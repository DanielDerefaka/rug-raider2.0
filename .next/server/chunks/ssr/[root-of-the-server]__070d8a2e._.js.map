{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file:///Users/macbookk/Desktop/CODES%20%F0%9F%98%8E/rug-raider/src/context/theme-provider.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport { ThemeProvider as NextThemesProvider } from 'next-themes'\nimport { type ThemeProviderProps } from 'next-themes/dist/types'\n\nexport function ThemeProvider({ children, ...props }: ThemeProviderProps) {\n  return <NextThemesProvider {...props}>{children}</NextThemesProvider>\n}\n"],"names":[],"mappings":";;;;AAGA;AAHA;;;AAMO,SAAS,cAAc,EAAE,QAAQ,EAAE,GAAG,OAA2B;IACtE,qBAAO,8OAAC,gJAAA,CAAA,gBAAkB;QAAE,GAAG,KAAK;kBAAG;;;;;;AACzC","debugId":null}},
    {"offset": {"line": 183, "column": 0}, "map": {"version":3,"sources":["file:///Users/macbookk/Desktop/CODES%20%F0%9F%98%8E/rug-raider/src/lib/solana-connection.ts"],"sourcesContent":["import { Connection, PublicKey, ConnectionConfig } from '@solana/web3.js';\n\n// RPC node configuration\nconst CONNECTION_CONFIG: ConnectionConfig = {\n  commitment: 'confirmed',\n  confirmTransactionInitialTimeout: 60000,\n  disableRetryOnRateLimit: true, // We'll handle rate limits ourselves\n};\n\n// List of available RPC endpoints - add more options for better fallback capabilities\nconst RPC_ENDPOINTS = [\n  // Your current endpoint\n  'https://mainnet.helius-rpc.com/?api-key=56ad7ab1-3b24-442a-9141-0b362594dac9',\n\n  \n\n];\n\n // Public RPCs (add these as backups)\n  // 'https://api.mainnet-beta.solana.com',\n  // 'https://solana-api.projectserum.com',\n  // 'https://rpc.ankr.com/solana', \n  // 'https://solana-mainnet.rpc.extrnode.com',\n  \n  // Add your Alchemy API if you have one (commented out for now)\n  // 'https://solana-mainnet.g.alchemy.com/v2/YOUR_API_KEY',\n\n// Tracking RPC request stats with enhanced metrics\ninterface EndpointStats {\n  url: string;\n  requestCount: number;\n  lastRequestTime: number;\n  errorCount: number;\n  consecutiveErrors: number;\n  lastErrorTime: number | null;\n  cooldownUntil: number | null;\n  avgResponseTime: number;\n  successRate: number;\n  requestLog: {\n    timestamp: number;\n    success: boolean;\n    responseTime?: number;\n  }[];\n}\n\n// Create a connection with intelligent endpoint selection\nclass SolanaConnectionManager {\n  private endpoints: string[] = RPC_ENDPOINTS;\n  private currentEndpointIndex = 0;\n  private connection: Connection;\n  \n  // Track endpoint stats to make smarter decisions\n  private endpointStats: EndpointStats[] = [];\n  \n  // Request throttling with per-endpoint tracking\n  private maxRequestsPerMinute = 45; // Conservative limit\n  private globalRequestsPerMinute = 100; // Global limit across all endpoints\n  private globalRequestLog: number[] = []; // Timestamps of all requests\n  \n  // Track pending requests to avoid overwhelming the node\n  private pendingRequests = 0;\n  private maxConcurrentRequests = 10;\n  \n  constructor() {\n    // Initialize stats for all endpoints\n    this.endpoints.forEach((url) => {\n      this.endpointStats.push({\n        url,\n        requestCount: 0,\n        lastRequestTime: 0,\n        errorCount: 0,\n        consecutiveErrors: 0,\n        lastErrorTime: null,\n        cooldownUntil: null,\n        avgResponseTime: 0,\n        successRate: 1.0, // Start optimistic\n        requestLog: [],\n      });\n    });\n    \n    // Start with first endpoint\n    this.connection = new Connection(\n      this.endpoints[this.currentEndpointIndex],\n      CONNECTION_CONFIG\n    );\n    \n    // Set up periodic health checks and stats calculation\n    this.setupPeriodicTasks();\n  }\n\n  // Get the current connection\n  getConnection(): Connection {\n    return this.connection;\n  }\n\n  // Setup periodic maintenance tasks\n  private setupPeriodicTasks(): void {\n    // Check endpoint health every 2 minutes\n    setInterval(() => {\n      this.checkEndpointHealth().catch(console.error);\n    }, 2 * 60 * 1000);\n    \n    // Recalculate endpoint stats every minute\n    setInterval(() => {\n      this.recalculateEndpointStats();\n    }, 60 * 1000);\n    \n    // Cleanup old request logs every 5 minutes\n    setInterval(() => {\n      this.cleanupOldLogs();\n    }, 5 * 60 * 1000);\n  }\n  \n  // Clean up old request logs to prevent memory bloat\n  private cleanupOldLogs(): void {\n    const now = Date.now();\n    const oneHourAgo = now - 60 * 60 * 1000;\n    \n    // Clean global request log\n    this.globalRequestLog = this.globalRequestLog.filter(time => time > oneHourAgo);\n    \n    // Clean endpoint-specific logs\n    this.endpointStats.forEach(stats => {\n      stats.requestLog = stats.requestLog.filter(log => log.timestamp > oneHourAgo);\n    });\n  }\n\n  // Check if we should throttle our requests\n  private shouldThrottle(endpointIndex: number): boolean {\n    const now = Date.now();\n    const stats = this.endpointStats[endpointIndex];\n    \n    // Check if endpoint is in cooldown\n    if (stats.cooldownUntil && now < stats.cooldownUntil) {\n      return true;\n    }\n    \n    // Count requests in the last minute for this endpoint\n    const recentRequests = stats.requestLog.filter(\n      log => log.timestamp > now - 60000\n    ).length;\n    \n    // Clean up old global timestamps (older than 1 minute)\n    this.globalRequestLog = this.globalRequestLog.filter(\n      time => time > now - 60000\n    );\n    \n    // Check if we're over our per-endpoint or global limits\n    const overPerEndpointLimit = recentRequests >= this.maxRequestsPerMinute;\n    const overGlobalLimit = this.globalRequestLog.length >= this.globalRequestsPerMinute;\n    const tooManyConcurrent = this.pendingRequests >= this.maxConcurrentRequests;\n    \n    return overPerEndpointLimit || overGlobalLimit || tooManyConcurrent;\n  }\n\n  // Recalculate endpoint statistics\n  private recalculateEndpointStats(): void {\n    const now = Date.now();\n    const recentWindow = now - 10 * 60 * 1000; // Last 10 minutes\n    \n    this.endpointStats.forEach(stats => {\n      const recentLogs = stats.requestLog.filter(log => log.timestamp > recentWindow);\n      \n      if (recentLogs.length > 0) {\n        // Calculate success rate\n        const successfulRequests = recentLogs.filter(log => log.success).length;\n        stats.successRate = successfulRequests / recentLogs.length;\n        \n        // Calculate average response time\n        const responseTimes = recentLogs\n          .filter(log => log.responseTime !== undefined)\n          .map(log => log.responseTime as number);\n          \n        if (responseTimes.length > 0) {\n          stats.avgResponseTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;\n        }\n      }\n    });\n  }\n\n  // Select the best endpoint to use based on comprehensive metrics\n  private selectBestEndpoint(): number {\n    const now = Date.now();\n    \n    // Step 1: Filter out endpoints in cooldown\n    let availableEndpoints = this.endpointStats\n      .map((stats, index) => ({ stats, index }))\n      .filter(({ stats }) => !stats.cooldownUntil || now > stats.cooldownUntil);\n    \n    // If all endpoints are in cooldown, use the one with shortest cooldown time\n    if (availableEndpoints.length === 0) {\n      const endpointsSorted = this.endpointStats\n        .map((stats, index) => ({ stats, index }))\n        .sort((a, b) => (a.stats.cooldownUntil || Infinity) - (b.stats.cooldownUntil || Infinity));\n      \n      return endpointsSorted[0].index;\n    }\n    \n    // Step 2: Score endpoints based on multiple factors\n    const scoredEndpoints = availableEndpoints.map(({ stats, index }) => {\n      // Calculate a score (higher is better)\n      const errorPenalty = stats.errorCount * 5;\n      const responsePenalty = stats.avgResponseTime / 50; // Penalty for slow responses\n      const successBonus = stats.successRate * 100;\n      \n      const score = successBonus - errorPenalty - responsePenalty;\n      \n      return { index, score };\n    });\n    \n    // Step 3: Sort by score and pick the best\n    scoredEndpoints.sort((a, b) => b.score - a.score);\n    return scoredEndpoints[0].index;\n  }\n\n  // Switch to best RPC endpoint\n  switchEndpoint(): Connection {\n    const previousEndpoint = this.currentEndpointIndex;\n    this.currentEndpointIndex = this.selectBestEndpoint();\n    \n    // Only create new connection if endpoint actually changed\n    if (previousEndpoint !== this.currentEndpointIndex) {\n      this.connection = new Connection(\n        this.endpoints[this.currentEndpointIndex],\n        CONNECTION_CONFIG\n      );\n      console.log(`Switched to RPC endpoint: ${this.endpoints[this.currentEndpointIndex]}`);\n    }\n    \n    return this.connection;\n  }\n\n  // Calculate dynamic backoff time based on consecutive errors and endpoint health\n  private calculateBackoffTime(endpointIndex: number): number {\n    const stats = this.endpointStats[endpointIndex];\n    \n    // Exponential backoff based on consecutive errors\n    // Start at 1 second, double each time, cap at 60 seconds\n    const baseTime = Math.min(1000 * Math.pow(2, stats.consecutiveErrors), 60000);\n    \n    // Add jitter to prevent all clients from retrying simultaneously\n    const jitter = Math.random() * 1000;\n    \n    return baseTime + jitter;\n  }\n\n  // Execute a function with advanced fallback, throttling, and retry logic\n  async executeWithFallback<T>(\n    fn: (connection: Connection) => Promise<T>,\n    maxRetries = 3\n  ): Promise<T> {\n    let retries = 0;\n    let result: T;\n    let lastError: Error | null = null;\n    \n    // Try until success or max retries reached\n    while (retries <= maxRetries) {\n      // Get best endpoint before each attempt\n      if (retries > 0) {\n        this.switchEndpoint();\n      }\n      \n      const endpointIndex = this.currentEndpointIndex;\n      const endpoint = this.endpoints[endpointIndex];\n      const stats = this.endpointStats[endpointIndex];\n      \n      // Check if we need to throttle requests\n      if (this.shouldThrottle(endpointIndex)) {\n        const backoffTime = this.calculateBackoffTime(endpointIndex);\n        console.warn(`Throttling requests to endpoint ${endpoint}. Waiting ${backoffTime}ms...`);\n        await new Promise(resolve => setTimeout(resolve, backoffTime));\n        continue; // Try again with possibly a different endpoint\n      }\n      \n      // Record this request timestamp for throttling (both global and endpoint-specific)\n      const now = Date.now();\n      this.globalRequestLog.push(now);\n      \n      // Create request log entry\n      const requestLogEntry = {\n        timestamp: now,\n        success: false,\n      };\n      stats.requestLog.push(requestLogEntry);\n      \n      // Update stats for current endpoint\n      stats.requestCount++;\n      stats.lastRequestTime = now;\n      this.pendingRequests++;\n      \n      // Measure response time\n      const startTime = performance.now();\n      \n      try {\n        // Execute the RPC call\n        result = await fn(this.connection);\n        \n        // Record successful request\n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n        \n        requestLogEntry.success = true;\n        requestLogEntry.responseTime = responseTime;\n        \n        // Reset consecutive error count on success\n        stats.consecutiveErrors = 0;\n        \n        // Recover slightly from previous errors\n        if (stats.errorCount > 0) {\n          stats.errorCount = Math.max(0, stats.errorCount - 0.5);\n        }\n        \n        this.pendingRequests--;\n        return result;\n      } catch (error: any) {\n        this.pendingRequests--;\n        const endTime = performance.now();\n        requestLogEntry.responseTime = endTime - startTime;\n        \n        const errorMessage = error?.message || '';\n        lastError = error;\n        \n        // Update error stats for current endpoint\n        stats.errorCount++;\n        stats.consecutiveErrors++;\n        stats.lastErrorTime = now;\n        \n        // Identify different types of RPC errors\n        const isRateLimit = \n          errorMessage.includes('429') || \n          errorMessage.includes('Too many requests') ||\n          errorMessage.includes('Rate limit exceeded');\n          \n        const isServerError = \n          errorMessage.includes('500') || \n          errorMessage.includes('502') ||\n          errorMessage.includes('503') ||\n          errorMessage.includes('504') ||\n          errorMessage.includes('Internal Server Error');\n          \n        const isAuthError = \n          errorMessage.includes('403') || \n          errorMessage.includes('401') ||\n          errorMessage.includes('Access forbidden') ||\n          errorMessage.includes('Unauthorized');\n        \n        // Apply different strategies based on error type\n        if (isRateLimit) {\n          // For rate limits, apply longer cooldown\n          const cooldownTime = Math.min(60000, stats.consecutiveErrors * 10000); // Max 60 sec\n          stats.cooldownUntil = now + cooldownTime;\n          \n          console.warn(`Rate limit (429) on endpoint ${endpoint}. Cooldown for ${cooldownTime/1000}s.`);\n          \n          // Immediate switch to another endpoint\n          this.switchEndpoint();\n        } else if (isServerError) {\n          // For server errors, apply short cooldown\n          const cooldownTime = Math.min(30000, stats.consecutiveErrors * 5000); // Max 30 sec\n          stats.cooldownUntil = now + cooldownTime;\n          \n          console.warn(`Server error on endpoint ${endpoint}. Cooldown for ${cooldownTime/1000}s.`);\n        } else if (isAuthError) {\n          // For auth errors, apply longer cooldown as they won't resolve quickly\n          stats.cooldownUntil = now + 5 * 60 * 1000; // 5 minutes\n          \n          console.warn(`Auth error on endpoint ${endpoint}. Cooldown for 5 minutes.`);\n        }\n        \n        if (retries < maxRetries) {\n          // Apply backoff before retry\n          const backoffTime = this.calculateBackoffTime(endpointIndex);\n          \n          console.warn(`RPC error (${errorMessage}). Retrying in ${backoffTime/1000}s (${retries + 1}/${maxRetries})`);\n          await new Promise(resolve => setTimeout(resolve, backoffTime));\n          \n          retries++;\n        } else {\n          console.error(`Exhausted all retries (${maxRetries}). Last error:`, error);\n          throw error;\n        }\n      }\n    }\n    \n    throw lastError || new Error('Exhausted all RPC fallback attempts');\n  }\n\n  // Add a custom RPC endpoint\n  addEndpoint(url: string): void {\n    // Check if endpoint already exists\n    if (!this.endpoints.includes(url)) {\n      this.endpoints.push(url);\n      \n      // Initialize stats for the new endpoint\n      this.endpointStats.push({\n        url,\n        requestCount: 0,\n        lastRequestTime: 0,\n        errorCount: 0,\n        consecutiveErrors: 0,\n        lastErrorTime: null,\n        cooldownUntil: null,\n        avgResponseTime: 0,\n        successRate: 1.0, // Start optimistic\n        requestLog: [],\n      });\n      \n      console.log(`Added new RPC endpoint: ${url}`);\n    }\n  }\n  \n  // Remove an RPC endpoint\n  removeEndpoint(url: string): void {\n    const index = this.endpoints.indexOf(url);\n    if (index >= 0) {\n      this.endpoints.splice(index, 1);\n      this.endpointStats.splice(index, 1);\n      \n      // If current endpoint was removed, switch to another\n      if (this.currentEndpointIndex === index) {\n        this.switchEndpoint();\n      } else if (this.currentEndpointIndex > index) {\n        // Adjust current index if it's after the removed one\n        this.currentEndpointIndex--;\n      }\n      \n      console.log(`Removed RPC endpoint: ${url}`);\n    }\n  }\n  \n  // Prioritize a specific endpoint\n  prioritizeEndpoint(url: string): void {\n    const index = this.endpoints.indexOf(url);\n    if (index >= 0) {\n      // Reset errors and cooldown\n      const stats = this.endpointStats[index];\n      stats.errorCount = 0;\n      stats.consecutiveErrors = 0;\n      stats.cooldownUntil = null;\n      \n      // Switch to this endpoint\n      this.currentEndpointIndex = index;\n      this.connection = new Connection(url, CONNECTION_CONFIG);\n      \n      console.log(`Prioritized RPC endpoint: ${url}`);\n    }\n  }\n\n  // Check endpoint health and dynamically adjust request limits\n  async checkEndpointHealth(): Promise<void> {\n    // Test all endpoints with a simple request\n    for (let i = 0; i < this.endpoints.length; i++) {\n      const endpoint = this.endpoints[i];\n      const stats = this.endpointStats[i];\n      \n      // Skip endpoints in cooldown\n      if (stats.cooldownUntil && Date.now() < stats.cooldownUntil) {\n        continue;\n      }\n      \n      // Create isolated connection for health check\n      const connection = new Connection(endpoint, CONNECTION_CONFIG);\n      \n      try {\n        // Measure response time\n        const startTime = performance.now();\n        \n        // Simple health check\n        await connection.getSlot();\n        \n        const endTime = performance.now();\n        const responseTime = endTime - startTime;\n        \n        // Update success stats\n        stats.requestLog.push({\n          timestamp: Date.now(),\n          success: true,\n          responseTime\n        });\n        \n        // Reset error counts slightly for successful check\n        stats.consecutiveErrors = 0;\n        if (stats.errorCount > 0) {\n          stats.errorCount = Math.max(0, stats.errorCount - 1);\n        }\n      } catch (error) {\n        console.warn(`Health check failed for endpoint ${endpoint}:`, error);\n        \n        // Log failure\n        stats.requestLog.push({\n          timestamp: Date.now(),\n          success: false\n        });\n        \n        stats.errorCount++;\n        stats.consecutiveErrors++;\n      }\n    }\n    \n    // Recalculate stats after health checks\n    this.recalculateEndpointStats();\n  }\n  \n  // Get health status for reporting\n  getEndpointStatus(): {\n    currentEndpoint: string;\n    endpointStats: {\n      url: string;\n      status: 'healthy' | 'degraded' | 'unhealthy' | 'cooldown';\n      successRate: number;\n      avgResponseTime: number;\n      errorCount: number;\n      inCooldown: boolean;\n    }[];\n  } {\n    const currentEndpoint = this.endpoints[this.currentEndpointIndex];\n    const now = Date.now();\n    \n    return {\n      currentEndpoint,\n      endpointStats: this.endpointStats.map(stats => {\n        // Determine status\n        let status: 'healthy' | 'degraded' | 'unhealthy' | 'cooldown';\n        \n        if (stats.cooldownUntil && now < stats.cooldownUntil) {\n          status = 'cooldown';\n        } else if (stats.successRate > 0.9 && stats.consecutiveErrors === 0) {\n          status = 'healthy';\n        } else if (stats.successRate > 0.5) {\n          status = 'degraded';\n        } else {\n          status = 'unhealthy';\n        }\n        \n        return {\n          url: stats.url,\n          status,\n          successRate: Math.round(stats.successRate * 100) / 100,\n          avgResponseTime: Math.round(stats.avgResponseTime),\n          errorCount: stats.errorCount,\n          inCooldown: !!(stats.cooldownUntil && now < stats.cooldownUntil)\n        };\n      })\n    };\n  }\n}\n\n// Create and export a singleton instance\nexport const connectionManager = new SolanaConnectionManager();\n\n// Helper function to get the current connection\nexport const getConnection = (): Connection => {\n  return connectionManager.getConnection();\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 588, "column": 0}, "map": {"version":3,"sources":["file:///Users/macbookk/Desktop/CODES%20%F0%9F%98%8E/rug-raider/src/lib/solana.ts"],"sourcesContent":["// token-utils.ts\nimport {\n  PublicKey,\n  ParsedAccountData,\n  ConfirmedSignatureInfo,\n  ParsedTransactionWithMeta,\n  Transaction,\n  SystemProgram,\n} from '@solana/web3.js';\nimport {\n  TOKEN_PROGRAM_ID,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  getAssociatedTokenAddress,\n  createAssociatedTokenAccountInstruction,\n  Account,\n  TokenAccountNotFoundError,\n  getAccount,\n  TokenInvalidAccountOwnerError,\n  createTransferInstruction,\n} from '@solana/spl-token';\nimport { WalletToken } from '@/types/token';\nimport { connectionManager } from './solana-connection';\n\n// Cache results to reduce RPC calls\nconst tokenMetadataCache: Record<string, {\n  data: any; \n  timestamp: number;\n}> = {};\nconst tokenAccountsCache: Record<string, {\n  data: { pubkey: PublicKey; account: ParsedAccountData }[];\n  timestamp: number;\n}> = {};\nconst riskAssessmentCache: Record<string, {\n  data: any;\n  timestamp: number;\n}> = {};\n\n// Cache expiration times (in milliseconds)\nconst CACHE_TIMES = {\n  TOKEN_METADATA: 30 * 60 * 1000, // 30 minutes\n  TOKEN_ACCOUNTS: 30 * 1000,      // 30 seconds\n  RISK_ASSESSMENT: 60 * 60 * 1000, // 1 hour\n};\n\n// Get token accounts for a wallet with fallback RPC support and caching\nexport async function getTokenAccounts(\n  walletAddress: string\n): Promise<{ pubkey: PublicKey; account: ParsedAccountData }[]> {\n  try {\n    // Check cache first\n    const cacheKey = `accounts:${walletAddress}`;\n    const cachedData = tokenAccountsCache[cacheKey];\n    \n    if (cachedData && (Date.now() - cachedData.timestamp < CACHE_TIMES.TOKEN_ACCOUNTS)) {\n      return cachedData.data;\n    }\n    \n    const walletPublicKey = new PublicKey(walletAddress);\n    \n    // Use the connection manager with improved fallback capability\n    const accounts = await connectionManager.executeWithFallback(async (connection) => {\n      const tokenResp = await connection.getParsedTokenAccountsByOwner(\n        walletPublicKey,\n        {\n          programId: TOKEN_PROGRAM_ID,\n        }\n      );\n      \n      return tokenResp.value;\n    });\n    \n    // Update cache\n    tokenAccountsCache[cacheKey] = {\n      data: accounts,\n      timestamp: Date.now()\n    };\n    \n    return accounts;\n  } catch (error) {\n    console.error('Error fetching token accounts:', error);\n    \n    // Return cached data even if expired in case of error\n    const cacheKey = `accounts:${walletAddress}`;\n    const cachedData = tokenAccountsCache[cacheKey];\n    \n    if (cachedData) {\n      console.log('Returning cached token accounts data due to RPC error');\n      return cachedData.data;\n    }\n    \n    throw error;\n  }\n}\n\n// Format token account data with risk assessment and caching\nexport async function getWalletTokens(walletAddress: string): Promise<WalletToken[]> {\n  try {\n    const accounts = await getTokenAccounts(walletAddress);\n    \n    // Filter to only include accounts with non-zero balance\n    const filteredAccounts = accounts.filter(\n      (acc) => parseInt(acc.account.data.parsed.info.tokenAmount.amount) > 0\n    );\n\n    // Map account data to WalletToken format\n    const tokens = filteredAccounts.map((acc) => {\n      const parsedInfo = acc.account.data.parsed.info;\n      \n      return {\n        mint: parsedInfo.mint,\n        owner: walletAddress,\n        amount: parsedInfo.tokenAmount.amount,\n        decimals: parsedInfo.tokenAmount.decimals,\n        uiAmount: parsedInfo.tokenAmount.uiAmount,\n      };\n    });\n\n    // Get metadata and risk assessment for each token (with batch processing)\n    // Process tokens in batches to avoid overwhelming RPC nodes\n    const BATCH_SIZE = 5;\n    const tokensWithMetadata: WalletToken[] = [];\n    \n    for (let i = 0; i < tokens.length; i += BATCH_SIZE) {\n      const batch = tokens.slice(i, i + BATCH_SIZE);\n      \n      const batchResults = await Promise.all(\n        batch.map(async (token) => {\n          // Fetch metadata and risk assessment in parallel, with caching\n          const [metadata, riskAssessment] = await Promise.all([\n            getTokenMetadata(token.mint),\n            analyzeTokenRisks(token.mint),\n          ]);\n\n          // Determine risk level\n          let riskLevel: 'low' | 'medium' | 'high' | 'critical' | undefined = undefined;\n          \n          if (riskAssessment) {\n            const { hasHighSupply, hasLowLiquidity, hasLargeHolders, isNewToken, hasSuspiciousTransactions } = riskAssessment;\n            \n            // Calculate risk score (simple heuristic)\n            let riskFactors = 0;\n            if (hasHighSupply) riskFactors++;\n            if (hasLowLiquidity) riskFactors += 2;\n            if (hasLargeHolders) riskFactors += 2;\n            if (isNewToken) riskFactors++;\n            if (hasSuspiciousTransactions) riskFactors += 3;\n            \n            // Assign risk level\n            if (riskFactors >= 5) riskLevel = 'critical';\n            else if (riskFactors >= 3) riskLevel = 'high';\n            else if (riskFactors >= 1) riskLevel = 'medium';\n            else riskLevel = 'low';\n          }\n\n          return {\n            ...token,\n            name: metadata?.name || 'Unknown Token',\n            symbol: metadata?.symbol || '',\n            logoURI: metadata?.logoURI,\n            riskLevel,\n            riskFactors: riskAssessment || {},\n          };\n        })\n      );\n      \n      tokensWithMetadata.push(...batchResults);\n      \n      // If there are more batches to process, add a small delay to avoid rate limiting\n      if (i + BATCH_SIZE < tokens.length) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n    }\n\n    return tokensWithMetadata;\n  } catch (error) {\n    console.error('Error formatting wallet tokens:', error);\n    throw error;\n  }\n}\n\n// Get recent transactions for a wallet with fallback and exponential backoff\nexport async function getRecentTransactions(\n  walletAddress: string,\n  limit: number = 10\n): Promise<ConfirmedSignatureInfo[]> {\n  try {\n    const walletPublicKey = new PublicKey(walletAddress);\n    \n    return await connectionManager.executeWithFallback(\n      async (connection) => {\n        return await connection.getSignaturesForAddress(\n          walletPublicKey,\n          { limit }\n        );\n      },\n      'confirmed',\n      5, // More retries for transaction history\n      300 // Lower initial delay for faster first retry\n    );\n  } catch (error) {\n    console.error('Error fetching recent transactions:', error);\n    throw error;\n  }\n}\n\n// Get parsed transaction details with fallback\nexport async function getTransactionDetails(\n  signature: string\n): Promise<ParsedTransactionWithMeta | null> {\n  try {\n    return await connectionManager.executeWithFallback(\n      async (connection) => {\n        return await connection.getParsedTransaction(\n          signature,\n          'confirmed'\n        );\n      }\n    );\n  } catch (error) {\n    console.error('Error fetching transaction details:', error);\n    throw error;\n  }\n}\n\n// Check if token account exists with caching\nexport async function checkTokenAccount(\n  walletAddress: string,\n  mintAddress: string\n): Promise<Account | null> {\n  try {\n    const walletPublicKey = new PublicKey(walletAddress);\n    const mintPublicKey = new PublicKey(mintAddress);\n    \n    // Get associated token account\n    const tokenAddress = await getAssociatedTokenAddress(\n      mintPublicKey,\n      walletPublicKey\n    );\n    \n    try {\n      // Check if account exists and get balance\n      return await connectionManager.executeWithFallback(async (connection) => {\n        return await getAccount(connection, tokenAddress);\n      });\n    } catch (error) {\n      if (\n        error instanceof TokenAccountNotFoundError ||\n        error instanceof TokenInvalidAccountOwnerError\n      ) {\n        // Account doesn't exist\n        return null;\n      }\n      throw error;\n    }\n  } catch (error) {\n    console.error('Error checking token account:', error);\n    throw error;\n  }\n}\n\n// Get token metadata with caching\nexport async function getTokenMetadata(mintAddress: string): Promise<{\n  name?: string;\n  symbol?: string;\n  logoURI?: string;\n} | null> {\n  try {\n    // Check cache first\n    const cacheKey = `metadata:${mintAddress}`;\n    const cachedData = tokenMetadataCache[cacheKey];\n    \n    if (cachedData && (Date.now() - cachedData.timestamp < CACHE_TIMES.TOKEN_METADATA)) {\n      return cachedData.data;\n    }\n    \n    // Implement a circuit breaker pattern for the token API calls\n    const fetchWithTimeout = async (url: string, timeout = 5000) => {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n      \n      try {\n        const response = await fetch(url, { signal: controller.signal });\n        clearTimeout(timeoutId);\n        return response;\n      } catch (error) {\n        clearTimeout(timeoutId);\n        throw error;\n      }\n    };\n    \n    // First try to get from Jupiter Aggregator token list (more comprehensive)\n    try {\n      const jupiterResponse = await fetchWithTimeout('https://token.jup.ag/all');\n      if (jupiterResponse.ok) {\n        const jupiterTokens = await jupiterResponse.json();\n        const token = jupiterTokens.find((t: any) => t.address === mintAddress);\n        \n        if (token) {\n          const metadata = {\n            name: token.name,\n            symbol: token.symbol,\n            logoURI: token.logoURI\n          };\n          \n          // Update cache\n          tokenMetadataCache[cacheKey] = {\n            data: metadata,\n            timestamp: Date.now()\n          };\n          \n          return metadata;\n        }\n      }\n    } catch (error) {\n      console.warn('Jupiter token list fetch failed, falling back to Solana list:', error);\n    }\n    \n    // Fallback to Solana token list\n    try {\n      const response = await fetchWithTimeout('https://cdn.jsdelivr.net/gh/solana-labs/token-list@main/src/tokens/solana.tokenlist.json');\n      if (response.ok) {\n        const tokenList = await response.json();\n        const token = tokenList.tokens.find((t: any) => t.address === mintAddress);\n        \n        if (token) {\n          const metadata = {\n            name: token.name,\n            symbol: token.symbol,\n            logoURI: token.logoURI\n          };\n          \n          // Update cache\n          tokenMetadataCache[cacheKey] = {\n            data: metadata,\n            timestamp: Date.now()\n          };\n          \n          return metadata;\n        }\n      }\n    } catch (error) {\n      console.warn('Solana token list fetch failed:', error);\n    }\n    \n    // If not found in token lists, token might be unlisted\n    const unknownToken = {\n      name: 'Unknown Token',\n      symbol: '???',\n      logoURI: undefined\n    };\n    \n    // Cache the unknown result too\n    tokenMetadataCache[cacheKey] = {\n      data: unknownToken,\n      timestamp: Date.now()\n    };\n    \n    return unknownToken;\n  } catch (error) {\n    console.error('Error fetching token metadata:', error);\n    \n    // Return cached data even if expired in case of error\n    const cacheKey = `metadata:${mintAddress}`;\n    const cachedData = tokenMetadataCache[cacheKey];\n    \n    if (cachedData) {\n      return cachedData.data;\n    }\n    \n    return null;\n  }\n}\n\n// Check for potential token risks with caching\nexport async function analyzeTokenRisks(mintAddress: string): Promise<{\n  hasHighSupply: boolean;\n  hasLowLiquidity: boolean;\n  hasLargeHolders: boolean;\n  isNewToken: boolean;\n  hasSuspiciousTransactions: boolean;\n} | null> {\n  try {\n    // Check cache first\n    const cacheKey = `risk:${mintAddress}`;\n    const cachedData = riskAssessmentCache[cacheKey];\n    \n    if (cachedData && (Date.now() - cachedData.timestamp < CACHE_TIMES.RISK_ASSESSMENT)) {\n      return cachedData.data;\n    }\n    \n    const mintPublicKey = new PublicKey(mintAddress);\n    \n    const riskData = await connectionManager.executeWithFallback(async (connection) => {\n      try {\n        // Get token supply with retries and backoff\n        const supplyPromise = connection.getTokenSupply(mintPublicKey)\n          .catch(error => {\n            console.warn('Error getting token supply, skipping this metric:', error);\n            return { value: { amount: '0' } };\n          });\n        \n        // Get larger token holders with retries and backoff\n        const holdersPromise = connection.getTokenLargestAccounts(mintPublicKey)\n          .catch(error => {\n            console.warn('Error getting token holders, skipping this metric:', error);\n            return { value: [] };\n          });\n        \n        // Get token creation info with retries and backoff\n        const signaturesPromise = connection.getSignaturesForAddress(mintPublicKey, { limit: 1 })\n          .catch(error => {\n            console.warn('Error getting token signatures, skipping this metric:', error);\n            return [];\n          });\n        \n        // Execute all queries in parallel\n        const [supply, largestAccounts, signatures] = await Promise.all([\n          supplyPromise,\n          holdersPromise,\n          signaturesPromise\n        ]);\n        \n        // Token creation date check\n        const isNewToken = signatures.length > 0 && \n          (new Date().getTime() - new Date(signatures[0].blockTime! * 1000).getTime()) < 7 * 24 * 60 * 60 * 1000; // 7 days\n        \n        // Analyze token distribution\n        const totalAccounts = largestAccounts.value.length;\n        const largestHolderPercentage = largestAccounts.value[0] ? \n          parseInt(largestAccounts.value[0].amount) / parseInt(supply.value.amount) : 0;\n        \n        const riskAssessment = {\n          hasHighSupply: parseInt(supply.value.amount) > 1_000_000_000_000_000, // Very high supply\n          hasLowLiquidity: totalAccounts < 10, // Low number of holders\n          hasLargeHolders: largestHolderPercentage > 0.8, // Single holder owns >80%\n          isNewToken: isNewToken,\n          hasSuspiciousTransactions: false, // Would require deeper transaction analysis\n        };\n        \n        // Update cache\n        riskAssessmentCache[cacheKey] = {\n          data: riskAssessment,\n          timestamp: Date.now()\n        };\n        \n        return riskAssessment;\n      } catch (error) {\n        console.warn('Error in token risk analysis, continuing with partial data:', error);\n        // Return default values in case of error with this specific analysis\n        const defaultRisk = {\n          hasHighSupply: false,\n          hasLowLiquidity: false,\n          hasLargeHolders: false,\n          isNewToken: false,\n          hasSuspiciousTransactions: false,\n        };\n        \n        // Update cache even for default values\n        riskAssessmentCache[cacheKey] = {\n          data: defaultRisk,\n          timestamp: Date.now()\n        };\n        \n        return defaultRisk;\n      }\n    });\n    \n    return riskData;\n  } catch (error) {\n    console.error('Error analyzing token risks:', error);\n    \n    // Return cached data even if expired in case of error\n    const cacheKey = `risk:${mintAddress}`;\n    const cachedData = riskAssessmentCache[cacheKey];\n    \n    if (cachedData) {\n      return cachedData.data;\n    }\n    \n    return null;\n  }\n}\n\n// Create an associated token account if it doesn't exist\nexport async function createTokenAccountIfNeeded(\n  wallet: any,\n  mintAddress: string\n): Promise<string> {\n  try {\n    const walletPublicKey = wallet.publicKey;\n    const mintPublicKey = new PublicKey(mintAddress);\n    \n    // Get associated token account address\n    const tokenAddress = await getAssociatedTokenAddress(\n      mintPublicKey,\n      walletPublicKey\n    );\n    \n    // Check if account exists\n    try {\n      await connectionManager.executeWithFallback(async (connection) => {\n        return await getAccount(connection, tokenAddress);\n      });\n      return tokenAddress.toString();\n    } catch (error) {\n      if (\n        error instanceof TokenAccountNotFoundError ||\n        error instanceof TokenInvalidAccountOwnerError\n      ) {\n        // Account doesn't exist, create it\n        return await connectionManager.executeWithFallback(async (connection) => {\n          const transaction = new Transaction().add(\n            createAssociatedTokenAccountInstruction(\n              walletPublicKey,\n              tokenAddress,\n              walletPublicKey,\n              mintPublicKey\n            )\n          );\n          \n          const signature = await wallet.sendTransaction(transaction, connection);\n          await connection.confirmTransaction(signature, 'confirmed');\n          \n          return tokenAddress.toString();\n        });\n      }\n      throw error;\n    }\n  } catch (error) {\n    console.error('Error creating token account:', error);\n    throw error;\n  }\n}\n\n// Clear all caches (useful for testing or when changing networks)\nexport function clearTokenCaches(): void {\n  Object.keys(tokenMetadataCache).forEach(key => {\n    delete tokenMetadataCache[key];\n  });\n  \n  Object.keys(tokenAccountsCache).forEach(key => {\n    delete tokenAccountsCache[key];\n  });\n  \n  Object.keys(riskAssessmentCache).forEach(key => {\n    delete riskAssessmentCache[key];\n  });\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 993, "column": 0}, "map": {"version":3,"sources":["file:///Users/macbookk/Desktop/CODES%20%F0%9F%98%8E/rug-raider/src/context/WalletContext.tsx"],"sourcesContent":["'use client';\n\nimport React, { createContext, useContext, ReactNode, useState, useEffect } from 'react';\nimport { \n  ConnectionProvider, \n  WalletProvider as SolanaWalletProvider,\n  useWallet,\n  useConnection\n} from '@solana/wallet-adapter-react';\nimport { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\nimport { \n  PhantomWalletAdapter,\n  SolflareWalletAdapter,\n  TorusWalletAdapter,\n  LedgerWalletAdapter,\n  CloverWalletAdapter\n} from '@solana/wallet-adapter-wallets';\nimport { WalletModalProvider } from '@solana/wallet-adapter-react-ui';\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { WalletToken } from '@/types/token';\nimport { getWalletTokens } from '@/lib/solana';\nimport { getConnection } from '@/lib/solana-connection';\n\n// Import wallet adapter CSS\nimport '@solana/wallet-adapter-react-ui/styles.css';\n\ninterface WalletContextValue {\n  walletAddress: string | null;\n  connected: boolean;\n  tokens: WalletToken[];\n  isLoadingTokens: boolean;\n  error: string | null;\n  riskSummary: {\n    highRiskCount: number;\n    mediumRiskCount: number;\n    lowRiskCount: number;\n    unknownCount: number;\n    totalTokens: number;\n  };\n  refreshTokens: () => Promise<void>;\n  clearError: () => void;\n}\n\n// Create context with defaults\nconst WalletContext = createContext<WalletContextValue>({\n  walletAddress: null,\n  connected: false,\n  tokens: [],\n  isLoadingTokens: false,\n  error: null,\n  riskSummary: {\n    highRiskCount: 0,\n    mediumRiskCount: 0,\n    lowRiskCount: 0,\n    unknownCount: 0,\n    totalTokens: 0,\n  },\n  refreshTokens: async () => {},\n  clearError: () => {},\n});\n\nexport const useWalletContext = () => useContext(WalletContext);\n\nexport const WalletContextProvider = ({ children }: { children: ReactNode }) => {\n  // Configure Solana network\n  const network = WalletAdapterNetwork.Mainnet;\n  \n  // Use our custom RPC connection configuration\n  // Instead of clusterApiUrl(network), we now use our managed connection\n  const endpoint = getConnection().rpcEndpoint;\n  \n  // Set up wallet adapters\n  const wallets = [\n    new PhantomWalletAdapter(),\n    new SolflareWalletAdapter(),\n    new TorusWalletAdapter(),\n    new LedgerWalletAdapter(),\n    new CloverWalletAdapter()\n  ];\n  \n  return (\n    <ConnectionProvider endpoint={endpoint}>\n      <SolanaWalletProvider wallets={wallets} autoConnect>\n        <WalletModalProvider>\n          <WalletDataProvider>\n            {children}\n          </WalletDataProvider>\n        </WalletModalProvider>\n      </SolanaWalletProvider>\n    </ConnectionProvider>\n  );\n};\n\n// Inner provider that handles the data\nconst WalletDataProvider = ({ children }: { children: ReactNode }) => {\n  const { publicKey, connected } = useWallet();\n  \n  const walletAddress = publicKey?.toBase58() || null;\n  \n  const [tokens, setTokens] = useState<WalletToken[]>([]);\n  const [isLoadingTokens, setIsLoadingTokens] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [lastFetchAttempt, setLastFetchAttempt] = useState<number>(0);\n  \n  // Calculate risk summary\n  const riskSummary = {\n    highRiskCount: tokens.filter(t => t.riskLevel === 'high' || t.riskLevel === 'critical').length,\n    mediumRiskCount: tokens.filter(t => t.riskLevel === 'medium').length,\n    lowRiskCount: tokens.filter(t => t.riskLevel === 'low').length,\n    unknownCount: tokens.filter(t => !t.riskLevel).length,\n    totalTokens: tokens.length,\n  };\n  \n  // Clear error state\n  const clearError = () => {\n    setError(null);\n  };\n  \n  // Fetch tokens with error handling and debouncing\n  const fetchTokens = async () => {\n    if (!walletAddress) {\n      setTokens([]);\n      return;\n    }\n    \n    // Avoid repeated fetching on errors (simple debouncing)\n    const now = Date.now();\n    if (now - lastFetchAttempt < 10000) {\n      return;\n    }\n    \n    setLastFetchAttempt(now);\n    setIsLoadingTokens(true);\n    setError(null);\n    \n    try {\n      const walletTokens = await getWalletTokens(walletAddress);\n      setTokens(walletTokens);\n    } catch (error: any) {\n      console.error('Error fetching wallet tokens:', error);\n      \n      // Format a user-friendly error message\n      let errorMessage = 'Failed to load tokens. ';\n      \n      if (error?.message?.includes('403') || error?.message?.includes('Access forbidden')) {\n        errorMessage += 'The RPC server connection was blocked. This could be due to rate limiting.';\n      } else if (error?.message?.includes('429') || error?.message?.includes('Too many requests')) {\n        errorMessage += 'Too many requests to the Solana network. Please try again in a moment.';\n      } else if (error?.message?.includes('timeout')) {\n        errorMessage += 'The connection to Solana network timed out. Please check your internet connection.';\n      } else {\n        errorMessage += error?.message || 'Unknown error occurred.';\n      }\n      \n      setError(errorMessage);\n      \n      // Return a minimal set of tokens if we have them cached\n      // This allows the UI to continue functioning with stale data if needed\n    } finally {\n      setIsLoadingTokens(false);\n    }\n  };\n  \n  // Refresh tokens (for manual refresh)\n  const refreshTokens = async () => {\n    // Reset last fetch attempt to force a refresh\n    setLastFetchAttempt(0);\n    await fetchTokens();\n  };\n  \n  // Initial fetch and refresh on wallet change\n  useEffect(() => {\n    if (connected && walletAddress) {\n      fetchTokens();\n    } else {\n      setTokens([]);\n      clearError();\n    }\n  }, [walletAddress, connected]);\n  \n  const contextValue: WalletContextValue = {\n    walletAddress,\n    connected,\n    tokens,\n    isLoadingTokens,\n    error,\n    riskSummary,\n    refreshTokens,\n    clearError,\n  };\n  \n  return (\n    <WalletContext.Provider value={contextValue}>\n      {children}\n    </WalletContext.Provider>\n  );\n};\n\nexport default WalletContextProvider;"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1184, "column": 0}, "map": {"version":3,"sources":["file:///Users/macbookk/Desktop/CODES%20%F0%9F%98%8E/rug-raider/src/react-query/index.tsx"],"sourcesContent":["'use client';\n\nimport { ReactNode } from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { WalletContextProvider } from '@/context/WalletContext';\n// import { NotificationProvider } from '@/contexts/NotificationContext';\n// import { TokenAnalysisProvider } from '@/contexts/TokenAnalysisContext';\n\n// Create a client\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      refetchOnWindowFocus: false,\n      retry: 1,\n    },\n  },\n});\n\nexport function Providers({ children }: { children: ReactNode }) {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <WalletContextProvider>\n        {/* <TokenAnalysisProvider>\n          <NotificationProvider> */}\n            {children}\n          {/* </NotificationProvider>\n        </TokenAnalysisProvider> */}\n      </WalletContextProvider>\n    </QueryClientProvider>\n  );\n}"],"names":[],"mappings":";;;;AAGA;AAAA;AACA;AAJA;;;;AAKA,yEAAyE;AACzE,2EAA2E;AAE3E,kBAAkB;AAClB,MAAM,cAAc,IAAI,6KAAA,CAAA,cAAW,CAAC;IAClC,gBAAgB;QACd,SAAS;YACP,sBAAsB;YACtB,OAAO;QACT;IACF;AACF;AAEO,SAAS,UAAU,EAAE,QAAQ,EAA2B;IAC7D,qBACE,8OAAC,sLAAA,CAAA,sBAAmB;QAAC,QAAQ;kBAC3B,cAAA,8OAAC,gIAAA,CAAA,wBAAqB;sBAGf;;;;;;;;;;;AAMb","debugId":null}}]
}