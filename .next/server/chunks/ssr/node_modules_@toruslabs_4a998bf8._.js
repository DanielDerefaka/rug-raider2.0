module.exports = {

"[project]/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BasePostMessageStream": (()=>BasePostMessageStream),
    "EthereumProviderError": (()=>EthereumProviderError),
    "IGNORE_SUBSTREAM": (()=>IGNORE_SUBSTREAM),
    "JRPCEngine": (()=>JRPCEngine),
    "JSON_RPC_SERVER_ERROR_MESSAGE": (()=>JSON_RPC_SERVER_ERROR_MESSAGE),
    "JsonRpcError": (()=>JsonRpcError),
    "ObjectMultiplex": (()=>ObjectMultiplex),
    "PostMessageStream": (()=>PostMessageStream),
    "SafeEventEmitter": (()=>SafeEventEmitter),
    "SerializableError": (()=>SerializableError),
    "Substream": (()=>Substream),
    "createAsyncMiddleware": (()=>createAsyncMiddleware),
    "createEngineStream": (()=>createEngineStream),
    "createErrorMiddleware": (()=>createErrorMiddleware),
    "createIdRemapMiddleware": (()=>createIdRemapMiddleware),
    "createLoggerMiddleware": (()=>createLoggerMiddleware),
    "createScaffoldMiddleware": (()=>createScaffoldMiddleware),
    "createStreamMiddleware": (()=>createStreamMiddleware),
    "dataHasCause": (()=>dataHasCause),
    "errorCodes": (()=>errorCodes),
    "errorValues": (()=>errorValues),
    "getMessageFromCode": (()=>getMessageFromCode),
    "getRpcPromiseCallback": (()=>getRpcPromiseCallback),
    "isObject": (()=>isObject),
    "isPlainObject": (()=>isPlainObject),
    "isValidCode": (()=>isValidCode),
    "isValidString": (()=>isValidString),
    "mergeMiddleware": (()=>mergeMiddleware),
    "providerAsMiddleware": (()=>providerAsMiddleware),
    "providerErrors": (()=>providerErrors),
    "providerFromEngine": (()=>providerFromEngine),
    "providerFromMiddleware": (()=>providerFromMiddleware),
    "rpcErrors": (()=>rpcErrors),
    "serializeCause": (()=>serializeCause),
    "serializeError": (()=>serializeError),
    "setupMultiplex": (()=>setupMultiplex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$readable$2d$stream$2f$lib$2f$ours$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/readable-stream/lib/ours/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$safe$2d$stringify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-safe-stringify/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$events__$5b$external$5d$__$28$events$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/events [external] (events, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$end$2d$of$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/end-of-stream/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$once$2f$once$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/once/once.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pump$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pump/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
function noop() {
    return undefined;
}
const SYN = "SYN";
const ACK = "ACK";
const BRK = "BRK";
class BasePostMessageStream extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$readable$2d$stream$2f$lib$2f$ours$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Duplex"] {
    constructor(_ref){
        let { name, target, targetWindow = window, targetOrigin = "*" } = _ref;
        super({
            objectMode: true
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_init", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_haveSyn", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_name", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_target", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_targetWindow", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_targetOrigin", void 0);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_onMessage", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_synIntervalId", void 0);
        if (!name || !target) {
            throw new Error("Invalid input.");
        }
        this._init = false;
        this._haveSyn = false;
        this._name = name;
        this._target = target; // target origin
        this._targetWindow = targetWindow;
        this._targetOrigin = targetOrigin;
        this._onMessage = this.onMessage.bind(this);
        this._synIntervalId = null;
        window.addEventListener("message", this._onMessage, false);
        this._handShake();
    }
    _break() {
        this.cork();
        this._write(BRK, null, noop);
        this._haveSyn = false;
        this._init = false;
    }
    _handShake() {
        this._write(SYN, null, noop);
        this.cork();
    }
    _onData(data) {
        if (!this._init) {
            // listen for handshake
            if (data === SYN) {
                this._haveSyn = true;
                this._write(ACK, null, noop);
            } else if (data === ACK) {
                this._init = true;
                if (!this._haveSyn) {
                    this._write(ACK, null, noop);
                }
                this.uncork();
            }
        } else if (data === BRK) {
            this._break();
        } else {
            // forward message
            try {
                this.push(data);
            } catch (err) {
                this.emit("error", err);
            }
        }
    }
    _postMessage(data) {
        const originConstraint = this._targetOrigin;
        this._targetWindow.postMessage({
            target: this._target,
            data
        }, originConstraint);
    }
    onMessage(event) {
        const message = event.data;
        // validate message
        if (this._targetOrigin !== "*" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== "object" || message.target !== this._name || !message.data) {
            return;
        }
        this._onData(message.data);
    }
    _read() {
        return undefined;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _write(data, _, cb) {
        this._postMessage(data);
        cb();
    }
    _destroy() {
        window.removeEventListener("message", this._onMessage, false);
    }
}
const errorCodes = {
    rpc: {
        invalidInput: -32000,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
    },
    provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
    }
};
const errorValues = {
    "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
    },
    "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
    },
    "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
    },
    "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
    },
    "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
    },
    "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
    },
    "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
    },
    "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
    },
    "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
    },
    "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
    },
    "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
    },
    "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
    },
    "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
    },
    "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
    }
};
const FALLBACK_ERROR_CODE = errorCodes.rpc.internal;
const FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
const JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
/**
 * Returns whether the given code is valid.
 * A code is valid if it is an integer.
 *
 * @param code - The error code.
 * @returns Whether the given code is valid.
 */ function isValidCode(code) {
    return Number.isInteger(code);
}
function isValidString(value) {
    return typeof value === "string" && value.length > 0;
}
/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */ function isObject(value) {
    return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}
/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */ function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
        return false;
    }
    try {
        let proto = value;
        while(Object.getPrototypeOf(proto) !== null){
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    } catch (_) {
        return false;
    }
}
/**
 * Check if the given code is a valid JSON-RPC server error code.
 *
 * @param code - The error code.
 * @returns Whether the given code is a valid JSON-RPC server error code.
 */ function isJsonRpcServerError(code) {
    return code >= -32099 && code <= -32000;
}
function isJsonRpcError(value) {
    const castValue = value;
    if (!castValue) return false;
    if (!isValidCode(castValue.code) || !isValidString(castValue.message)) return false;
    if (castValue.stack && !isValidString(castValue.stack)) return false;
    return true;
}
/**
 * Gets the message for a given code, or a fallback message if the code has
 * no corresponding message.
 *
 * @param code - The error code.
 * @param fallbackMessage - The fallback message to use if the code has no
 * corresponding message.
 * @returns The message for the given code, or the fallback message if the code
 * has no corresponding message.
 */ function getMessageFromCode(code) {
    let fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;
    if (isValidCode(code)) {
        const codeString = code.toString();
        if (Object.hasOwn(errorValues, codeString)) {
            return errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
            return JSON_RPC_SERVER_ERROR_MESSAGE;
        }
    }
    return fallbackMessage;
}
const FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE)
};
function isValidJson(str) {
    try {
        JSON.parse(JSON.stringify(str, (strKey, strVal)=>{
            if (strKey === "__proto__" || strKey === "constructor") {
                throw new Error("Not valid json");
            }
            if (typeof strVal === "function" || typeof strVal === "symbol") {
                throw new Error("Not valid json");
            }
            return strVal;
        }), (propKey, propValue)=>{
            // Strip __proto__ and constructor properties to prevent prototype pollution.
            if (propKey === "__proto__" || propKey === "constructor") {
                return undefined;
            }
            return propValue;
        });
    // this means, it's a valid json so far
    } catch (e) {
        return false;
    }
    return true;
}
/**
 * Extracts all JSON-serializable properties from an object.
 *
 * @param object - The object in question.
 * @returns An object containing all the JSON-serializable properties.
 */ function serializeObject(object) {
    return Object.getOwnPropertyNames(object).reduce((acc, key)=>{
        const value = object[key];
        if (isValidJson(value)) {
            acc[key] = value;
        }
        return acc;
    }, {});
}
/**
 * Serializes an unknown error to be used as the `cause` in a fallback error.
 *
 * @param error - The unknown error.
 * @returns A JSON-serializable object containing as much information about the original error as possible.
 */ function serializeCause(error) {
    if (Array.isArray(error)) {
        return error.map((entry)=>{
            if (isValidJson(entry)) {
                return entry;
            } else if (isObject(entry)) {
                return serializeObject(entry);
            }
            return null;
        });
    } else if (isObject(error)) {
        return serializeObject(error);
    }
    if (isValidJson(error)) {
        return error;
    }
    return null;
}
/**
 * Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`
 *
 * @param error - The error in question.
 * @param fallbackError - A JSON serializable fallback error.
 * @returns A JSON serializable error object.
 */ function buildError(error, fallbackError) {
    // If an error specifies a `serialize` function, we call it and return the result.
    if (error && typeof error === "object" && "serialize" in error && typeof error.serialize === "function") {
        return error.serialize();
    }
    if (isJsonRpcError(error)) {
        return error;
    }
    // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.
    const cause = serializeCause(error);
    const fallbackWithCause = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, fallbackError), {}, {
        data: {
            cause
        }
    });
    return fallbackWithCause;
}
/**
 * Serializes the given error to an Ethereum JSON RPC-compatible error object.
 * If the given error is not fully compatible, it will be preserved on the
 * returned object's data.cause property.
 *
 * @param error - The error to serialize.
 * @param options - Options bag.
 * @param options.fallbackError - The error to return if the given error is
 * not compatible. Should be a JSON serializable value.
 * @param options.shouldIncludeStack - Whether to include the error's stack
 * on the returned object.
 * @returns The serialized error.
 */ function serializeError(error) {
    let { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!isJsonRpcError(fallbackError)) {
        throw new Error("Must provide fallback error with integer number code and string message.");
    }
    const serialized = buildError(error, fallbackError);
    if (!shouldIncludeStack) {
        delete serialized.stack;
    }
    return serialized;
}
/**
 * Returns true if supplied error data has a usable `cause` property; false otherwise.
 *
 * @param data - Optional data to validate.
 * @returns Whether cause property is present and an object.
 */ function dataHasCause(data) {
    return isObject(data) && Object.hasOwn(data, "cause") && isObject(data.cause);
}
/**
 * Check if the given code is a valid JSON-RPC error code.
 *
 * @param code - The code to check.
 * @returns Whether the code is valid.
 */ function isValidEthProviderCode(code) {
    return Number.isInteger(code) && code >= 1000 && code <= 4999;
}
/**
 * A JSON replacer function that omits circular references.
 *
 * @param _ - The key being replaced.
 * @param value - The value being replaced.
 * @returns The value to use in place of the original value.
 */ function stringifyReplacer(_, value) {
    if (value === "[Circular]") {
        return undefined;
    }
    return value;
}
/**
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors
 * per EIP-1474.
 *
 * Permits any integer error code.
 */ class JsonRpcError extends Error {
    constructor(code, message, data){
        if (!Number.isInteger(code)) {
            throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
            throw new Error('"message" must be a non-empty string.');
        }
        if (dataHasCause(data)) {
            super(message, {
                cause: data.cause
            });
            // Browser backwards-compatibility fallback
            // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "cause", void 0);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "code", void 0);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "data", void 0);
            if (!Object.hasOwn(this, "cause")) {
                Object.assign(this, {
                    cause: data.cause
                });
            }
        } else {
            super(message);
            // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "cause", void 0);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "code", void 0);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "data", void 0);
        }
        if (data !== undefined) {
            this.data = data;
        }
        this.code = code;
        this.cause = data === null || data === void 0 ? void 0 : data.cause;
    }
    /**
   * Get the error as JSON-serializable object.
   *
   * @returns A plain object with all public class properties.
   */ serialize() {
        const serialized = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            // `this.data` is not guaranteed to be a plain object, but this simplifies
            // the type guard below. We can safely cast it because we know it's a
            // JSON-serializable value.
            serialized.data = this.data;
            if (isPlainObject(this.data)) {
                serialized.data.cause = serializeCause(this.data.cause);
            }
        }
        if (this.stack) {
            serialized.stack = this.stack;
        }
        return serialized;
    }
    /**
   * Get a string representation of the serialized error, omitting any circular
   * references.
   *
   * @returns A string representation of the serialized error.
   */ toString() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$safe$2d$stringify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this.serialize(), stringifyReplacer, 2);
    }
}
/**
 * Error subclass implementing Ethereum Provider errors per EIP-1193.
 * Permits integer error codes in the [ 1000 <= 4999 ] range.
 */ class EthereumProviderError extends JsonRpcError {
    /**
   * Create an Ethereum Provider JSON-RPC error.
   *
   * @param code - The JSON-RPC error code. Must be an integer in the
   * `1000 <= n <= 4999` range.
   * @param message - The JSON-RPC error message.
   * @param data - Optional data to include in the error.
   */ constructor(code, message, data){
        if (!isValidEthProviderCode(code)) {
            throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
    }
}
/**
 * Get an error message and optional data from an options bag.
 *
 * @param arg - The error message or options bag.
 * @returns A tuple containing the error message and optional data.
 */ function parseOpts(arg) {
    if (arg) {
        if (typeof arg === "string") {
            return [
                arg
            ];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
            const { message, data } = arg;
            if (message && typeof message !== "string") {
                throw new Error("Must specify string message.");
            }
            return [
                message !== null && message !== void 0 ? message : undefined,
                data
            ];
        }
    }
    return [];
}
/**
 * Get a generic JSON-RPC error class instance.
 *
 * @param code - The error code.
 * @param arg - The error message or options bag.
 * @returns An instance of the {@link JsonRpcError} class.
 */ function getJsonRpcError(code, arg) {
    const [message, data] = parseOpts(arg);
    return new JsonRpcError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);
}
/**
 * Get an Ethereum Provider error class instance.
 *
 * @param code - The error code.
 * @param arg - The error message or options bag.
 * @returns An instance of the {@link EthereumProviderError} class.
 */ function getEthProviderError(code, arg) {
    const [message, data] = parseOpts(arg);
    return new EthereumProviderError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);
}
const rpcErrors = {
    /**
   * Get a JSON RPC 2.0 Parse (-32700) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ parse: (arg)=>getJsonRpcError(errorCodes.rpc.parse, arg),
    /**
   * Get a JSON RPC 2.0 Invalid Request (-32600) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ invalidRequest: (arg)=>getJsonRpcError(errorCodes.rpc.invalidRequest, arg),
    /**
   * Get a JSON RPC 2.0 Invalid Params (-32602) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ invalidParams: (arg)=>getJsonRpcError(errorCodes.rpc.invalidParams, arg),
    /**
   * Get a JSON RPC 2.0 Method Not Found (-32601) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ methodNotFound: (arg)=>getJsonRpcError(errorCodes.rpc.methodNotFound, arg),
    /**
   * Get a JSON RPC 2.0 Internal (-32603) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ internal: (arg)=>getJsonRpcError(errorCodes.rpc.internal, arg),
    /**
   * Get a JSON RPC 2.0 Server error.
   * Permits integer error codes in the [ -32099 <= -32005 ] range.
   * Codes -32000 through -32004 are reserved by EIP-1474.
   *
   * @param opts - The error options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ server: (opts)=>{
        if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
        }
        const { code } = opts;
        if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
        }
        return getJsonRpcError(code, opts);
    },
    /**
   * Get an Ethereum JSON RPC Invalid Input (-32000) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ invalidInput: (arg)=>getJsonRpcError(errorCodes.rpc.invalidInput, arg),
    /**
   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ resourceNotFound: (arg)=>getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),
    /**
   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ resourceUnavailable: (arg)=>getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),
    /**
   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ transactionRejected: (arg)=>getJsonRpcError(errorCodes.rpc.transactionRejected, arg),
    /**
   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ methodNotSupported: (arg)=>getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),
    /**
   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link JsonRpcError} class.
   */ limitExceeded: (arg)=>getJsonRpcError(errorCodes.rpc.limitExceeded, arg)
};
const providerErrors = {
    /**
   * Get an Ethereum Provider User Rejected Request (4001) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */ userRejectedRequest: (arg)=>{
        return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);
    },
    /**
   * Get an Ethereum Provider Unauthorized (4100) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */ unauthorized: (arg)=>{
        return getEthProviderError(errorCodes.provider.unauthorized, arg);
    },
    /**
   * Get an Ethereum Provider Unsupported Method (4200) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */ unsupportedMethod: (arg)=>{
        return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);
    },
    /**
   * Get an Ethereum Provider Not Connected (4900) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */ disconnected: (arg)=>{
        return getEthProviderError(errorCodes.provider.disconnected, arg);
    },
    /**
   * Get an Ethereum Provider Chain Not Connected (4901) error.
   *
   * @param arg - The error message or options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */ chainDisconnected: (arg)=>{
        return getEthProviderError(errorCodes.provider.chainDisconnected, arg);
    },
    /**
   * Get a custom Ethereum Provider error.
   *
   * @param opts - The error options bag.
   * @returns An instance of the {@link EthereumProviderError} class.
   */ custom: (opts)=>{
        if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
        }
        const { code, message, data } = opts;
        if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
        }
        return new EthereumProviderError(code, message, data);
    }
};
/* eslint-disable @typescript-eslint/no-explicit-any */ function safeApply(handler, context, args) {
    try {
        Reflect.apply(handler, context, args);
    } catch (err) {
        // Throw error after timeout so as not to interrupt the stack
        setTimeout(()=>{
            throw err;
        });
    }
}
function arrayClone(arr) {
    const n = arr.length;
    const copy = new Array(n);
    for(let i = 0; i < n; i += 1){
        copy[i] = arr[i];
    }
    return copy;
}
class SafeEventEmitter extends __TURBOPACK__imported__module__$5b$externals$5d2f$events__$5b$external$5d$__$28$events$2c$__cjs$29$__["EventEmitter"] {
    emit(type) {
        let doError = type === "error";
        const events = this._events;
        if (events !== undefined) {
            doError = doError && events.error === undefined;
        } else if (!doError) {
            return false;
        }
        // If there is no 'error' event listener then throw.
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        if (doError) {
            let er;
            if (args.length > 0) {
                [er] = args;
            }
            if (er instanceof Error) {
                // Note: The comments on the `throw` lines are intentional, they show
                // up in Node's output if this results in an unhandled exception.
                throw er; // Unhandled 'error' event
            }
            // At least give some kind of context to the user
            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ""}`);
            err.context = er;
            throw err; // Unhandled 'error' event
        }
        const handler = events[type];
        if (handler === undefined) {
            return false;
        }
        if (typeof handler === "function") {
            safeApply(handler, this, args);
        } else {
            const len = handler.length;
            const listeners = arrayClone(handler);
            for(let i = 0; i < len; i += 1){
                safeApply(listeners[i], this, args);
            }
        }
        return true;
    }
}
class SerializableError extends Error {
    constructor(_ref){
        let { code, message, data } = _ref;
        if (!Number.isInteger(code)) {
            throw new Error("code must be an integer");
        }
        if (!message || typeof message !== "string") {
            throw new Error("message must be string");
        }
        super(message);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "code", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "data", void 0);
        this.code = code;
        if (data !== undefined) {
            this.data = data;
        }
    }
    toString() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$safe$2d$stringify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            code: this.code,
            message: this.message,
            data: this.data,
            stack: this.stack
        });
    }
}
const getRpcPromiseCallback = function(resolve, reject) {
    let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    return (error, response)=>{
        if (error || response.error) {
            reject(error || response.error);
        } else if (!unwrapResult || Array.isArray(response)) {
            resolve(response);
        } else {
            resolve(response.result);
        }
    };
};
function createErrorMiddleware(log) {
    return (req, res, next, end)=>{
        try {
            // json-rpc-engine will terminate the request when it notices this error
            if (typeof req.method !== "string" || !req.method) {
                res.error = new SerializableError({
                    code: -32603,
                    message: "invalid method"
                });
                end();
                return;
            }
            next((done)=>{
                const { error } = res;
                if (!error) {
                    return done();
                }
                log.error(`OpenLogin - RPC Error: ${error.message}`, error);
                return done();
            });
        } catch (error) {
            log.error(`OpenLogin - RPC Error thrown: ${error.message}`, error);
            res.error = new SerializableError({
                code: -32603,
                message: error.message
            });
            end();
        }
    };
}
function createStreamMiddleware() {
    const idMap = {};
    function readNoop() {
        return false;
    }
    const events = new SafeEventEmitter();
    function processResponse(res) {
        const context = idMap[res.id];
        if (!context) {
            throw new Error(`StreamMiddleware - Unknown response id "${res.id}"`);
        }
        delete idMap[res.id];
        // copy whole res onto original res
        Object.assign(context.res, res);
        // run callback on empty stack,
        // prevent internal stream-handler from catching errors
        setTimeout(context.end);
    }
    function processNotification(res) {
        events.emit("notification", res);
    }
    function processMessage(res, _encoding, cb) {
        let err;
        try {
            const isNotification = !res.id;
            if (isNotification) {
                processNotification(res);
            } else {
                processResponse(res);
            }
        } catch (_err) {
            err = _err;
        }
        // continue processing stream
        cb(err);
    }
    const stream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$readable$2d$stream$2f$lib$2f$ours$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Duplex"]({
        objectMode: true,
        read: readNoop,
        write: processMessage
    });
    const middleware = (req, res, next, end)=>{
        // write req to stream
        stream.push(req);
        // register request on id map
        idMap[req.id] = {
            req,
            res,
            next,
            end
        };
    };
    return {
        events,
        middleware,
        stream
    };
}
function createScaffoldMiddleware(handlers) {
    return (req, res, next, end)=>{
        const handler = handlers[req.method];
        // if no handler, return
        if (handler === undefined) {
            return next();
        }
        // if handler is fn, call as middleware
        if (typeof handler === "function") {
            return handler(req, res, next, end);
        }
        // if handler is some other value, use as result
        res.result = handler;
        return end();
    };
}
function createIdRemapMiddleware() {
    return (req, res, next, _end)=>{
        const originalId = req.id;
        const newId = Math.random().toString(36).slice(2);
        req.id = newId;
        res.id = newId;
        next((done)=>{
            req.id = originalId;
            res.id = originalId;
            done();
        });
    };
}
function createLoggerMiddleware(logger) {
    return (req, res, next, _)=>{
        logger.debug("REQ", req, "RES", res);
        next();
    };
}
function createAsyncMiddleware(asyncMiddleware) {
    return async (req, res, next, end)=>{
        // nextPromise is the key to the implementation
        // it is resolved by the return handler passed to the
        // "next" function
        let resolveNextPromise;
        const nextPromise = new Promise((resolve)=>{
            resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        // This will be called by the consumer's async middleware.
        const asyncNext = async ()=>{
            nextWasCalled = true;
            // We pass a return handler to next(). When it is called by the engine,
            // the consumer's async middleware will resume executing.
            next((runReturnHandlersCallback)=>{
                // This callback comes from JRPCEngine._runReturnHandlers
                returnHandlerCallback = runReturnHandlersCallback;
                resolveNextPromise();
            });
            await nextPromise;
        };
        try {
            await asyncMiddleware(req, res, asyncNext);
            if (nextWasCalled) {
                await nextPromise; // we must wait until the return handler is called
                returnHandlerCallback(null);
            } else {
                end(null);
            }
        } catch (err) {
            const error = err;
            if (returnHandlerCallback) {
                returnHandlerCallback(error);
            } else {
                end(error);
            }
        }
    };
}
/**
 * A JSON-RPC request and response processor.
 * Give it a stack of middleware, pass it requests, and get back responses.
 */ class JRPCEngine extends SafeEventEmitter {
    constructor(){
        super();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_middleware", void 0);
        this._middleware = [];
    }
    /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */ static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error = null;
        let isComplete = false;
        // Go down stack of middleware, call and collect optional returnHandlers
        for (const middleware of middlewareStack){
            [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);
            if (isComplete) {
                break;
            }
        }
        return [
            error,
            isComplete,
            returnHandlers.reverse()
        ];
    }
    /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * and a boolean indicating whether the request should end.
   */ static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve)=>{
            const end = (err)=>{
                const error = err || res.error;
                if (error) {
                    if (typeof error === "object" && Object.keys(error).includes("stack") === false) error.stack = "Stack trace is not available.";
                    res.error = serializeError(error, {
                        shouldIncludeStack: true,
                        fallbackError: {
                            message: (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString()),
                            code: (error === null || error === void 0 ? void 0 : error.code) || -32603,
                            stack: (error === null || error === void 0 ? void 0 : error.stack) || "Stack trace is not available.",
                            data: (error === null || error === void 0 ? void 0 : error.data) || (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString())
                        }
                    });
                }
                // True indicates that the request should end
                resolve([
                    error,
                    true
                ]);
            };
            const next = (returnHandler)=>{
                if (res.error) {
                    end(res.error);
                } else {
                    if (returnHandler) {
                        if (typeof returnHandler !== "function") {
                            end(new SerializableError({
                                code: -32603,
                                message: "JRPCEngine: 'next' return handlers must be functions"
                            }));
                        }
                        returnHandlers.push(returnHandler);
                    }
                    // False indicates that the request should not end
                    resolve([
                        null,
                        false
                    ]);
                }
            };
            try {
                middleware(req, res, next, end);
            } catch (error) {
                end(error);
            }
        });
    }
    /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */ static async _runReturnHandlers(handlers) {
        for (const handler of handlers){
            await new Promise((resolve, reject)=>{
                handler((err)=>err ? reject(err) : resolve());
            });
        }
    }
    /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */ static _checkForCompletion(_req, res, isComplete) {
        if (!("result" in res) && !("error" in res)) {
            throw new SerializableError({
                code: -32603,
                message: "Response has no error or result for request"
            });
        }
        if (!isComplete) {
            throw new SerializableError({
                code: -32603,
                message: "Nothing ended request"
            });
        }
    }
    /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */ push(middleware) {
        this._middleware.push(middleware);
    }
    /**
   * Handle a JSON-RPC request, and return a response.
   *
   * @param request - The request to handle.
   * @param callback - An error-first callback that will receive the response.
   */ /**
   * Handle an array of JSON-RPC requests, and return an array of responses.
   *
   * @param request - The requests to handle.
   * @param callback - An error-first callback that will receive the array of
   * responses.
   */ /**
   * Handle a JSON-RPC request, and return a response.
   *
   * @param request - The request to handle.
   * @returns A promise that resolves with the response, or rejects with an
   * error.
   */ /**
   * Handle an array of JSON-RPC requests, and return an array of responses.
   *
   * @param request - The requests to handle.
   * @returns A promise that resolves with the array of responses, or rejects
   * with an error.
   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    handle(req, cb) {
        if (cb && typeof cb !== "function") {
            throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
            if (cb) {
                return this._handleBatch(req, cb);
            }
            return this._handleBatch(req);
        }
        if (cb) {
            return this._handle(req, cb);
        }
        return this._promiseHandle(req);
    }
    /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */ asMiddleware() {
        return async (req, res, next, end)=>{
            try {
                const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);
                if (isComplete) {
                    await JRPCEngine._runReturnHandlers(returnHandlers);
                    return end(middlewareError);
                }
                return next(async (handlerCallback)=>{
                    try {
                        await JRPCEngine._runReturnHandlers(returnHandlers);
                    } catch (error) {
                        return handlerCallback(error);
                    }
                    return handlerCallback();
                });
            } catch (error) {
                return end(error);
            }
        };
    }
    /**
   * Like _handle, but for batch requests.
   */ /**
   * Like _handle, but for batch requests.
   */ async _handleBatch(reqs, cb) {
        // The order here is important
        try {
            // 2. Wait for all requests to finish, or throw on some kind of fatal
            // error
            const responses = await Promise.all(// 1. Begin executing each request in the order received
            reqs.map(this._promiseHandle.bind(this)));
            // 3. Return batch response
            if (cb) {
                return cb(null, responses);
            }
            return responses;
        } catch (error) {
            if (cb) {
                return cb(error);
            }
            throw error;
        }
    }
    /**
   * A promise-wrapped _handle.
   */ _promiseHandle(req) {
        return new Promise((resolve, reject)=>{
            this._handle(req, (_err, res)=>{
                // There will always be a response, and it will always have any error
                // that is caught and propagated.
                if (_err && res === undefined) {
                    reject(_err);
                } else resolve(res);
            }).catch(reject);
        });
    }
    /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */ async _handle(callerReq, cb) {
        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
            const error = new SerializableError({
                code: -32603,
                message: "request must be plain object"
            });
            return cb(error, {
                id: undefined,
                jsonrpc: "2.0",
                error
            });
        }
        if (typeof callerReq.method !== "string") {
            const error = new SerializableError({
                code: -32603,
                message: "method must be string"
            });
            return cb(error, {
                id: callerReq.id,
                jsonrpc: "2.0",
                error
            });
        }
        const req = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, callerReq);
        const res = {
            id: req.id,
            jsonrpc: req.jsonrpc
        };
        let error = null;
        try {
            await this._processRequest(req, res);
        } catch (_error) {
            // A request handler error, a re-thrown middleware error, or something
            // unexpected.
            error = _error;
        }
        if (error) {
            // Ensure no result is present on an errored response
            delete res.result;
            if (!res.error) {
                var _error2, _error3, _error4, _error5, _error6, _error7, _error8;
                if (typeof error === "object" && Object.keys(error).includes("stack") === false) error.stack = "Stack trace is not available.";
                res.error = serializeError(error, {
                    shouldIncludeStack: true,
                    fallbackError: {
                        message: ((_error2 = error) === null || _error2 === void 0 ? void 0 : _error2.message) || ((_error3 = error) === null || _error3 === void 0 ? void 0 : _error3.toString()),
                        code: ((_error4 = error) === null || _error4 === void 0 ? void 0 : _error4.code) || -32603,
                        stack: ((_error5 = error) === null || _error5 === void 0 ? void 0 : _error5.stack) || "Stack trace is not available.",
                        data: ((_error6 = error) === null || _error6 === void 0 ? void 0 : _error6.data) || ((_error7 = error) === null || _error7 === void 0 ? void 0 : _error7.message) || ((_error8 = error) === null || _error8 === void 0 ? void 0 : _error8.toString())
                    }
                });
            }
        }
        return cb(error, res);
    }
    /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */ async _processRequest(req, res) {
        const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);
        // Throw if "end" was not called, or if the response has neither a result
        // nor an error.
        JRPCEngine._checkForCompletion(req, res, isComplete);
        // The return handlers should run even if an error was encountered during
        // middleware processing.
        await JRPCEngine._runReturnHandlers(returnHandlers);
        // Now we re-throw the middleware processing error, if any, to catch it
        // further up the call chain.
        if (error) {
            throw error;
        }
    }
}
function mergeMiddleware(middlewareStack) {
    const engine = new JRPCEngine();
    middlewareStack.forEach((middleware)=>engine.push(middleware));
    return engine.asMiddleware();
}
function createEngineStream(opts) {
    if (!opts || !opts.engine) {
        throw new Error("Missing engine parameter!");
    }
    const { engine } = opts;
    // eslint-disable-next-line prefer-const
    let stream;
    function read() {
        return undefined;
    }
    function write(req, _encoding, cb) {
        engine.handle(req, (_err, res)=>{
            stream.push(res);
        });
        cb();
    }
    stream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$readable$2d$stream$2f$lib$2f$ours$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Duplex"]({
        objectMode: true,
        read,
        write
    });
    // forward notifications
    if (engine.on) {
        engine.on("notification", (message)=>{
            stream.push(message);
        });
    }
    return stream;
}
function providerFromEngine(engine) {
    const provider = new SafeEventEmitter();
    // handle both rpc send methods
    provider.sendAsync = async (req)=>{
        const res = await engine.handle(req);
        if (res.error) {
            var _res$error, _res$error2, _res$error3, _res$error4, _res$error5, _res$error6, _res$error7;
            if (typeof res.error === "object" && Object.keys(res.error).includes("stack") === false) res.error.stack = "Stack trace is not available.";
            const err = serializeError(res.error, {
                fallbackError: {
                    message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.toString()),
                    code: ((_res$error3 = res.error) === null || _res$error3 === void 0 ? void 0 : _res$error3.code) || -32603,
                    stack: ((_res$error4 = res.error) === null || _res$error4 === void 0 ? void 0 : _res$error4.stack) || "Stack trace is not available.",
                    data: ((_res$error5 = res.error) === null || _res$error5 === void 0 ? void 0 : _res$error5.data) || ((_res$error6 = res.error) === null || _res$error6 === void 0 ? void 0 : _res$error6.message) || ((_res$error7 = res.error) === null || _res$error7 === void 0 ? void 0 : _res$error7.toString())
                },
                shouldIncludeStack: true
            });
            throw rpcErrors.internal(err);
        }
        return res.result;
    };
    provider.send = (req, callback)=>{
        if (typeof callback !== "function") {
            throw new Error('Must provide callback to "send" method.');
        }
        engine.handle(req, callback);
    };
    // forward notifications
    if (engine.on) {
        engine.on("notification", (message)=>{
            provider.emit("data", null, message);
        });
    }
    provider.request = async (args)=>{
        const req = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, args), {}, {
            id: Math.random().toString(36).slice(2),
            jsonrpc: "2.0"
        });
        const res = await provider.sendAsync(req);
        return res;
    };
    return provider;
}
function providerFromMiddleware(middleware) {
    const engine = new JRPCEngine();
    engine.push(middleware);
    const provider = providerFromEngine(engine);
    return provider;
}
function providerAsMiddleware(provider) {
    return async (req, res, _next, end)=>{
        // send request to provider
        try {
            const providerRes = await provider.sendAsync(req);
            res.result = providerRes;
            return end();
        } catch (error) {
            return end(error);
        }
    };
}
class Substream extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$readable$2d$stream$2f$lib$2f$ours$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Duplex"] {
    constructor(_ref){
        let { parent, name } = _ref;
        super({
            objectMode: true
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_parent", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_name", void 0);
        this._parent = parent;
        this._name = name;
    }
    /**
   * Explicitly sets read operations to a no-op.
   */ _read() {
        return undefined;
    }
    /**
   * Called when data should be written to this writable stream.
   *
   * @param chunk - Arbitrary object to write
   * @param encoding - Encoding to use when writing payload
   * @param callback - Called when writing is complete or an error occurs
   */ _write(chunk, _encoding, callback) {
        this._parent.push({
            name: this._name,
            data: chunk
        });
        callback();
    }
}
const IGNORE_SUBSTREAM = Symbol("IGNORE_SUBSTREAM");
class ObjectMultiplex extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$readable$2d$stream$2f$lib$2f$ours$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Duplex"] {
    constructor(){
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, opts), {}, {
            objectMode: true
        }));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_substreams", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "getStream", void 0);
        this._substreams = {};
    }
    createStream(name) {
        // validate name
        if (!name) {
            throw new Error("ObjectMultiplex - name must not be empty");
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // create substream
        const substream = new Substream({
            parent: this,
            name
        });
        this._substreams[name] = substream;
        // listen for parent stream to end
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        anyStreamEnd(this, (_error)=>substream.destroy(_error || undefined));
        return substream;
    }
    // ignore streams (dont display orphaned data warning)
    ignoreStream(name) {
        // validate name
        if (!name) {
            throw new Error("ObjectMultiplex - name must not be empty");
        }
        if (this._substreams[name]) {
            throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
        }
        // set
        this._substreams[name] = IGNORE_SUBSTREAM;
    }
    _read() {
        return undefined;
    }
    _write(chunk, _encoding, callback) {
        const { name, data } = chunk;
        if (!name) {
            window.console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`);
            return callback();
        }
        // get corresponding substream
        const substream = this._substreams[name];
        if (!substream) {
            window.console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`);
            return callback();
        }
        // push data into substream
        if (substream !== IGNORE_SUBSTREAM) {
            substream.push(data);
        }
        return callback();
    }
}
// util
function anyStreamEnd(stream, _cb) {
    const cb = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$once$2f$once$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(_cb);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$end$2d$of$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(stream, {
        readable: false
    }, cb);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$end$2d$of$2d$stream$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(stream, {
        writable: false
    }, cb);
}
function setupMultiplex(stream) {
    const mux = new ObjectMultiplex();
    mux.getStream = function streamHelper(name) {
        if (this._substreams[name]) {
            return this._substreams[name];
        }
        return this.createStream(name);
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pump$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(stream, mux, stream, (err)=>{
        if (err) window.console.error(err);
    });
    return mux;
}
class PostMessageStream extends BasePostMessageStream {
    _postMessage(data) {
        let originConstraint = this._targetOrigin;
        if (typeof data === "object") {
            const dataObj = data;
            if (typeof dataObj.data === "object") {
                const dataObjData = dataObj.data;
                if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {
                    const dataObjDataParam = dataObjData.params[0];
                    if (dataObjDataParam._origin) {
                        originConstraint = dataObjDataParam._origin;
                    }
                    // add a constraint for the response
                    dataObjDataParam._origin = window.location.origin;
                }
            }
        }
        this._targetWindow.postMessage({
            target: this._target,
            data
        }, originConstraint);
    }
}
;
}}),
"[project]/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "clearAPIKey": (()=>clearAPIKey),
    "clearEmbedHost": (()=>clearEmbedHost),
    "enableSentryTracing": (()=>enableSentryTracing),
    "gatewayAuthHeader": (()=>gatewayAuthHeader),
    "gatewayEmbedHostHeader": (()=>gatewayEmbedHostHeader),
    "generateJsonRPCObject": (()=>generateJsonRPCObject),
    "get": (()=>get),
    "getAPIKey": (()=>getAPIKey),
    "getEmbedHost": (()=>getEmbedHost),
    "patch": (()=>patch),
    "post": (()=>post),
    "promiseRace": (()=>promiseRace),
    "promiseTimeout": (()=>promiseTimeout),
    "put": (()=>put),
    "remove": (()=>remove),
    "setAPIKey": (()=>setAPIKey),
    "setEmbedHost": (()=>setEmbedHost),
    "setLogLevel": (()=>setLogLevel)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$merge$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash.merge/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loglevel/lib/loglevel.js [app-ssr] (ecmascript)");
;
;
;
const log = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getLogger("http-helpers");
log.setLevel(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["levels"].INFO);
let apiKey = "torus-default";
let embedHost = "";
// #region API Keys
const gatewayAuthHeader = "x-api-key";
const gatewayEmbedHostHeader = "x-embed-host";
let sentry = null;
const tracingOrigins = [];
const tracingPaths = [];
function enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {
    sentry = _sentry;
    tracingOrigins.push(..._tracingOrigins);
    tracingPaths.push(..._tracingPaths);
}
function setEmbedHost(embedHost_) {
    embedHost = embedHost_;
}
function clearEmbedHost() {
    embedHost = "";
}
function getEmbedHost() {
    return embedHost;
}
function setAPIKey(apiKey_) {
    apiKey = apiKey_;
}
function clearAPIKey() {
    apiKey = "torus-default";
}
function getAPIKey() {
    return apiKey;
}
// #endregion
function setLogLevel(level) {
    log.setLevel(level);
}
async function fetchAndTrace(url, init) {
    let _url = null;
    try {
        _url = new URL(url);
    } catch (error) {}
    if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {
        const transaction = sentry.startTransaction({
            name: url
        });
        const span = transaction.startChild({
            op: "http"
        }); // This function returns a Span
        const response = await fetch(url, init);
        span.finish(); // Remember that only finished spans will be sent with the transaction
        transaction.finish(); // Finishing the transaction will send it to Sentry
        return response;
    }
    return fetch(url, init);
}
function getApiKeyHeaders() {
    const headers = {};
    if (apiKey) headers[gatewayAuthHeader] = apiKey;
    if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;
    return headers;
}
function debugLogResponse(response) {
    log.info(`Response: ${response.status} ${response.statusText}`);
    log.info(`Url: ${response.url}`);
}
function logTracingHeader(response) {
    const tracingHeader = response.headers.get("x-web3-correlation-id");
    if (tracingHeader) log.info(`Request tracing with traceID = ${tracingHeader}`);
}
const promiseTimeout = async (ms, promise)=>{
    let timeoutFunc = null;
    try {
        const timeout = new Promise((_resolve, reject)=>{
            timeoutFunc = setTimeout(()=>{
                reject(new Error(`Timed out in ${ms}ms`));
            }, ms);
        });
        const result = await Promise.race([
            promise,
            timeout
        ]);
        // promise.race will return the first resolved promise
        // then we clear the timeout
        if (timeoutFunc != null) {
            clearTimeout(timeoutFunc);
        }
        return result;
    } catch (err) {
        // clear the timeout
        if (timeoutFunc != null) {
            clearTimeout(timeoutFunc);
        }
        // rethrow the original error
        throw err;
    }
};
const get = async function(url) {
    let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const defaultOptions = {
        mode: "cors",
        headers: {}
    };
    if (customOptions.useAPIKey) {
        defaultOptions.headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, defaultOptions.headers), getApiKeyHeaders());
    }
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$merge$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(defaultOptions, options_, {
        method: "GET"
    });
    const response = await fetchAndTrace(url, options);
    if (response.ok) {
        const responseContentType = response.headers.get("content-type");
        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes("application/json")) {
            return response.json();
        }
        return response.text();
    }
    debugLogResponse(response);
    throw response;
};
const post = function(url) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const defaultOptions = {
        mode: "cors",
        headers: {
            "Content-Type": "application/json; charset=utf-8"
        }
    };
    if (customOptions.useAPIKey) {
        defaultOptions.headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, defaultOptions.headers), getApiKeyHeaders());
    }
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$merge$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(defaultOptions, options_, {
        method: "POST"
    });
    // deep merge changes the structure of form data and url encoded data ,
    // so we should not deepmerge body data
    if (customOptions.isUrlEncodedData) {
        // for multipart request browser/client will add multipart content type
        // along with multipart boundary , so for multipart request send
        // content-type: undefined or send with multipart boundary if already known
        options.body = data;
        // If url encoded data, this must not be the content type
        if (options.headers["Content-Type"] === "application/json; charset=utf-8") delete options.headers["Content-Type"];
    } else {
        options.body = JSON.stringify(data);
    }
    return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then((response)=>{
        if (customOptions.logTracingHeader) {
            logTracingHeader(response);
        }
        if (response.ok) {
            const responseContentType = response.headers.get("content-type");
            if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes("application/json")) {
                return response.json();
            }
            return response.text();
        }
        debugLogResponse(response);
        throw response;
    }));
};
const patch = async function(url) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const defaultOptions = {
        mode: "cors",
        headers: {
            "Content-Type": "application/json; charset=utf-8"
        }
    };
    // for multipart request browser/client will add multipart content type
    // along with multipart boundary , so for multipart request send
    // content-type: undefined or send with multipart boundary if already known
    if (customOptions.useAPIKey) {
        defaultOptions.headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, defaultOptions.headers), getApiKeyHeaders());
    }
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$merge$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(defaultOptions, options_, {
        method: "PATCH"
    });
    // deep merge changes the structure of form data and url encoded data ,
    // so we should not deepmerge body data
    if (customOptions.isUrlEncodedData) {
        // for multipart request browser/client will add multipart content type
        // along with multipart boundary , so for multipart request send
        // content-type: undefined or send with multipart boundary if already known
        options.body = data;
        // If url encoded data, this must not be the content type
        if (options.headers["Content-Type"] === "application/json; charset=utf-8") delete options.headers["Content-Type"];
    } else {
        options.body = JSON.stringify(data);
    }
    const response = await fetchAndTrace(url, options);
    if (response.ok) {
        const responseContentType = response.headers.get("content-type");
        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes("application/json")) {
            return response.json();
        }
        return response.text();
    }
    debugLogResponse(response);
    throw response;
};
const put = async function(url) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const defaultOptions = {
        mode: "cors",
        headers: {
            "Content-Type": "application/json; charset=utf-8"
        }
    };
    // for multipart request browser/client will add multipart content type
    // along with multipart boundary , so for multipart request send
    // content-type: undefined or send with multipart boundary if already known
    if (customOptions.useAPIKey) {
        defaultOptions.headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, defaultOptions.headers), getApiKeyHeaders());
    }
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$merge$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(defaultOptions, options_, {
        method: "PUT"
    });
    // deep merge changes the structure of form data and url encoded data ,
    // so we should not deepmerge body data
    if (customOptions.isUrlEncodedData) {
        // for multipart request browser/client will add multipart content type
        // along with multipart boundary , so for multipart request send
        // content-type: undefined or send with multipart boundary if already known
        options.body = data;
        // If url encoded data, this must not be the content type
        if (options.headers["Content-Type"] === "application/json; charset=utf-8") delete options.headers["Content-Type"];
    } else {
        options.body = JSON.stringify(data);
    }
    const response = await fetchAndTrace(url, options);
    if (response.ok) {
        const responseContentType = response.headers.get("content-type");
        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes("application/json")) {
            return response.json();
        }
        return response.text();
    }
    debugLogResponse(response);
    throw response;
};
const remove = async function(url) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const defaultOptions = {
        mode: "cors",
        headers: {
            "Content-Type": "application/json; charset=utf-8"
        }
    };
    // for multipart request browser/client will add multipart content type
    // along with multipart boundary , so for multipart request send
    // content-type: undefined or send with multipart boundary if already known
    if (customOptions.useAPIKey) {
        defaultOptions.headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, defaultOptions.headers), getApiKeyHeaders());
    }
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$merge$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(defaultOptions, options_, {
        method: "DELETE"
    });
    if (customOptions.isUrlEncodedData) {
        // for multipart request browser/client will add multipart content type
        // along with multipart boundary , so for multipart request send
        // content-type: undefined or send with multipart boundary if already known
        options.body = data;
        // If url encoded data, this must not be the content type
        if (options.headers["Content-Type"] === "application/json; charset=utf-8") delete options.headers["Content-Type"];
    } else {
        options.body = JSON.stringify(data);
    }
    const response = await fetchAndTrace(url, options);
    if (response.ok) {
        const responseContentType = response.headers.get("content-type");
        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes("application/json")) {
            return response.json();
        }
        return response.text();
    }
    debugLogResponse(response);
    throw response;
};
const generateJsonRPCObject = (method, parameters)=>({
        jsonrpc: "2.0",
        method,
        id: 10,
        params: parameters
    });
const promiseRace = function(url, options) {
    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;
    return Promise.race([
        get(url, options),
        new Promise((_resolve, reject)=>{
            setTimeout(()=>{
                reject(new Error("timed out"));
            }, timeout);
        })
    ]);
};
;
}}),
"[project]/node_modules/@toruslabs/constants/dist/constants.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "FND_SERVER": (()=>FND_SERVER),
    "KEY_TYPE": (()=>KEY_TYPE),
    "LEGACY_NETWORKS_ROUTE_MAP": (()=>LEGACY_NETWORKS_ROUTE_MAP),
    "METADATA_MAP": (()=>METADATA_MAP),
    "MULTI_CLUSTER_NETWORKS": (()=>MULTI_CLUSTER_NETWORKS),
    "NETWORK_MAP": (()=>NETWORK_MAP),
    "PROXY_CONTRACT_ADDRESS": (()=>PROXY_CONTRACT_ADDRESS),
    "SESSION_SERVER": (()=>SESSION_SERVER),
    "SIGNER_MAP": (()=>SIGNER_MAP),
    "TORUS_LEGACY_NETWORK": (()=>TORUS_LEGACY_NETWORK),
    "TORUS_SAPPHIRE_NETWORK": (()=>TORUS_SAPPHIRE_NETWORK),
    "abi": (()=>abi)
});
const TORUS_LEGACY_NETWORK = {
    MAINNET: "mainnet",
    TESTNET: "testnet",
    CYAN: "cyan",
    AQUA: "aqua",
    CELESTE: "celeste"
};
const TORUS_SAPPHIRE_NETWORK = {
    SAPPHIRE_DEVNET: "sapphire_devnet",
    SAPPHIRE_MAINNET: "sapphire_mainnet"
};
const PROXY_CONTRACT_ADDRESS = {
    [TORUS_LEGACY_NETWORK.MAINNET]: "0xf20336e16B5182637f09821c27BDe29b0AFcfe80",
    [TORUS_LEGACY_NETWORK.TESTNET]: "0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A",
    [TORUS_LEGACY_NETWORK.CYAN]: "0x9f072ba19b3370e512aa1b4bfcdaf97283168005",
    [TORUS_LEGACY_NETWORK.AQUA]: "0x29Dea82a0509153b91040ee13cDBba0f03efb625",
    [TORUS_LEGACY_NETWORK.CELESTE]: "0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c"
};
const MULTI_CLUSTER_NETWORKS = [];
const LEGACY_NETWORKS_ROUTE_MAP = {
    [TORUS_LEGACY_NETWORK.AQUA]: {
        migrationCompleted: true,
        networkIdentifier: "aqua",
        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
    },
    [TORUS_LEGACY_NETWORK.CELESTE]: {
        migrationCompleted: true,
        networkIdentifier: "celeste",
        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
    },
    [TORUS_LEGACY_NETWORK.CYAN]: {
        migrationCompleted: true,
        networkIdentifier: "cyan",
        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
    },
    [TORUS_LEGACY_NETWORK.MAINNET]: {
        migrationCompleted: true,
        networkIdentifier: "mainnet",
        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
    },
    [TORUS_LEGACY_NETWORK.TESTNET]: {
        migrationCompleted: true,
        networkIdentifier: "teal",
        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET
    }
};
const NETWORK_MAP = {
    [TORUS_LEGACY_NETWORK.MAINNET]: "mainnet",
    [TORUS_LEGACY_NETWORK.TESTNET]: "goerli",
    [TORUS_LEGACY_NETWORK.CYAN]: "polygon-mainnet",
    [TORUS_LEGACY_NETWORK.AQUA]: "polygon-mainnet",
    [TORUS_LEGACY_NETWORK.CELESTE]: "polygon-mainnet"
};
const SIGNER_MAP = {
    [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: "https://signer.web3auth.io",
    [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: "https://signer.web3auth.io",
    [TORUS_LEGACY_NETWORK.MAINNET]: "https://signer.web3auth.io",
    [TORUS_LEGACY_NETWORK.TESTNET]: "https://signer.web3auth.io",
    [TORUS_LEGACY_NETWORK.CYAN]: "https://signer-polygon.web3auth.io",
    [TORUS_LEGACY_NETWORK.AQUA]: "https://signer-polygon.web3auth.io",
    [TORUS_LEGACY_NETWORK.CELESTE]: "https://signer-polygon.web3auth.io"
};
const METADATA_MAP = {
    [TORUS_LEGACY_NETWORK.MAINNET]: "https://metadata.web3auth.io",
    [TORUS_LEGACY_NETWORK.TESTNET]: "https://metadata.web3auth.io",
    [TORUS_LEGACY_NETWORK.CYAN]: "https://metadata.web3auth.io",
    [TORUS_LEGACY_NETWORK.AQUA]: "https://metadata.web3auth.io",
    [TORUS_LEGACY_NETWORK.CELESTE]: "https://metadata.web3auth.io"
};
const FND_SERVER = "https://fnd.web3auth.io";
const SESSION_SERVER = "https://session.web3auth.io";
const KEY_TYPE = {
    SECP256K1: "secp256k1",
    ED25519: "ed25519"
};
const abi = [
    {
        inputs: [
            {
                internalType: "string",
                name: "_verifier",
                type: "string"
            },
            {
                internalType: "bytes32",
                name: "hashedVerifierId",
                type: "bytes32"
            }
        ],
        name: "getNodeSet",
        outputs: [
            {
                internalType: "uint256",
                name: "currentEpoch",
                type: "uint256"
            },
            {
                internalType: "string[]",
                name: "torusNodeEndpoints",
                type: "string[]"
            },
            {
                internalType: "uint256[]",
                name: "torusNodePubX",
                type: "uint256[]"
            },
            {
                internalType: "uint256[]",
                name: "torusNodePubY",
                type: "uint256[]"
            },
            {
                internalType: "uint256[]",
                name: "torusIndexes",
                type: "uint256[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
];
;
}}),
"[project]/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BUILD_ENV": (()=>BUILD_ENV),
    "BrowserStorage": (()=>BrowserStorage),
    "LANGUAGES": (()=>LANGUAGES),
    "LANGUAGE_MAP": (()=>LANGUAGE_MAP),
    "LOGIN_PROVIDER": (()=>LOGIN_PROVIDER),
    "MFA_FACTOR": (()=>MFA_FACTOR),
    "MFA_LEVELS": (()=>MFA_LEVELS),
    "MemoryStore": (()=>MemoryStore),
    "OPENLOGIN_ACTIONS": (()=>OPENLOGIN_ACTIONS),
    "OPENLOGIN_NETWORK": (()=>OPENLOGIN_NETWORK),
    "SUPPORTED_KEY_CURVES": (()=>SUPPORTED_KEY_CURVES),
    "THEME_MODES": (()=>THEME_MODES),
    "UX_MODE": (()=>UX_MODE),
    "applyWhiteLabelTheme": (()=>applyWhiteLabelTheme),
    "base64toJSON": (()=>base64toJSON),
    "base64url": (()=>base64url),
    "generateWhiteLabelTheme": (()=>generateWhiteLabelTheme),
    "getColorsList": (()=>getColorsList),
    "jsonToBase64": (()=>jsonToBase64),
    "safeatob": (()=>safeatob),
    "safebtoa": (()=>safebtoa),
    "storageAvailable": (()=>storageAvailable),
    "storeKey": (()=>storeKey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/base64url/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$constants$2f$dist$2f$constants$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/constants/dist/constants.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/color/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
const base64url = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
function safebtoa(str) {
    return base64url.encode(str);
}
function safeatob(str) {
    // Going backwards: from bytestream, to percent-encoding, to original string.
    return base64url.decode(str);
}
function base64toJSON(b64str) {
    return JSON.parse(base64url.decode(b64str));
}
function jsonToBase64(json) {
    return base64url.encode(JSON.stringify(json));
}
function storageAvailable(type) {
    let storageExists = false;
    let storageLength = 0;
    let storage;
    try {
        storage = window[type];
        storageExists = true;
        storageLength = storage.length;
        const x = "__storage_test__";
        storage.setItem(x, x);
        storage.removeItem(x);
        return true;
    } catch (err) {
        const error = err;
        return error && (// everything except Firefox
        error.code === 22 || // Firefox
        error.code === 1014 || // test name field too, because code might not be present
        // everything except Firefox
        error.name === "QuotaExceededError" || // Firefox
        error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
        storageExists && storageLength !== 0;
    }
}
class MemoryStore {
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "store", new Map());
    }
    getItem(key) {
        return this.store.get(key) || null;
    }
    setItem(key, value) {
        this.store.set(key, value);
    }
    removeItem(key) {
        this.store.delete(key);
    }
}
class BrowserStorage {
    constructor(storeKey, storage){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "storage", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_storeKey", void 0);
        this.storage = storage;
        this._storeKey = storeKey;
        try {
            if (!storage.getItem(storeKey)) {
                this.resetStore();
            }
        } catch (error) {
        // Storage is not available
        }
    }
    static getInstance(key) {
        let storageKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "local";
        if (!this.instanceMap.has(key)) {
            let storage;
            if (storageKey === "local" && storageAvailable("localStorage")) {
                storage = window.localStorage;
            } else if (storageKey === "session" && storageAvailable("sessionStorage")) {
                storage = window.sessionStorage;
            } else {
                storage = new MemoryStore();
            }
            this.instanceMap.set(key, new this(key, storage));
        }
        return this.instanceMap.get(key);
    }
    toJSON() {
        return this.storage.getItem(this._storeKey);
    }
    resetStore() {
        const currStore = this.getStore();
        this.storage.removeItem(this._storeKey);
        return currStore;
    }
    getStore() {
        return JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    }
    get(key) {
        const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
        return store[key];
    }
    set(key, value) {
        const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
        store[key] = value;
        this.storage.setItem(this._storeKey, JSON.stringify(store));
    }
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(BrowserStorage, "instanceMap", new Map());
const storeKey = "openlogin_store";
const UX_MODE = {
    POPUP: "popup",
    REDIRECT: "redirect"
};
const OPENLOGIN_NETWORK = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$constants$2f$dist$2f$constants$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TORUS_SAPPHIRE_NETWORK"]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$constants$2f$dist$2f$constants$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TORUS_LEGACY_NETWORK"]);
const SUPPORTED_KEY_CURVES = {
    SECP256K1: "secp256k1",
    ED25519: "ed25519"
};
const LOGIN_PROVIDER = {
    GOOGLE: "google",
    FACEBOOK: "facebook",
    REDDIT: "reddit",
    DISCORD: "discord",
    TWITCH: "twitch",
    APPLE: "apple",
    LINE: "line",
    GITHUB: "github",
    KAKAO: "kakao",
    LINKEDIN: "linkedin",
    TWITTER: "twitter",
    WEIBO: "weibo",
    WECHAT: "wechat",
    FARCASTER: "farcaster",
    EMAIL_PASSWORDLESS: "email_passwordless",
    SMS_PASSWORDLESS: "sms_passwordless",
    WEBAUTHN: "webauthn",
    JWT: "jwt"
};
const MFA_LEVELS = {
    DEFAULT: "default",
    OPTIONAL: "optional",
    MANDATORY: "mandatory",
    NONE: "none"
};
const OPENLOGIN_ACTIONS = {
    LOGIN: "login",
    ENABLE_MFA: "enable_mfa",
    MANAGE_MFA: "manage_mfa",
    MODIFY_SOCIAL_FACTOR: "modify_social_factor"
};
const BUILD_ENV = {
    PRODUCTION: "production",
    DEVELOPMENT: "development",
    STAGING: "staging",
    TESTING: "testing"
};
/**
 * {@label loginProviderType}
 */ // autocomplete workaround https://github.com/microsoft/TypeScript/issues/29729
const LANGUAGES = {
    en: "en",
    ja: "ja",
    ko: "ko",
    de: "de",
    zh: "zh",
    es: "es",
    fr: "fr",
    pt: "pt",
    nl: "nl",
    tr: "tr"
};
const LANGUAGE_MAP = {
    en: "english",
    ja: "japanese",
    ko: "korean",
    de: "german",
    zh: "mandarin",
    es: "spanish",
    fr: "french",
    pt: "portuguese",
    nl: "dutch",
    tr: "turkish"
};
const THEME_MODES = {
    light: "light",
    dark: "dark",
    auto: "auto"
};
const MFA_FACTOR = {
    DEVICE: "deviceShareFactor",
    BACKUP_SHARE: "backUpShareFactor",
    SOCIAL_BACKUP: "socialBackupFactor",
    PASSWORD: "passwordFactor",
    PASSKEYS: "passkeysFactor",
    AUTHENTICATOR: "authenticatorFactor"
};
function getColorsList() {
    let colorsAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
    let colorsShiftAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;
    let mixColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "black";
    let rotate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let saturation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;
    let mainColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "#0346ff";
    const colorsList = [];
    let step;
    for(step = 0; step < colorsAmount; step += 1){
        colorsList.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(mainColor).rotate((step + 1) / colorsAmount * -rotate).saturate((step + 1) / colorsAmount * (saturation / 100)).mix((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$color$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(mixColor), colorsShiftAmount / 100 * (step + 1) / colorsAmount).hex());
    }
    return colorsList;
}
function generateWhiteLabelTheme(primary) {
    const darkSet = getColorsList(3, 50, "black", 0, 20, primary);
    const lightSet = getColorsList(6, 85, "white", 0, 20, primary);
    return [
        ...darkSet.reverse(),
        primary,
        ...lightSet
    ];
}
function applyWhiteLabelTheme(rootElement, theme) {
    if (theme.primary) {
        const themeSet = generateWhiteLabelTheme(theme.primary);
        rootElement.style.setProperty("--app-primary-900", themeSet[0]);
        rootElement.style.setProperty("--app-primary-800", themeSet[1]);
        rootElement.style.setProperty("--app-primary-700", themeSet[2]);
        rootElement.style.setProperty("--app-primary-600", themeSet[3]);
        rootElement.style.setProperty("--app-primary-500", themeSet[4]);
        rootElement.style.setProperty("--app-primary-400", themeSet[5]);
        rootElement.style.setProperty("--app-primary-300", themeSet[6]);
        rootElement.style.setProperty("--app-primary-200", themeSet[7]);
        rootElement.style.setProperty("--app-primary-100", themeSet[8]);
        rootElement.style.setProperty("--app-primary-50", themeSet[9]);
    }
    if (theme.onPrimary) {
        rootElement.style.setProperty("--app-on-primary", theme.onPrimary);
    }
}
;
}}),
"[project]/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/base64url/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$constants$2f$dist$2f$constants$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/constants/dist/constants.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$utils$2f$dist$2f$openloginUtils$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decrypt": (()=>decrypt),
    "derive": (()=>derive),
    "derivePadded": (()=>derivePadded),
    "deriveUnpadded": (()=>deriveUnpadded),
    "encrypt": (()=>encrypt),
    "generatePrivate": (()=>generatePrivate),
    "getPublic": (()=>getPublic),
    "getPublicCompressed": (()=>getPublicCompressed),
    "sign": (()=>sign),
    "verify": (()=>verify)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$elliptic$2f$lib$2f$elliptic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/elliptic/lib/elliptic.js [app-ssr] (ecmascript)");
;
;
const ec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$elliptic$2f$lib$2f$elliptic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ec"]("secp256k1");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const browserCrypto = global.crypto || global.msCrypto || {};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
const EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
const ZERO32 = Buffer.alloc(32, 0);
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assertion failed");
    }
}
function isScalar(x) {
    return Buffer.isBuffer(x) && x.length === 32;
}
function isValidPrivateKey(privateKey) {
    if (!isScalar(privateKey)) {
        return false;
    }
    return privateKey.compare(ZERO32) > 0 && // > 0
    privateKey.compare(EC_GROUP_ORDER) < 0; // < G
}
// Compare two buffers in constant time to prevent timing attacks.
function equalConstTime(b1, b2) {
    if (b1.length !== b2.length) {
        return false;
    }
    let res = 0;
    for(let i = 0; i < b1.length; i++){
        res |= b1[i] ^ b2[i]; // jshint ignore:line
    }
    return res === 0;
}
/* This must check if we're in the browser or
not, since the functions are different and does
not convert using browserify */ function randomBytes(size) {
    const arr = new Uint8Array(size);
    if (typeof browserCrypto.getRandomValues === "undefined") {
        return Buffer.from(__TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].randomBytes(size));
    }
    browserCrypto.getRandomValues(arr);
    return Buffer.from(arr);
}
async function sha512(msg) {
    if (subtle) {
        const hash = await subtle.digest("SHA-512", msg);
        const result = new Uint8Array(hash);
        return result;
    }
    const hash = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash("sha512");
    const result = hash.update(msg).digest();
    return new Uint8Array(result);
}
function getAes(op) {
    return async function(iv, key, data) {
        if (subtle) {
            const importAlgorithm = {
                name: "AES-CBC"
            };
            const cryptoKey = await subtle.importKey("raw", key, importAlgorithm, false, [
                op
            ]);
            const encAlgorithm = {
                name: "AES-CBC",
                iv
            };
            const result = await subtle[op](encAlgorithm, cryptoKey, data);
            return Buffer.from(new Uint8Array(result));
        } else if (op === "encrypt") {
            const cipher = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createCipheriv("aes-256-cbc", key, iv);
            const firstChunk = cipher.update(data);
            const secondChunk = cipher.final();
            return Buffer.concat([
                firstChunk,
                secondChunk
            ]);
        } else if (op === "decrypt") {
            const decipher = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createDecipheriv("aes-256-cbc", key, iv);
            const firstChunk = decipher.update(data);
            const secondChunk = decipher.final();
            return Buffer.concat([
                firstChunk,
                secondChunk
            ]);
        }
        throw new Error(`Unsupported operation: ${op}`);
    };
}
const aesCbcEncrypt = getAes("encrypt");
const aesCbcDecrypt = getAes("decrypt");
async function hmacSha256Sign(key, msg) {
    if (subtle) {
        const importAlgorithm = {
            name: "HMAC",
            hash: {
                name: "SHA-256"
            }
        };
        const cryptoKey = await subtle.importKey("raw", new Uint8Array(key), importAlgorithm, false, [
            "sign",
            "verify"
        ]);
        const sig = await subtle.sign("HMAC", cryptoKey, msg);
        const result = Buffer.from(new Uint8Array(sig));
        return result;
    }
    const hmac = __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHmac("sha256", Buffer.from(key));
    hmac.update(msg);
    const result = hmac.digest();
    return result;
}
async function hmacSha256Verify(key, msg, sig) {
    const expectedSig = await hmacSha256Sign(key, msg);
    return equalConstTime(expectedSig, sig);
}
/**
 * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source
 * depending on your browser.
 */ const generatePrivate = function() {
    let privateKey = randomBytes(32);
    while(!isValidPrivateKey(privateKey)){
        privateKey = randomBytes(32);
    }
    return privateKey;
};
const getPublic = function(privateKey) {
    // This function has sync API so we throw an error immediately.
    assert(privateKey.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKey), "Bad private key");
    // XXX(Kagami): `elliptic.utils.encode` returns array for every
    // encoding except `hex`.
    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic("array"));
};
/**
 * Get compressed version of public key.
 */ const getPublicCompressed = function(privateKey) {
    // jshint ignore:line
    assert(privateKey.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKey), "Bad private key");
    // See https://github.com/wanderer/secp256k1-node/issues/46
    const compressed = true;
    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, "array"));
};
// NOTE(Kagami): We don't use promise shim in Browser implementation
// because it's supported natively in new browsers (see
// <http://caniuse.com/#feat=promises>) and we can use only new browsers
// because of the WebCryptoAPI (see
// <http://caniuse.com/#feat=cryptography>).
const sign = async function(privateKey, msg) {
    assert(privateKey.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKey), "Bad private key");
    assert(msg.length > 0, "Message should not be empty");
    assert(msg.length <= 32, "Message is too long");
    return Buffer.from(ec.sign(msg, privateKey, {
        canonical: true
    }).toDER());
};
const verify = async function(publicKey, msg, sig) {
    assert(publicKey.length === 65 || publicKey.length === 33, "Bad public key");
    if (publicKey.length === 65) {
        assert(publicKey[0] === 4, "Bad public key");
    }
    if (publicKey.length === 33) {
        assert(publicKey[0] === 2 || publicKey[0] === 3, "Bad public key");
    }
    assert(msg.length > 0, "Message should not be empty");
    assert(msg.length <= 32, "Message is too long");
    if (ec.verify(msg, sig, publicKey)) {
        return null;
    }
    throw new Error("Bad signature");
};
const derive = async function(privateKeyA, publicKeyB) {
    assert(Buffer.isBuffer(privateKeyA), "Bad private key");
    assert(Buffer.isBuffer(publicKeyB), "Bad public key");
    assert(privateKeyA.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKeyA), "Bad private key");
    assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
    if (publicKeyB.length === 65) {
        assert(publicKeyB[0] === 4, "Bad public key");
    }
    if (publicKeyB.length === 33) {
        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
    }
    const keyA = ec.keyFromPrivate(privateKeyA);
    const keyB = ec.keyFromPublic(publicKeyB);
    const Px = keyA.derive(keyB.getPublic()); // BN instance
    return Buffer.from(Px.toArray());
};
const deriveUnpadded = derive;
const derivePadded = async function(privateKeyA, publicKeyB) {
    assert(Buffer.isBuffer(privateKeyA), "Bad private key");
    assert(Buffer.isBuffer(publicKeyB), "Bad public key");
    assert(privateKeyA.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKeyA), "Bad private key");
    assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
    if (publicKeyB.length === 65) {
        assert(publicKeyB[0] === 4, "Bad public key");
    }
    if (publicKeyB.length === 33) {
        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
    }
    const keyA = ec.keyFromPrivate(privateKeyA);
    const keyB = ec.keyFromPublic(publicKeyB);
    const Px = keyA.derive(keyB.getPublic()); // BN instance
    return Buffer.from(Px.toString(16, 64), "hex");
};
const encrypt = async function(publicKeyTo, msg, opts) {
    opts = opts || {};
    let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
    // There is a very unlikely possibility that it is not a valid key
    while(!isValidPrivateKey(ephemPrivateKey)){
        ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
    }
    const ephemPublicKey = getPublic(ephemPrivateKey);
    const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);
    const hash = await sha512(Px);
    const iv = opts.iv || randomBytes(16);
    const encryptionKey = hash.slice(0, 32);
    const macKey = hash.slice(32);
    const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);
    const ciphertext = data;
    const dataToMac = Buffer.concat([
        iv,
        ephemPublicKey,
        ciphertext
    ]);
    const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);
    return {
        iv,
        ephemPublicKey,
        ciphertext,
        mac
    };
};
const decrypt = async function(privateKey, opts, _padding) {
    const padding = _padding !== null && _padding !== void 0 ? _padding : false;
    const deriveLocal = padding ? derivePadded : deriveUnpadded;
    const Px = await deriveLocal(privateKey, opts.ephemPublicKey);
    const hash = await sha512(Px);
    const encryptionKey = hash.slice(0, 32);
    const macKey = hash.slice(32);
    const dataToMac = Buffer.concat([
        opts.iv,
        opts.ephemPublicKey,
        opts.ciphertext
    ]);
    const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);
    if (!macGood && padding === false) {
        return decrypt(privateKey, opts, true);
    } else if (!macGood && padding === true) {
        throw new Error("bad MAC after trying padded");
    }
    const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);
    return Buffer.from(new Uint8Array(msg));
};
;
 //# sourceMappingURL=eccrypto.esm.js.map
}}),
"[project]/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decryptData": (()=>decryptData),
    "default": (()=>MetadataStorageLayer),
    "ec": (()=>ec),
    "encParamsBufToHex": (()=>encParamsBufToHex),
    "encParamsHexToBuf": (()=>encParamsHexToBuf),
    "encryptAndSetData": (()=>encryptAndSetData),
    "encryptData": (()=>encryptData),
    "getAndDecryptData": (()=>getAndDecryptData),
    "getDeviceShare": (()=>getDeviceShare),
    "getTorusShare": (()=>getTorusShare),
    "keccak256": (()=>keccak256),
    "setDeviceShare": (()=>setDeviceShare),
    "setTorusShare": (()=>setTorusShare)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$stable$2d$stringify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/json-stable-stringify/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$elliptic$2f$lib$2f$elliptic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/elliptic/lib/elliptic.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$keccak$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ethereum-cryptography/esm/keccak.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
function keccak256(a) {
    return Buffer.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$keccak$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])(a));
}
const ec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$elliptic$2f$lib$2f$elliptic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ec"]("secp256k1");
class MetadataStorageLayer {
    // ms
    constructor(){
        let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "https://metadata.tor.us";
        let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "metadataHost", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "serverTimeOffset", void 0);
        this.metadataHost = metadataHost;
        this.serverTimeOffset = serverTimeOffset;
    }
    static setAPIKey(apiKey) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setAPIKey"])(apiKey);
    }
    static setEmbedHost(embedHost) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setEmbedHost"])(embedHost);
    }
    generateMetadataParams(message, privateKeyHex) {
        var _sig$recoveryParam$to, _sig$recoveryParam;
        const key = ec.keyFromPrivate(privateKeyHex, "hex");
        const setData = {
            data: message,
            timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)
        };
        const sig = key.sign(keccak256(Buffer.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$json$2d$stable$2d$stringify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(setData), "utf8")));
        return {
            pub_key_X: key.getPublic().getX().toString(16, 64),
            pub_key_Y: key.getPublic().getY().toString(16, 64),
            set_data: setData,
            signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam$to = (_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, "0").slice(-2)) !== null && _sig$recoveryParam$to !== void 0 ? _sig$recoveryParam$to : "00"), "hex").toString("base64")
        };
    }
    generatePubKeyParams(privateKeyHex) {
        const key = ec.keyFromPrivate(privateKeyHex, "hex");
        return {
            pub_key_X: key.getPublic().getX().toString(16, 64),
            pub_key_Y: key.getPublic().getY().toString(16, 64)
        };
    }
    async setMetadata(data, namespace, options) {
        const params = namespace !== null ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, data), {}, {
            namespace
        }) : data;
        const metadataResponse = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${this.metadataHost}/set`, params, options, {
            useAPIKey: true
        });
        return metadataResponse.message;
    }
    async getMetadata(pubKey, namespace, options) {
        const params = namespace !== null ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, pubKey), {}, {
            namespace
        }) : pubKey;
        const metadataResponse = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${this.metadataHost}/get`, params, options, {
            useAPIKey: true
        });
        return metadataResponse.message;
    }
}
const WEBAUTHN_TORUS_SHARE = "webauthn_torus_share";
const WEBAUTHN_DEVICE_SHARE = "webauthn_device_share";
function encParamsHexToBuf(encParamsHex) {
    return {
        iv: Buffer.from(encParamsHex.iv, "hex"),
        ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, "hex"),
        ciphertext: Buffer.from(encParamsHex.ciphertext, "hex"),
        mac: Buffer.from(encParamsHex.mac, "hex")
    };
}
function encParamsBufToHex(encParams) {
    return {
        iv: Buffer.from(encParams.iv).toString("hex"),
        ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString("hex"),
        ciphertext: Buffer.from(encParams.ciphertext).toString("hex"),
        mac: Buffer.from(encParams.mac).toString("hex")
    };
}
async function encryptData(privKeyHex, d) {
    const serializedDec = JSON.stringify(d);
    const serializedBuf = Buffer.from(serializedDec, "utf-8");
    const encParams = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encrypt"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublic"])(Buffer.from(privKeyHex, "hex")), serializedBuf);
    const encParamsHex = encParamsBufToHex(encParams);
    const sData = JSON.stringify(encParamsHex);
    return sData;
}
async function decryptData(privKeyHex, d) {
    const encParamsHex = JSON.parse(d);
    const encParams = encParamsHexToBuf(encParamsHex);
    const keyPair = ec.keyFromPrivate(privKeyHex);
    const serializedBuf = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decrypt"])(Buffer.from(keyPair.getPrivate().toString("hex", 64), "hex"), encParams);
    const serializedDec = serializedBuf.toString("utf-8");
    const data = JSON.parse(serializedDec);
    return data;
}
async function getAndDecryptData(m, privKeyHex, namespace) {
    const keyPair = ec.keyFromPrivate(privKeyHex, "hex");
    const pubKey = keyPair.getPublic();
    const serializedData = await m.getMetadata({
        pub_key_X: pubKey.getX().toString(16, 64),
        pub_key_Y: pubKey.getY().toString(16, 64)
    }, namespace);
    if (!serializedData) {
        return null;
    }
    const data = await decryptData(privKeyHex, serializedData);
    return data;
}
async function encryptAndSetData(m, privKeyHex, d, namespace) {
    const sData = await encryptData(privKeyHex, d);
    const metadataParams = m.generateMetadataParams(sData, privKeyHex);
    await m.setMetadata(metadataParams, namespace);
}
async function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {
    const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);
    const privKey = refKeyPair.getPrivate();
    const pubKey = ec.keyFromPublic({
        x: webAuthnPubKey.pub_key_X,
        y: webAuthnPubKey.pub_key_Y
    });
    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);
    let d = {};
    if (data) d = data;
    const serializedSubspaceData = JSON.stringify(subspaceData);
    const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, "utf-8");
    const encSubspaceData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encrypt"])(Buffer.from(pubKey.getPublic("hex"), "hex"), serializedSubspaceDataBuf);
    const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);
    d[subspace] = encSubspaceDataHex;
    await encryptAndSetData(m, privKey.toString("hex", 64), d, WEBAUTHN_TORUS_SHARE);
}
async function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {
    const keyPair = ec.keyFromPrivate(webAuthnRefHex);
    const privKey = keyPair.getPrivate();
    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);
    let d = {};
    if (data) d = data;
    d[subspace] = subspaceData;
    await encryptAndSetData(m, privKey.toString("hex", 64), d, WEBAUTHN_DEVICE_SHARE);
}
async function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {
    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);
    if (!data) return null;
    const encParamsHex = data[subspace];
    if (!encParamsHex) return null;
    const encParams = encParamsHexToBuf(encParamsHex);
    const keyPair = ec.keyFromPrivate(webAuthnKeyHex);
    const privKey = keyPair.getPrivate();
    const serializedSubspaceDataBuf = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decrypt"])(Buffer.from(privKey.toString("hex", 64), "hex"), encParams);
    const serializedSubspaceData = serializedSubspaceDataBuf.toString("utf-8");
    const subspaceData = JSON.parse(serializedSubspaceData);
    return subspaceData;
}
async function getDeviceShare(m, webAuthnRefHex, subspace) {
    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);
    if (data) return data[subspace];
    return null;
}
;
}}),
"[project]/node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BroadcastChannel": (()=>BroadcastChannel$1),
    "IndexedDbMethod": (()=>IndexeDbMethod),
    "LocalStorageMethod": (()=>LocalstorageMethod),
    "NativeMethod": (()=>NativeMethod),
    "OPEN_BROADCAST_CHANNELS": (()=>OPEN_BROADCAST_CHANNELS),
    "ServerMethod": (()=>ServerMethod),
    "chooseMethod": (()=>chooseMethod),
    "enforceOptions": (()=>enforceOptions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loglevel/lib/loglevel.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oblivious$2d$set$2f$dist$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/oblivious-set/dist/esm/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/socket.io-client/build/esm-debug/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$metadata$2d$helpers$2f$dist$2f$metadataHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js [app-ssr] (ecmascript)");
;
;
;
;
;
// import Bowser from 'bowser';
/**
 * returns true if the given object is a promise
 */ function isPromise(obj) {
    if (obj && typeof obj.then === 'function') {
        return true;
    } else {
        return false;
    }
}
Promise.resolve(false);
Promise.resolve(true);
const PROMISE_RESOLVED_VOID = Promise.resolve();
function sleep(time, resolveWith) {
    if (!time) time = 0;
    return new Promise((res)=>setTimeout(()=>res(resolveWith), time));
}
function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * https://stackoverflow.com/a/8084248
 */ function randomToken() {
    return Math.random().toString(36).substring(2);
}
let lastMs = 0;
/**
 * returns the current time in micro-seconds,
 * WARNING: This is a pseudo-function
 * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.
 * This is enough in browsers, and this function will not be used in nodejs.
 * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.
 */ function microSeconds$5() {
    let ret = Date.now() * 1000; // milliseconds to microseconds
    if (ret <= lastMs) {
        ret = lastMs + 1;
    }
    lastMs = ret;
    return ret;
}
// the problem is only in iframes. we should default to server in case of iframes.
// storage scoping is present in all browsers now
// Safari and other browsers support native Broadcast channel now. It's in LS.
// test here: https://pubkey.github.io/broadcast-channel/e2e.html?methodType=native
// https://caniuse.com/broadcastchannel
// export function are3PCSupported() {
//     if (typeof navigator === 'undefined') return false;
//     const browserInfo = Bowser.parse(navigator.userAgent);
//     log.info(JSON.stringify(browserInfo), 'current browser info');
//     let thirdPartyCookieSupport = true;
//     // brave
//     if (navigator.brave) {
//         thirdPartyCookieSupport = false;
//     }
//     // All webkit & gecko engine instances use itp (intelligent tracking prevention -
//     // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)
//     if (browserInfo.engine.name === Bowser.ENGINE_MAP.WebKit || browserInfo.engine.name === Bowser.ENGINE_MAP.Gecko) {
//         thirdPartyCookieSupport = false;
//     }
//     return thirdPartyCookieSupport;
// }
const log = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getLogger('broadcast-channel');
log.setLevel('error');
const microSeconds$4 = microSeconds$5;
const type$4 = 'native';
function create$4(channelName) {
    const state = {
        time: microSeconds$5(),
        messagesCallback: null,
        bc: new BroadcastChannel(channelName),
        subFns: [] // subscriberFunctions
    };
    state.bc.onmessage = (msg)=>{
        if (state.messagesCallback) {
            state.messagesCallback(msg.data);
        }
    };
    return state;
}
function close$4(channelState) {
    channelState.bc.close();
    channelState.subFns = [];
}
function postMessage$4(channelState, messageJson) {
    try {
        channelState.bc.postMessage(messageJson, false);
        return PROMISE_RESOLVED_VOID;
    } catch (err) {
        return Promise.reject(err);
    }
}
function onMessage$4(channelState, fn1) {
    channelState.messagesCallback = fn1;
}
function canBeUsed$4() {
    /**
   * in the electron-renderer, isNode will be true even if we are in browser-context
   * so we also check if window is undefined
   */ if (typeof window === 'undefined') return false;
    if (typeof BroadcastChannel === 'function') {
        if (BroadcastChannel._pubkey) {
            throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');
        }
        return true;
    } else return false;
}
function averageResponseTime$4() {
    return 150;
}
var NativeMethod = {
    create: create$4,
    close: close$4,
    onMessage: onMessage$4,
    postMessage: postMessage$4,
    canBeUsed: canBeUsed$4,
    type: type$4,
    averageResponseTime: averageResponseTime$4,
    microSeconds: microSeconds$4
};
function fillOptionsWithDefaults() {
    let originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const options = JSON.parse(JSON.stringify(originalOptions));
    // main
    if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true;
    // indexed-db
    if (!options.idb) options.idb = {};
    //  after this time the messages get deleted
    if (!options.idb.ttl) options.idb.ttl = 1000 * 45;
    if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;
    //  handles abrupt db onclose events.
    if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose;
    // localstorage
    if (!options.localstorage) options.localstorage = {};
    if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;
    // server
    if (!options.server) options.server = {};
    if (!options.server.url) options.server.url = 'https://session.web3auth.io';
    if (!options.server.removeTimeout) options.server.removeTimeout = 1000 * 60 * 5; // 5 minutes
    // custom methods
    if (originalOptions.methods) options.methods = originalOptions.methods;
    return options;
}
/**
 * this method uses indexeddb to store the messages
 * There is currently no observerAPI for idb
 * @link https://github.com/w3c/IndexedDB/issues/51
 *
 * When working on this, ensure to use these performance optimizations:
 * @link https://rxdb.info/slow-indexeddb.html
 */ const microSeconds$3 = microSeconds$5;
const DB_PREFIX = 'pubkey.broadcast-channel-0-';
const OBJECT_STORE_ID = 'messages';
/**
 * Use relaxed durability for faster performance on all transactions.
 * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/
 */ const TRANSACTION_SETTINGS = {
    durability: 'relaxed'
};
const type$3 = 'idb';
function getIdb() {
    if (typeof indexedDB !== 'undefined') return indexedDB;
    if (typeof window !== 'undefined') {
        if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;
        if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;
        if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;
    }
    return false;
}
/**
 * If possible, we should explicitly commit IndexedDB transactions
 * for better performance.
 * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/
 */ function commitIndexedDBTransaction(tx) {
    if (tx.commit) {
        tx.commit();
    }
}
function createDatabase(channelName) {
    const IndexedDB = getIdb();
    // create table
    const dbName = DB_PREFIX + channelName;
    /**
   * All IndexedDB databases are opened without version
   * because it is a bit faster, especially on firefox
   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version
   */ const openRequest = IndexedDB.open(dbName);
    openRequest.onupgradeneeded = (ev)=>{
        const db = ev.target.result;
        db.createObjectStore(OBJECT_STORE_ID, {
            keyPath: 'id',
            autoIncrement: true
        });
    };
    const dbPromise = new Promise((res, rej)=>{
        openRequest.onerror = (ev)=>rej(ev);
        openRequest.onsuccess = ()=>{
            res(openRequest.result);
        };
    });
    return dbPromise;
}
/**
 * writes the new message to the database
 * so other readers can find it
 */ function writeMessage(db, readerUuid, messageJson) {
    const time = Date.now();
    const writeObject = {
        uuid: readerUuid,
        time,
        data: messageJson
    };
    const tx = db.transaction([
        OBJECT_STORE_ID
    ], 'readwrite', TRANSACTION_SETTINGS);
    return new Promise((res, rej)=>{
        tx.oncomplete = ()=>res();
        tx.onerror = (ev)=>rej(ev);
        const objectStore = tx.objectStore(OBJECT_STORE_ID);
        objectStore.add(writeObject);
        commitIndexedDBTransaction(tx);
    });
}
function getAllMessages(db) {
    const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);
    const objectStore = tx.objectStore(OBJECT_STORE_ID);
    const ret = [];
    return new Promise((res)=>{
        objectStore.openCursor().onsuccess = (ev)=>{
            const cursor = ev.target.result;
            if (cursor) {
                ret.push(cursor.value);
                //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);
                cursor.continue();
            } else {
                commitIndexedDBTransaction(tx);
                res(ret);
            }
        };
    });
}
function getMessagesHigherThan(db, lastCursorId) {
    const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);
    const objectStore = tx.objectStore(OBJECT_STORE_ID);
    const ret = [];
    let keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
    /**
   * Optimization shortcut,
   * if getAll() can be used, do not use a cursor.
   * @link https://rxdb.info/slow-indexeddb.html
   */ if (objectStore.getAll) {
        const getAllRequest = objectStore.getAll(keyRangeValue);
        return new Promise((res, rej)=>{
            getAllRequest.onerror = (err)=>rej(err);
            getAllRequest.onsuccess = function(e) {
                res(e.target.result);
            };
        });
    }
    function openCursor() {
        // Occasionally Safari will fail on IDBKeyRange.bound, this
        // catches that error, having it open the cursor to the first
        // item. When it gets data it will advance to the desired key.
        try {
            keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
            return objectStore.openCursor(keyRangeValue);
        } catch (e) {
            return objectStore.openCursor();
        }
    }
    return new Promise((res, rej)=>{
        const openCursorRequest = openCursor();
        openCursorRequest.onerror = (err)=>rej(err);
        openCursorRequest.onsuccess = (ev)=>{
            const cursor = ev.target.result;
            if (cursor) {
                if (cursor.value.id < lastCursorId + 1) {
                    cursor.continue(lastCursorId + 1);
                } else {
                    ret.push(cursor.value);
                    cursor.continue();
                }
            } else {
                commitIndexedDBTransaction(tx);
                res(ret);
            }
        };
    });
}
function removeMessagesById(db, ids) {
    const tx = db.transaction([
        OBJECT_STORE_ID
    ], 'readwrite', TRANSACTION_SETTINGS);
    const objectStore = tx.objectStore(OBJECT_STORE_ID);
    return Promise.all(ids.map((id)=>{
        const deleteRequest = objectStore.delete(id);
        return new Promise((res)=>{
            deleteRequest.onsuccess = ()=>res();
        });
    }));
}
function getOldMessages(db, ttl) {
    const olderThen = Date.now() - ttl;
    const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);
    const objectStore = tx.objectStore(OBJECT_STORE_ID);
    const ret = [];
    return new Promise((res)=>{
        objectStore.openCursor().onsuccess = (ev)=>{
            const cursor = ev.target.result;
            if (cursor) {
                const msgObk = cursor.value;
                if (msgObk.time < olderThen) {
                    ret.push(msgObk);
                    //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);
                    cursor.continue();
                } else {
                    // no more old messages,
                    commitIndexedDBTransaction(tx);
                    res(ret);
                    return;
                }
            } else {
                res(ret);
            }
        };
    });
}
function cleanOldMessages(db, ttl) {
    return getOldMessages(db, ttl).then((tooOld)=>{
        return removeMessagesById(db, tooOld.map((msg)=>msg.id));
    });
}
function create$3(channelName, options) {
    options = fillOptionsWithDefaults(options);
    return createDatabase(channelName).then((db)=>{
        const state = {
            closed: false,
            lastCursorId: 0,
            channelName,
            options,
            uuid: randomToken(),
            /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */ eMIs: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oblivious$2d$set$2f$dist$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObliviousSet"](options.idb.ttl * 2),
            // ensures we do not read messages in parrallel
            writeBlockPromise: PROMISE_RESOLVED_VOID,
            messagesCallback: null,
            readQueuePromises: [],
            db,
            time: microSeconds$5()
        };
        /**
     * Handle abrupt closes that do not originate from db.close().
     * This could happen, for example, if the underlying storage is
     * removed or if the user clears the database in the browser's
     * history preferences.
     */ db.onclose = function() {
            state.closed = true;
            if (options.idb.onclose) options.idb.onclose();
        };
        /**
     * if service-workers are used,
     * we have no 'storage'-event if they post a message,
     * therefore we also have to set an interval
     */ _readLoop(state);
        return state;
    });
}
function _readLoop(state) {
    if (state.closed) return;
    readNewMessages(state).then(()=>sleep(state.options.idb.fallbackInterval)).then(()=>_readLoop(state));
}
function _filterMessage(msgObj, state) {
    if (msgObj.uuid === state.uuid) return false; // send by own
    if (state.eMIs.has(msgObj.id)) return false; // already emitted
    if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback
    return true;
}
/**
 * reads all new messages from the database and emits them
 */ function readNewMessages(state) {
    // channel already closed
    if (state.closed) return PROMISE_RESOLVED_VOID;
    // if no one is listening, we do not need to scan for new messages
    if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;
    return getMessagesHigherThan(state.db, state.lastCursorId).then((newerMessages)=>{
        const useMessages = newerMessages/**
     * there is a bug in iOS where the msgObj can be undefined some times
     * so we filter them out
     * @link https://github.com/pubkey/broadcast-channel/issues/19
     */ .filter((msgObj)=>!!msgObj).map((msgObj)=>{
            if (msgObj.id > state.lastCursorId) {
                state.lastCursorId = msgObj.id;
            }
            return msgObj;
        }).filter((msgObj)=>_filterMessage(msgObj, state)).sort((msgObjA, msgObjB)=>msgObjA.time - msgObjB.time); // sort by time
        useMessages.forEach((msgObj)=>{
            if (state.messagesCallback) {
                state.eMIs.add(msgObj.id);
                state.messagesCallback(msgObj.data);
            }
        });
        return PROMISE_RESOLVED_VOID;
    });
}
function close$3(channelState) {
    channelState.closed = true;
    channelState.db.close();
}
function postMessage$3(channelState, messageJson) {
    channelState.writeBlockPromise = channelState.writeBlockPromise.then(()=>writeMessage(channelState.db, channelState.uuid, messageJson)).then(()=>{
        if (randomInt(0, 10) === 0) {
            /* await (do not await) */ cleanOldMessages(channelState.db, channelState.options.idb.ttl);
        }
    });
    return channelState.writeBlockPromise;
}
function onMessage$3(channelState, fn1, time) {
    channelState.messagesCallbackTime = time;
    channelState.messagesCallback = fn1;
    readNewMessages(channelState);
}
function canBeUsed$3() {
    const idb = getIdb();
    if (!idb) return false;
    return true;
}
function averageResponseTime$3(options) {
    return options.idb.fallbackInterval * 2;
}
var IndexeDbMethod = {
    getIdb,
    createDatabase,
    create: create$3,
    close: close$3,
    onMessage: onMessage$3,
    postMessage: postMessage$3,
    canBeUsed: canBeUsed$3,
    type: type$3,
    averageResponseTime: averageResponseTime$3,
    microSeconds: microSeconds$3,
    writeMessage,
    getAllMessages,
    cleanOldMessages,
    getMessagesHigherThan,
    getOldMessages
};
/**
 * A localStorage-only method which uses localstorage and its 'storage'-event
 * This does not work inside of webworkers because they have no access to locastorage
 * This is basically implemented to support IE9 or your grandmothers toaster.
 * @link https://caniuse.com/#feat=namevalue-storage
 * @link https://caniuse.com/#feat=indexeddb
 */ const microSeconds$2 = microSeconds$5;
const KEY_PREFIX$1 = 'pubkey.broadcastChannel-';
const type$2 = 'localstorage';
/**
 * copied from crosstab
 * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32
 */ function getLocalStorage() {
    let localStorage;
    if (typeof window === 'undefined') return null;
    try {
        localStorage = window.localStorage;
        localStorage = window['ie8-eventlistener/storage'] || window.localStorage;
    } catch (e) {
    // New versions of Firefox throw a Security exception
    // if cookies are disabled. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153
    }
    return localStorage;
}
function storageKey$1(channelName) {
    return KEY_PREFIX$1 + channelName;
}
/**
 * writes the new message to the storage
 * and fires the storage-event so other readers can find it
 */ function postMessage$2(channelState, messageJson) {
    return new Promise((res)=>{
        sleep().then(()=>{
            const key = storageKey$1(channelState.channelName);
            const writeObj = {
                token: randomToken(),
                time: Date.now(),
                data: messageJson,
                uuid: channelState.uuid
            };
            const value = JSON.stringify(writeObj);
            getLocalStorage().setItem(key, value);
            /**
       * StorageEvent does not fire the 'storage' event
       * in the window that changes the state of the local storage.
       * So we fire it manually
       */ const ev = document.createEvent('Event');
            ev.initEvent('storage', true, true);
            ev.key = key;
            ev.newValue = value;
            window.dispatchEvent(ev);
            res();
        });
    });
}
function addStorageEventListener(channelName, fn1) {
    const key = storageKey$1(channelName);
    const listener = (ev)=>{
        if (ev.key === key) {
            fn1(JSON.parse(ev.newValue));
        }
    };
    window.addEventListener('storage', listener);
    return listener;
}
function removeStorageEventListener(listener) {
    window.removeEventListener('storage', listener);
}
function create$2(channelName, options) {
    options = fillOptionsWithDefaults(options);
    if (!canBeUsed$2()) {
        throw new Error('BroadcastChannel: localstorage cannot be used');
    }
    const uuid = randomToken();
    /**
   * eMIs
   * contains all messages that have been emitted before
   * @type {ObliviousSet}
   */ const eMIs = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oblivious$2d$set$2f$dist$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObliviousSet"](options.localstorage.removeTimeout);
    const state = {
        channelName,
        uuid,
        time: microSeconds$5(),
        eMIs
    };
    state.listener = addStorageEventListener(channelName, (msgObj)=>{
        if (!state.messagesCallback) return; // no listener
        if (msgObj.uuid === uuid) return; // own message
        if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted
        if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old
        eMIs.add(msgObj.token);
        state.messagesCallback(msgObj.data);
    });
    return state;
}
function close$2(channelState) {
    removeStorageEventListener(channelState.listener);
}
function onMessage$2(channelState, fn1, time) {
    channelState.messagesCallbackTime = time;
    channelState.messagesCallback = fn1;
}
function canBeUsed$2() {
    const ls = getLocalStorage();
    if (!ls) return false;
    try {
        const key = '__broadcastchannel_check';
        ls.setItem(key, 'works');
        ls.removeItem(key);
    } catch (e) {
        // Safari 10 in private mode will not allow write access to local
        // storage and fail with a QuotaExceededError. See
        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes
        return false;
    }
    return true;
}
function averageResponseTime$2() {
    const defaultTime = 120;
    const userAgent = navigator.userAgent.toLowerCase();
    if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
        // safari is much slower so this time is higher
        return defaultTime * 2;
    }
    return defaultTime;
}
var LocalstorageMethod = {
    getLocalStorage,
    create: create$2,
    close: close$2,
    onMessage: onMessage$2,
    postMessage: postMessage$2,
    canBeUsed: canBeUsed$2,
    type: type$2,
    averageResponseTime: averageResponseTime$2,
    microSeconds: microSeconds$2,
    storageKey: storageKey$1,
    addStorageEventListener,
    removeStorageEventListener
};
/**
 * A localStorage-only method which uses localstorage and its 'storage'-event
 * This does not work inside of webworkers because they have no access to locastorage
 * This is basically implemented to support IE9 or your grandmothers toaster.
 * @link https://caniuse.com/#feat=namevalue-storage
 * @link https://caniuse.com/#feat=indexeddb
 */ const microSeconds$1 = microSeconds$5;
const KEY_PREFIX = 'pubkey.broadcastChannel-';
const type$1 = 'server';
let SOCKET_CONN_INSTANCE = null;
// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly
const runningChannels = new Set();
function storageKey(channelName) {
    return KEY_PREFIX + channelName;
}
/**
 * writes the new message to the storage
 * and fires the storage-event so other readers can find it
 */ function postMessage$1(channelState, messageJson) {
    return new Promise((res, rej)=>{
        sleep().then(async ()=>{
            const key = storageKey(channelState.channelName);
            const channelEncPrivKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$metadata$2d$helpers$2f$dist$2f$metadataHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])(Buffer.from(key, 'utf8'));
            const encData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$metadata$2d$helpers$2f$dist$2f$metadataHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encryptData"])(channelEncPrivKey.toString('hex'), {
                token: randomToken(),
                time: Date.now(),
                data: messageJson,
                uuid: channelState.uuid
            });
            const body = {
                sameOriginCheck: true,
                sameIpCheck: true,
                key: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublic"])(channelEncPrivKey).toString('hex'),
                data: encData,
                signature: (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sign"])(channelEncPrivKey, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$metadata$2d$helpers$2f$dist$2f$metadataHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])(Buffer.from(encData, 'utf8')))).toString('hex')
            };
            if (channelState.timeout) body.timeout = channelState.timeout;
            return fetch(channelState.serverUrl + '/channel/set', {
                method: 'POST',
                body: JSON.stringify(body),
                headers: {
                    'Content-Type': 'application/json; charset=utf-8'
                }
            }).then(res).catch(rej);
        });
    });
}
function getSocketInstance(serverUrl) {
    if (SOCKET_CONN_INSTANCE) {
        return SOCKET_CONN_INSTANCE;
    }
    const SOCKET_CONN = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socket$2e$io$2d$client$2f$build$2f$esm$2d$debug$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["io"])(serverUrl, {
        transports: [
            'websocket',
            'polling'
        ],
        // use WebSocket first, if available
        withCredentials: true,
        reconnectionDelayMax: 10000,
        reconnectionAttempts: 10
    });
    SOCKET_CONN.on('connect_error', (err)=>{
        // revert to classic upgrade
        SOCKET_CONN.io.opts.transports = [
            'polling',
            'websocket'
        ];
        log.error('connect error', err);
    });
    SOCKET_CONN.on('connect', async ()=>{
        const { engine } = SOCKET_CONN.io;
        log.debug('initially connected to', engine.transport.name); // in most cases, prints "polling"
        engine.once('upgrade', ()=>{
            // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)
            log.debug('upgraded', engine.transport.name); // in most cases, prints "websocket"
        });
        engine.once('close', (reason)=>{
            // called when the underlying connection is closed
            log.debug('connection closed', reason);
        });
    });
    SOCKET_CONN.on('error', (err)=>{
        log.error('socket errored', err);
        SOCKET_CONN.disconnect();
    });
    SOCKET_CONN_INSTANCE = SOCKET_CONN;
    return SOCKET_CONN;
}
function setupSocketConnection(serverUrl, channelState, fn1) {
    const socketConn = getSocketInstance(serverUrl);
    const key = storageKey(channelState.channelName);
    const channelEncPrivKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$metadata$2d$helpers$2f$dist$2f$metadataHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])(Buffer.from(key, 'utf8'));
    const channelPubKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$eccrypto$2f$dist$2f$eccrypto$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPublic"])(channelEncPrivKey).toString('hex');
    if (socketConn.connected) {
        socketConn.emit('check_auth_status', channelPubKey, {
            sameOriginCheck: true,
            sameIpCheck: true
        });
    } else {
        socketConn.once('connect', ()=>{
            log.debug('connected with socket');
            socketConn.emit('check_auth_status', channelPubKey, {
                sameOriginCheck: true,
                sameIpCheck: true
            });
        });
    }
    const reconnect = ()=>{
        socketConn.once('connect', async ()=>{
            if (runningChannels.has(channelState.channelName)) {
                socketConn.emit('check_auth_status', channelPubKey, {
                    sameOriginCheck: true,
                    sameIpCheck: true
                });
            }
        });
    };
    const visibilityListener = ()=>{
        // if channel is closed, then remove the listener.
        if (!socketConn || !runningChannels.has(channelState.channelName)) {
            document.removeEventListener('visibilitychange', visibilityListener);
            return;
        }
        // if not connected, then wait for connection and ping server for latest msg.
        if (!socketConn.connected && document.visibilityState === 'visible') {
            reconnect();
        }
    };
    const listener = async (ev)=>{
        try {
            const decData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$metadata$2d$helpers$2f$dist$2f$metadataHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decryptData"])(channelEncPrivKey.toString('hex'), ev);
            log.info(decData);
            fn1(decData);
        } catch (error) {
            log.error(error);
        }
    };
    socketConn.on('disconnect', ()=>{
        log.debug('socket disconnected');
        if (runningChannels.has(channelState.channelName)) {
            log.error('socket disconnected unexpectedly, reconnecting socket');
            reconnect();
        }
    });
    socketConn.on(`${channelPubKey}_success`, listener);
    if (typeof document !== 'undefined') document.addEventListener('visibilitychange', visibilityListener);
    return socketConn;
}
function create$1(channelName, options) {
    options = fillOptionsWithDefaults(options);
    const uuid = randomToken();
    /**
   * eMIs
   * contains all messages that have been emitted before
   * @type {ObliviousSet}
   */ const eMIs = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$oblivious$2d$set$2f$dist$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObliviousSet"](options.server.removeTimeout);
    const state = {
        channelName,
        uuid,
        eMIs,
        // emittedMessagesIds
        serverUrl: options.server.url,
        time: microSeconds$5()
    };
    if (options.server.timeout) state.timeout = options.server.timeout;
    setupSocketConnection(options.server.url, state, (msgObj)=>{
        if (!state.messagesCallback) return; // no listener
        if (msgObj.uuid === state.uuid) return; // own message
        if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted
        // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old
        state.eMIs.add(msgObj.token);
        state.messagesCallback(msgObj.data);
    });
    runningChannels.add(channelName);
    return state;
}
function close$1(channelState) {
    runningChannels.delete(channelState.channelName);
// give 2 sec for all msgs which are in transit to be consumed
// by receiver.
// window.setTimeout(() => {
//     removeStorageEventListener(channelState);
//     SOCKET_CONN_INSTANCE = null;
// }, 1000);
}
function onMessage$1(channelState, fn1, time) {
    channelState.messagesCallbackTime = time;
    channelState.messagesCallback = fn1;
}
function canBeUsed$1() {
    return true;
}
function averageResponseTime$1() {
    const defaultTime = 500;
    // TODO: Maybe increase it based on operation
    return defaultTime;
}
var ServerMethod = {
    create: create$1,
    close: close$1,
    onMessage: onMessage$1,
    postMessage: postMessage$1,
    canBeUsed: canBeUsed$1,
    type: type$1,
    averageResponseTime: averageResponseTime$1,
    microSeconds: microSeconds$1
};
const microSeconds = microSeconds$5;
const type = 'simulate';
const SIMULATE_CHANNELS = new Set();
const SIMULATE_DELAY_TIME = 5;
function create(channelName) {
    const state = {
        time: microSeconds$5(),
        name: channelName,
        messagesCallback: null
    };
    SIMULATE_CHANNELS.add(state);
    return state;
}
function close(channelState) {
    SIMULATE_CHANNELS.delete(channelState);
}
function postMessage(channelState, messageJson) {
    return new Promise((res)=>setTimeout(()=>{
            const channelArray = Array.from(SIMULATE_CHANNELS);
            channelArray.forEach((channel)=>{
                if (channel.name === channelState.name && // has same name
                channel !== channelState && // not own channel
                !!channel.messagesCallback && // has subscribers
                channel.time < messageJson.time // channel not created after postMessage() call
                ) {
                    channel.messagesCallback(messageJson);
                }
            });
            res();
        }, SIMULATE_DELAY_TIME));
}
function onMessage(channelState, fn1) {
    channelState.messagesCallback = fn1;
}
function canBeUsed() {
    return true;
}
function averageResponseTime() {
    return SIMULATE_DELAY_TIME;
}
var SimulateMethod = {
    create,
    close,
    onMessage,
    postMessage,
    canBeUsed,
    type,
    averageResponseTime,
    microSeconds
};
// order is important
const METHODS = [
    NativeMethod,
    // fastest
    IndexeDbMethod,
    LocalstorageMethod,
    ServerMethod
];
function chooseMethod(options) {
    let chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
    // directly chosen
    if (options.type) {
        if (options.type === 'simulate') {
            // only use simulate-method if directly chosen
            return SimulateMethod;
        }
        const ret = chooseMethods.find((m)=>m.type === options.type);
        if (!ret) throw new Error('method-type ' + options.type + ' not found');
        else return ret;
    }
    /**
   * if no webworker support is needed,
   * remove idb from the list so that localstorage is been chosen
   */ if (!options.webWorkerSupport) {
        chooseMethods = chooseMethods.filter((m)=>m.type !== 'idb');
    }
    const useMethod = chooseMethods.find((method)=>method.canBeUsed(options));
    if (!useMethod) throw new Error(`No useable method found in ${JSON.stringify(METHODS.map((m)=>m.type))}`);
    else return useMethod;
}
/**
 * Contains all open channels,
 * used in tests to ensure everything is closed.
 */ const OPEN_BROADCAST_CHANNELS = new Set();
let lastId = 0;
const BroadcastChannel$1 = function(name, options) {
    // identifier of the channel to debug stuff
    this.id = lastId++;
    OPEN_BROADCAST_CHANNELS.add(this);
    this.name = name;
    if (ENFORCED_OPTIONS) {
        options = ENFORCED_OPTIONS;
    }
    this.options = fillOptionsWithDefaults(options);
    this.method = chooseMethod(this.options);
    // isListening
    this._iL = false;
    /**
   * _onMessageListener
   * setting onmessage twice,
   * will overwrite the first listener
   */ this._onML = null;
    /**
   * _addEventListeners
   */ this._addEL = {
        message: [],
        internal: []
    };
    /**
   * Unsend message promises
   * where the sending is still in progress
   * @type {Set<Promise>}
   */ this._uMP = new Set();
    /**
   * _beforeClose
   * array of promises that will be awaited
   * before the channel is closed
   */ this._befC = [];
    /**
   * _preparePromise
   */ this._prepP = null;
    _prepareChannel(this);
};
// STATICS
/**
 * used to identify if someone overwrites
 * window.BroadcastChannel with this
 * See methods/native.js
 */ BroadcastChannel$1._pubkey = true;
/**
 * if set, this method is enforced,
 * no mather what the options are
 */ let ENFORCED_OPTIONS;
function enforceOptions(options) {
    ENFORCED_OPTIONS = options;
}
// PROTOTYPE
BroadcastChannel$1.prototype = {
    postMessage (msg) {
        if (this.closed) {
            throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' + /**
       * In the past when this error appeared, it was realy hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */ JSON.stringify(msg));
        }
        return _post(this, 'message', msg);
    },
    postInternal (msg) {
        return _post(this, 'internal', msg);
    },
    set onmessage (fn){
        const time = this.method.microSeconds();
        const listenObj = {
            time,
            fn
        };
        _removeListenerObject(this, 'message', this._onML);
        if (fn && typeof fn === 'function') {
            this._onML = listenObj;
            _addListenerObject(this, 'message', listenObj);
        } else {
            this._onML = null;
        }
    },
    addEventListener (type, fn1) {
        const time = this.method.microSeconds();
        const listenObj = {
            time,
            fn: fn1
        };
        _addListenerObject(this, type, listenObj);
    },
    removeEventListener (type, fn1) {
        const obj = this._addEL[type].find((obj)=>obj.fn === fn1);
        _removeListenerObject(this, type, obj);
    },
    close () {
        if (this.closed) {
            return;
        }
        OPEN_BROADCAST_CHANNELS.delete(this);
        this.closed = true;
        const awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
        this._onML = null;
        this._addEL.message = [];
        return awaitPrepare// wait until all current sending are processed
        .then(()=>Promise.all(Array.from(this._uMP)))// run before-close hooks
        .then(()=>Promise.all(this._befC.map((fn1)=>fn1())))// close the channel
        .then(()=>this.method.close(this._state));
    },
    get type () {
        return this.method.type;
    },
    get isClosed () {
        return this.closed;
    }
};
/**
 * Post a message over the channel
 * @returns {Promise} that resolved when the message sending is done
 */ function _post(broadcastChannel, type, msg) {
    const time = broadcastChannel.method.microSeconds();
    const msgObj = {
        time,
        type,
        data: msg
    };
    const awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;
    return awaitPrepare.then(()=>{
        const sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
        // add/remove to unsend messages list
        broadcastChannel._uMP.add(sendPromise);
        sendPromise.catch().then(()=>broadcastChannel._uMP.delete(sendPromise));
        return sendPromise;
    });
}
function _prepareChannel(channel) {
    const maybePromise = channel.method.create(channel.name, channel.options);
    if (isPromise(maybePromise)) {
        channel._prepP = maybePromise;
        maybePromise.then((s)=>{
            // used in tests to simulate slow runtime
            /*if (channel.options.prepareDelay) {
           await new Promise(res => setTimeout(res, this.options.prepareDelay));
      }*/ channel._state = s;
        });
    } else {
        channel._state = maybePromise;
    }
}
function _hasMessageListeners(channel) {
    if (channel._addEL.message.length > 0) return true;
    if (channel._addEL.internal.length > 0) return true;
    return false;
}
function _addListenerObject(channel, type, obj) {
    channel._addEL[type].push(obj);
    _startListening(channel);
}
function _removeListenerObject(channel, type, obj) {
    channel._addEL[type] = channel._addEL[type].filter((o)=>o !== obj);
    _stopListening(channel);
}
function _startListening(channel) {
    if (!channel._iL && _hasMessageListeners(channel)) {
        // someone is listening, start subscribing
        const listenerFn = (msgObj)=>{
            channel._addEL[msgObj.type].forEach((listenerObject)=>{
                /**
         * Getting the current time in JavaScript has no good precision.
         * So instead of only listening to events that happend 'after' the listener
         * was added, we also listen to events that happended 100ms before it.
         * This ensures that when another process, like a WebWorker, sends events
         * we do not miss them out because their timestamp is a bit off compared to the main process.
         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.
         * @link https://johnresig.com/blog/accuracy-of-javascript-time/
         */ // const hundredMsInMicro = 100 * 1000;
                // const minMessageTime = listenerObject.time - hundredMsInMicro;
                if (msgObj.time >= listenerObject.time) {
                    listenerObject.fn(msgObj.data);
                } else if (channel.method.type === 'server') {
                    // server msg might lag based on connection.
                    listenerObject.fn(msgObj.data);
                }
            });
        };
        const time = channel.method.microSeconds();
        if (channel._prepP) {
            channel._prepP.then(()=>{
                channel._iL = true;
                channel.method.onMessage(channel._state, listenerFn, time);
            });
        } else {
            channel._iL = true;
            channel.method.onMessage(channel._state, listenerFn, time);
        }
    }
}
function _stopListening(channel) {
    if (channel._iL && !_hasMessageListeners(channel)) {
        // noone is listening, stop subscribing
        channel._iL = false;
        const time = channel.method.microSeconds();
        channel.method.onMessage(channel._state, null, time);
    }
}
;
}}),
"[project]/node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ACCOUNT_CATEGORY": (()=>ACCOUNT_CATEGORY),
    "ACTIVITY_ACTION": (()=>ACTIVITY_ACTION),
    "ACTIVITY_ACTION_ACCEPT_NFT_OFFER": (()=>ACTIVITY_ACTION_ACCEPT_NFT_OFFER),
    "ACTIVITY_ACTION_ALL": (()=>ACTIVITY_ACTION_ALL),
    "ACTIVITY_ACTION_BURN": (()=>ACTIVITY_ACTION_BURN),
    "ACTIVITY_ACTION_CANCEL_NFT_OFFER": (()=>ACTIVITY_ACTION_CANCEL_NFT_OFFER),
    "ACTIVITY_ACTION_CREATE_NFT_OFFER": (()=>ACTIVITY_ACTION_CREATE_NFT_OFFER),
    "ACTIVITY_ACTION_CREATE_TRUSTLINE": (()=>ACTIVITY_ACTION_CREATE_TRUSTLINE),
    "ACTIVITY_ACTION_RECEIVE": (()=>ACTIVITY_ACTION_RECEIVE),
    "ACTIVITY_ACTION_REMOVE_TRUSTLINE": (()=>ACTIVITY_ACTION_REMOVE_TRUSTLINE),
    "ACTIVITY_ACTION_SEND": (()=>ACTIVITY_ACTION_SEND),
    "ACTIVITY_ACTION_TOPUP": (()=>ACTIVITY_ACTION_TOPUP),
    "ACTIVITY_PERIOD_ALL": (()=>ACTIVITY_PERIOD_ALL),
    "ACTIVITY_PERIOD_MONTH_ONE": (()=>ACTIVITY_PERIOD_MONTH_ONE),
    "ACTIVITY_PERIOD_MONTH_SIX": (()=>ACTIVITY_PERIOD_MONTH_SIX),
    "ACTIVITY_PERIOD_WEEK_ONE": (()=>ACTIVITY_PERIOD_WEEK_ONE),
    "ACTIVITY_STATUS_CANCELLED": (()=>ACTIVITY_STATUS_CANCELLED),
    "ACTIVITY_STATUS_CANCELLING": (()=>ACTIVITY_STATUS_CANCELLING),
    "ACTIVITY_STATUS_PENDING": (()=>ACTIVITY_STATUS_PENDING),
    "ACTIVITY_STATUS_SUCCESSFUL": (()=>ACTIVITY_STATUS_SUCCESSFUL),
    "ACTIVITY_STATUS_UNSUCCESSFUL": (()=>ACTIVITY_STATUS_UNSUCCESSFUL),
    "BROADCAST_CHANNELS": (()=>BROADCAST_CHANNELS),
    "BROADCAST_CHANNELS_MSGS": (()=>BROADCAST_CHANNELS_MSGS),
    "BUTTON_POSITION": (()=>BUTTON_POSITION),
    "BaseBlockTracker": (()=>BaseBlockTracker),
    "BaseController": (()=>BaseController),
    "BaseCurrencyController": (()=>BaseCurrencyController),
    "BaseEmbedController": (()=>BaseEmbedController),
    "BaseKeyringController": (()=>BaseKeyringController),
    "BasePreferencesController": (()=>BasePreferencesController),
    "BaseTransactionStateManager": (()=>BaseTransactionStateManager),
    "BroadcastChannelHandler": (()=>BroadcastChannelHandler),
    "CHAIN_NAMESPACES": (()=>CHAIN_NAMESPACES),
    "COMMUNICATION_JRPC_METHODS": (()=>COMMUNICATION_JRPC_METHODS),
    "COMMUNICATION_NOTIFICATIONS": (()=>COMMUNICATION_NOTIFICATIONS),
    "CONFIRMATION_STRATEGY": (()=>CONFIRMATION_STRATEGY),
    "CommunicationWindowManager": (()=>CommunicationWindowManager),
    "ControllerEvents": (()=>ControllerEvents),
    "DEFAULT_PREFERENCES": (()=>DEFAULT_PREFERENCES),
    "FEATURES_CONFIRM_WINDOW": (()=>FEATURES_CONFIRM_WINDOW),
    "FEATURES_DEFAULT_POPUP_WINDOW": (()=>FEATURES_DEFAULT_POPUP_WINDOW),
    "FEATURES_DEFAULT_WALLET_WINDOW": (()=>FEATURES_DEFAULT_WALLET_WINDOW),
    "FEATURES_PROVIDER_CHANGE_WINDOW": (()=>FEATURES_PROVIDER_CHANGE_WINDOW),
    "LOGIN_PROVIDER": (()=>LOGIN_PROVIDER),
    "PAYMENT_PROVIDER": (()=>PAYMENT_PROVIDER),
    "POPUP_LOADED": (()=>POPUP_LOADED),
    "POPUP_RESULT": (()=>POPUP_RESULT),
    "PROVIDER_JRPC_METHODS": (()=>PROVIDER_JRPC_METHODS),
    "PROVIDER_NOTIFICATIONS": (()=>PROVIDER_NOTIFICATIONS),
    "PopupHandler": (()=>PopupHandler),
    "PopupStoreChannel": (()=>PopupStoreChannel),
    "PopupWithBcHandler": (()=>PopupWithBcHandler),
    "RedirectHandler": (()=>RedirectHandler),
    "SETUP_COMPLETE": (()=>SETUP_COMPLETE),
    "StreamWindow": (()=>StreamWindow),
    "TRANSACTION_TYPES": (()=>TRANSACTION_TYPES),
    "TX_EVENTS": (()=>TX_EVENTS),
    "TransactionStatus": (()=>TransactionStatus),
    "UserError": (()=>UserError),
    "WSApiClient": (()=>WSApiClient),
    "addressSlicer": (()=>addressSlicer),
    "authServer": (()=>authServer),
    "broadcastChannelOptions": (()=>broadcastChannelOptions),
    "cloneDeep": (()=>cloneDeep),
    "concatSig": (()=>concatSig),
    "createChangeProviderMiddlewareMiddleware": (()=>createChangeProviderMiddlewareMiddleware),
    "createCommunicationMiddleware": (()=>createCommunicationMiddleware),
    "createEventEmitterProxy": (()=>createEventEmitterProxy),
    "createFetchConfigFromReq": (()=>createFetchConfigFromReq),
    "createFetchMiddleware": (()=>createFetchMiddleware),
    "createGenericJRPCMiddleware": (()=>createGenericJRPCMiddleware),
    "createInflightCacheMiddleware": (()=>createInflightCacheMiddleware),
    "createLoggerMiddleware": (()=>createLoggerMiddleware),
    "createOriginMiddleware": (()=>createOriginMiddleware),
    "createRandomId": (()=>createRandomId),
    "createSwappableProxy": (()=>createSwappableProxy),
    "createTopupMiddleware": (()=>createTopupMiddleware),
    "formatDate": (()=>formatDate),
    "formatSmallNumbers": (()=>formatSmallNumbers),
    "formatTime": (()=>formatTime),
    "getCustomDeviceInfo": (()=>getCustomDeviceInfo),
    "getHeaders": (()=>getHeaders),
    "getPopupFeatures": (()=>getPopupFeatures),
    "getTxStatusText": (()=>getTxStatusText),
    "handleRedirectParameters": (()=>handleRedirectParameters),
    "hashMessage": (()=>hashMessage),
    "intToHex": (()=>intToHex),
    "isUnauthorizedError": (()=>isUnauthorizedError),
    "omitBy": (()=>omitBy),
    "padWithZeroes": (()=>padWithZeroes),
    "pickBy": (()=>pickBy),
    "randomId": (()=>randomId),
    "signChallenge": (()=>signChallenge),
    "signMessage": (()=>signMessage),
    "significantDigits": (()=>significantDigits),
    "sleep": (()=>sleep),
    "timeout": (()=>timeout$1),
    "transactionMatchesNetwork": (()=>transactionMatchesNetwork),
    "verifySignedChallenge": (()=>verifySignedChallenge)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loglevel/lib/loglevel.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethereumjs/util/dist/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethereumjs/util/dist/esm/bytes.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$internal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethereumjs/util/dist/esm/internal.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethereumjs/util/dist/esm/signature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$utils$2f$dist$2f$openloginUtils$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$utils$2f$dist$2f$openloginUtils$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bowser$2f$src$2f$bowser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bowser/src/bowser.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jwt$2d$decode$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jwt-decode/build/esm/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
/**
 * Controller class that provides configuration, state management, and subscriptions
 */ class BaseController extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SafeEventEmitter"] {
    /**
   * Creates a BaseController instance. Both initial state and initial
   * configuration options are merged with defaults upon initialization.
   *
   * @param config - Initial options used to configure this controller
   * @param state - Initial state to set on this controller
   */ constructor({ config = {}, state = {} }){
        super();
        // Use assign since generics can't be spread: https://git.io/vpRhY
        /**
     * Default options used to configure this controller
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "defaultConfig", {});
        /**
     * Default state set on this controller
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "defaultState", {});
        /**
     * Determines if listeners are notified of state changes
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "disabled", false);
        /**
     * Name of this controller used during composition
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "name", "BaseController");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "initialConfig", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "initialState", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "internalConfig", this.defaultConfig);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "internalState", this.defaultState);
        this.initialState = state;
        this.initialConfig = config;
    }
    /**
   * Retrieves current controller configuration options
   *
   * @returns - Current configuration
   */ get config() {
        return this.internalConfig;
    }
    /**
   * Retrieves current controller state
   *
   * @returns - Current state
   */ get state() {
        return this.internalState;
    }
    /**
   * Updates controller configuration
   *
   * @param config - New configuration options
   * @param overwrite - Overwrite config instead of merging
   * @param fullUpdate - Boolean that defines if the update is partial or not
   */ configure(config, overwrite = false, fullUpdate = true) {
        if (fullUpdate) {
            this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);
            for(const key in this.internalConfig){
                if (typeof this.internalConfig[key] !== "undefined") {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    this[key] = this.internalConfig[key];
                }
            }
        } else {
            for(const key in config){
                /* istanbul ignore else */ if (typeof this.internalConfig[key] !== "undefined") {
                    this.internalConfig[key] = config[key];
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    this[key] = config[key];
                }
            }
        }
    }
    /**
   * Updates controller state
   *
   * @param state - New state
   * @param overwrite - Overwrite state instead of merging
   */ update(state, overwrite = false) {
        this.internalState = overwrite ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, state) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.internalState), state);
        this.emit("store", this.internalState);
    }
    /**
   * Enables the controller. This sets each config option as a member
   * variable on this instance and triggers any defined setters. This
   * also sets initial state and triggers any listeners.
   *
   * @returns - This controller instance
   */ initialize() {
        this.internalState = this.defaultState;
        this.internalConfig = this.defaultConfig;
        this.configure(this.initialConfig);
        this.update(this.initialState);
        return this;
    }
}
const sec = 1000;
const calculateSum = (accumulator, currentValue)=>accumulator + currentValue;
const blockTrackerEvents = [
    "sync",
    "latest"
];
class BaseBlockTracker extends BaseController {
    constructor({ config = {}, state = {} }){
        super({
            config,
            state
        });
        // config
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "name", "BaseBlockTracker");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_blockResetTimeout", void 0);
        this.defaultState = {
            _currentBlock: {
                idempotencyKey: ""
            },
            _isRunning: false
        };
        this.defaultConfig = {
            blockResetDuration: 20 * sec
        };
        this.initialize();
        // bind functions for internal use
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        // listen for handler changes
        this._setupInternalEvents();
    }
    isRunning() {
        return this.state._isRunning;
    }
    getCurrentBlock() {
        return this.state._currentBlock;
    }
    async getLatestBlock() {
        // return if available
        if (this.state._currentBlock.idempotencyKey) {
            return this.state._currentBlock;
        }
        // wait for a new latest block
        const latestBlock = await new Promise((resolve)=>{
            this.once("latest", (block)=>{
                if (block) {
                    resolve(block);
                }
            });
        });
        // return newly set current block
        return latestBlock;
    }
    // dont allow module consumer to remove our internal event listeners
    removeAllListeners(eventName) {
        if (eventName) {
            super.removeAllListeners(eventName);
        } else {
            super.removeAllListeners();
        }
        // re-add internal events
        this._setupInternalEvents();
        // trigger stop check just in case
        this._onRemoveListener();
        return this;
    }
    /**
   * To be implemented in subclass.
   */ _start() {
    // default behavior is noop
    }
    /**
   * To be implemented in subclass.
   */ _end() {
    // default behavior is noop
    }
    _newPotentialLatest(newBlock) {
        const currentBlock = this.state._currentBlock;
        // only update if block number is higher
        if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {
            return;
        }
        this._setCurrentBlock(newBlock);
    }
    _setupInternalEvents() {
        // first remove listeners for idempotency
        this.removeListener("newListener", this._onNewListener);
        this.removeListener("removeListener", this._onRemoveListener);
        // then add them
        this.on("removeListener", this._onRemoveListener);
        this.on("newListener", this._onNewListener);
    }
    _onNewListener() {
        this._maybeStart();
    }
    _onRemoveListener() {
        // `removeListener` is called *after* the listener is removed
        if (this._getBlockTrackerEventCount() > 0) {
            return;
        }
        this._maybeEnd();
    }
    _maybeStart() {
        if (this.state._isRunning) {
            return;
        }
        this.state._isRunning = true;
        // cancel setting latest block to stale
        this._cancelBlockResetTimeout();
        this._start();
    }
    _maybeEnd() {
        if (!this.state._isRunning) {
            return;
        }
        this.state._isRunning = false;
        this._setupBlockResetTimeout();
        this._end();
    }
    _getBlockTrackerEventCount() {
        return blockTrackerEvents.map((eventName)=>this.listenerCount(eventName)).reduce(calculateSum);
    }
    _setCurrentBlock(newBlock) {
        const oldBlock = this.state._currentBlock;
        this.update({
            _currentBlock: newBlock
        });
        this.emit("latest", newBlock);
        this.emit("sync", {
            oldBlock,
            newBlock
        });
    }
    _setupBlockResetTimeout() {
        // clear any existing timeout
        this._cancelBlockResetTimeout();
        // clear latest block when stale
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration);
        // nodejs - dont hold process open
        if (this._blockResetTimeout.unref) {
            this._blockResetTimeout.unref();
        }
    }
    _cancelBlockResetTimeout() {
        if (this._blockResetTimeout) {
            clearTimeout(this._blockResetTimeout);
        }
    }
    _resetCurrentBlock() {
        this.update({
            _currentBlock: {
                idempotencyKey: ""
            }
        });
    }
}
const filterNoop = ()=>true;
const internalEvents = [
    "newListener",
    "removeListener"
];
const externalEventFilter = (name)=>!internalEvents.includes(name);
function getRawListeners(eventEmitter, name) {
    // prefer native
    return typeof eventEmitter.rawListeners !== "undefined" ? eventEmitter.rawListeners(name) : eventEmitter.listeners(name);
}
function createEventEmitterProxy(initialTarget, opts) {
    // parse options
    const finalOpts = opts || {};
    let eventFilter = finalOpts.eventFilter || filterNoop;
    if (typeof eventFilter === "string" && eventFilter === "skipInternal") eventFilter = externalEventFilter;
    if (typeof eventFilter !== "function") throw new Error("createEventEmitterProxy - Invalid eventFilter");
    let target = initialTarget;
    let setTarget = (newTarget)=>{
        const oldTarget = target;
        target = newTarget;
        oldTarget.eventNames().filter(eventFilter).forEach((name)=>{
            getRawListeners(oldTarget, name).forEach((handler)=>{
                newTarget.on(name, handler);
            });
        });
        // remove old listeners
        oldTarget.removeAllListeners();
    };
    const proxy = new Proxy({}, {
        get: (_, name)=>{
            // override `setTarget` access
            if (name === "setTarget") return setTarget;
            return target[name];
        },
        set: (_, name, value)=>{
            // allow `setTarget` overrides
            if (name === "setTarget") {
                setTarget = value;
                return true;
            }
            target[name] = value;
            return true;
        }
    });
    return proxy;
}
function createSwappableProxy(initialTarget) {
    let target = initialTarget;
    let setTarget = (newTarget)=>{
        target = newTarget;
    };
    const proxy = new Proxy({}, {
        get: (_, name)=>{
            // override `setTarget` access
            if (name === "setTarget") return setTarget;
            return target[name];
        },
        set: (_, name, value)=>{
            // allow `setTarget` overrides
            if (name === "setTarget") {
                setTarget = value;
                return true;
            }
            target[name] = value;
            return true;
        }
    });
    return proxy;
}
// every ten minutes
const POLLING_INTERVAL = 600000;
class BaseCurrencyController extends BaseController {
    constructor({ config = {}, state }){
        super({
            config,
            state
        });
        this.defaultState = {
            currentCurrency: "usd",
            conversionRate: 0,
            conversionDate: "N/A",
            nativeCurrency: "ETH"
        };
        this.defaultConfig = {
            pollInterval: POLLING_INTERVAL
        };
        this.initialize();
    }
    //
    // PUBLIC METHODS
    //
    getNativeCurrency() {
        return this.state.nativeCurrency;
    }
    setNativeCurrency(nativeCurrency) {
        this.update({
            nativeCurrency,
            ticker: nativeCurrency
        });
    }
    getCurrentCurrency() {
        return this.state.currentCurrency;
    }
    setCurrentCurrency(currentCurrency) {
        this.update({
            currentCurrency
        });
    }
    /**
   * A getter for the conversionRate property
   *
   * @returns The conversion rate from ETH to the selected currency.
   *
   */ getConversionRate() {
        return this.state.conversionRate;
    }
    setConversionRate(conversionRate) {
        this.update({
            conversionRate
        });
    }
    /**
   * A getter for the conversionDate property
   *
   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of
   * January 1, 1970
   *
   */ getConversionDate() {
        return this.state.conversionDate;
    }
    setConversionDate(conversionDate) {
        this.update({
            conversionDate
        });
    }
}
const FEATURES_PROVIDER_CHANGE_WINDOW = {
    height: 660,
    width: 375
};
const FEATURES_DEFAULT_WALLET_WINDOW = {
    height: 740,
    width: 1315
};
const FEATURES_DEFAULT_POPUP_WINDOW = {
    height: 700,
    width: 1200
};
const FEATURES_CONFIRM_WINDOW = {
    height: 700,
    width: 450
};
const POPUP_LOADED = "popup_loaded";
const POPUP_RESULT = "popup_result";
const SETUP_COMPLETE = "setup_complete";
const ACTIVITY_ACTION_ALL = "walletActivity.allTransactions";
const ACTIVITY_ACTION_SEND = "walletActivity.send";
const ACTIVITY_ACTION_BURN = "walletActivity.burn";
const ACTIVITY_ACTION_RECEIVE = "walletActivity.receive";
const ACTIVITY_ACTION_TOPUP = "walletActivity.topup";
const ACTIVITY_ACTION_CREATE_TRUSTLINE = "walletActivity.createTrustline";
const ACTIVITY_ACTION_REMOVE_TRUSTLINE = "walletActivity.removeTrustline";
const ACTIVITY_ACTION_CREATE_NFT_OFFER = "walletActivity.createNftOffer";
const ACTIVITY_ACTION_ACCEPT_NFT_OFFER = "walletActivity.acceptNftOffer";
const ACTIVITY_ACTION_CANCEL_NFT_OFFER = "walletActivity.cancelNftOffer";
const ACTIVITY_PERIOD_ALL = "walletActivity.all";
const ACTIVITY_PERIOD_WEEK_ONE = "walletActivity.lastOneWeek";
const ACTIVITY_PERIOD_MONTH_ONE = "walletActivity.lastOneMonth";
const ACTIVITY_PERIOD_MONTH_SIX = "walletActivity.lastSixMonts";
const ACTIVITY_STATUS_SUCCESSFUL = "walletActivity.successful";
const ACTIVITY_STATUS_UNSUCCESSFUL = "walletActivity.unsuccessful";
const ACTIVITY_STATUS_PENDING = "walletActivity.pending";
const ACTIVITY_STATUS_CANCELLED = "walletActivity.cancelled";
const ACTIVITY_STATUS_CANCELLING = "walletActivity.cancelling";
const COMMUNICATION_NOTIFICATIONS = {
    IFRAME_STATUS: "iframe_status",
    // Tell embed to close the window
    CLOSE_WINDOW: "close_window",
    USER_LOGGED_IN: "user_logged_in",
    USER_LOGGED_OUT: "user_logged_out"
};
const COMMUNICATION_JRPC_METHODS = {
    LOGOUT: "logout",
    WALLET_INSTANCE_ID: "wallet_instance_id",
    USER_INFO: "user_info",
    SET_PROVIDER: "set_provider",
    TOPUP: "topup",
    IFRAME_STATUS: "iframe_status",
    // user has closed the window from embed's side
    CLOSED_WINDOW: "closed_window",
    WINDOW_BLOCKED: "window_blocked",
    GET_PROVIDER_STATE: "get_provider_state",
    LOGIN_WITH_PRIVATE_KEY: "login_with_private_key",
    SHOW_WALLET_CONNECT: "show_wallet_connect",
    SHOW_CHECKOUT: "show_checkout",
    SHOW_WALLET_UI: "show_wallet_ui",
    LOGIN_WITH_SESSION_ID: "login_with_session_id"
};
const PROVIDER_JRPC_METHODS = {
    GET_PROVIDER_STATE: "wallet_get_provider_state"
};
const PROVIDER_NOTIFICATIONS = {
    ACCOUNTS_CHANGED: "wallet_accounts_changed",
    CHAIN_CHANGED: "wallet_chain_changed",
    UNLOCK_STATE_CHANGED: "wallet_unlock_state_changed"
};
const BROADCAST_CHANNELS = {
    REDIRECT_CHANNEL: "redirect_channel",
    PROVIDER_CHANGE_CHANNEL: "torus_provider_change_channel",
    TRANSACTION_CHANNEL: "torus_channel",
    MESSAGE_CHANNEL: "torus_message_channel",
    WALLET_LOGOUT_CHANNEL: "wallet_logout_channel",
    WALLET_SELECTED_ADDRESS_CHANNEL: "wallet_selected_address_channel",
    WALLET_NETWORK_CHANGE_CHANNEL: "wallet_network_change_channel",
    WALLET_ACCOUNT_IMPORT_CHANNEL: "wallet_account_import_channel",
    THEME_CHANGE: "theme_change_channel",
    TOP_UP_CHANNEL: "top_up_channel"
};
const BROADCAST_CHANNELS_MSGS = {
    LOGOUT: "logout",
    ACCOUNT_IMPORTED: "account_imported",
    SELECTED_ADDRESS_CHANGE: "selected_address_change",
    NETWORK_CHANGE: "network_change",
    SET_THEME: "set_theme"
};
let ControllerEvents = /*#__PURE__*/ function(ControllerEvents) {
    ControllerEvents["UserUnauthorized"] = "user.unauthorized";
    return ControllerEvents;
}({});
function createChangeProviderMiddlewareMiddleware({ changeProvider }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(async (request, response, next)=>{
        const { method } = request;
        if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();
        if (!changeProvider) throw new Error("CommunicationMiddleware - opts.changeProvider not provided");
        response.result = await changeProvider(request);
    });
}
function createTopupMiddleware({ topup }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(async (request, response, next)=>{
        const { method } = request;
        if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();
        if (!topup) throw new Error("CommunicationMiddleware - opts.topup not provided");
        response.result = await topup(request);
    });
}
function createGenericJRPCMiddleware(targetMethod, handler) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(async (request, response, next)=>{
        const { method } = request;
        if (method !== targetMethod) return next();
        if (!handler) throw new Error(`CommunicationMiddleware - ${targetMethod} not provided`);
        const result = await handler(request);
        if (!result) {
            return next();
        }
        response.result = result;
        return undefined;
    });
}
function createCommunicationMiddleware(providerHandlers) {
    const { getUserInfo, getWalletInstanceId, topup, logout, changeProvider, setIFrameStatus, handleWindowRpc, getProviderState, loginWithPrivateKey, showWalletConnect, showCheckout, showWalletUi, showWindowBlockAlert, loginWithSessionId } = providerHandlers;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeMiddleware"])([
        createChangeProviderMiddlewareMiddleware({
            changeProvider
        }),
        createTopupMiddleware({
            topup
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createScaffoldMiddleware"])({
            [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,
            [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,
            [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,
            [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,
            // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers
            [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,
            [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState,
            [COMMUNICATION_JRPC_METHODS.SHOW_WALLET_CONNECT]: showWalletConnect,
            [COMMUNICATION_JRPC_METHODS.SHOW_CHECKOUT]: showCheckout,
            [COMMUNICATION_JRPC_METHODS.SHOW_WALLET_UI]: showWalletUi,
            [COMMUNICATION_JRPC_METHODS.WINDOW_BLOCKED]: showWindowBlockAlert
        }),
        createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey),
        createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_SESSION_ID, loginWithSessionId)
    ]);
}
class BaseEmbedController extends BaseController {
    constructor({ config = {}, state }){
        super({
            config,
            state
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_communicationProviderProxy", void 0);
        this.defaultState = {
            isIFrameFullScreen: true,
            oauthModalVisibility: false,
            loginInProgress: false,
            dappMetadata: {
                name: "",
                icon: ""
            },
            web3AuthClientId: "",
            web3AuthNetwork: "mainnet",
            whiteLabel: null,
            confirmationStrategy: "popup"
        };
        this.initialize();
    }
    /**
   * Called by orchestrator once while initializing the class
   * @param handlers - JRPC handlers for provider
   * @returns - provider - Returns the providerProxy
   */ initializeProvider(handlers) {
        const engine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["JRPCEngine"]();
        const communicationMiddleware = createCommunicationMiddleware(handlers);
        engine.push(communicationMiddleware);
        const communicationProvider = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerFromEngine"])(engine);
        this.setCommunicationProvider(communicationProvider);
    }
    setCommunicationProvider(communicationProvider) {
        if (this._communicationProviderProxy) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this._communicationProviderProxy.setTarget(communicationProvider);
        } else {
            this._communicationProviderProxy = createSwappableProxy(communicationProvider);
        }
    }
}
class CommunicationWindowManager extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SafeEventEmitter"] {
    constructor(...args){
        super(...args);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "handleWindowRpc", (request, response, next, end)=>{
            const { method, params } = request;
            if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {
                const { windowId } = params;
                // I've been informed that a window has been closed
                this.emit(`${windowId}:closed`);
                response.result = true;
                end();
            } else {
                next();
            }
        });
    }
}
const BUTTON_POSITION = {
    BOTTOM_LEFT: "bottom-left",
    TOP_LEFT: "top-left",
    BOTTOM_RIGHT: "bottom-right",
    TOP_RIGHT: "top-right"
};
const CONFIRMATION_STRATEGY = {
    POPUP: "popup",
    MODAL: "modal",
    AUTO_APPROVE: "auto-approve",
    DEFAULT: "default"
};
/**
 * State change callbacks
 */ /**
 * Base controller configuration
 */ /**
 * Base state representation
 */ const LOGIN_PROVIDER = {
    GOOGLE: "google",
    FACEBOOK: "facebook",
    REDDIT: "reddit",
    DISCORD: "discord",
    TWITCH: "twitch",
    APPLE: "apple",
    LINE: "line",
    GITHUB: "github",
    KAKAO: "kakao",
    LINKEDIN: "linkedin",
    TWITTER: "twitter",
    WEIBO: "weibo",
    WECHAT: "wechat",
    EMAIL_PASSWORDLESS: "email_passwordless",
    SMS_PASSWORDLESS: "sms_passwordless"
};
/**
 * {@label loginProviderType}
 */ const PAYMENT_PROVIDER = {
    MOONPAY: "moonpay",
    WYRE: "wyre",
    RAMPNETWORK: "rampnetwork",
    XANPOOL: "xanpool",
    MERCURYO: "mercuryo",
    TRANSAK: "transak"
};
function omitBy(object, predicate) {
    // Create a new object to store the results
    const result = {};
    // Iterate over all own properties of the object
    for (const [key, value] of Object.entries(object)){
        if (!predicate(value, key)) {
            result[key] = value;
        }
    }
    return result;
}
function pickBy(object, predicate) {
    // Create a new object to store the results
    const result = {};
    for (const [key, value] of Object.entries(object)){
        if (predicate(value, key)) {
            result[key] = value;
        }
    }
    return result;
}
function cloneDeep(object) {
    try {
        return structuredClone(object);
    } catch (error) {
        return JSON.parse(JSON.stringify(object));
    }
}
const authServer = "https://authjs.web3auth.io";
const signChallenge = async (payload, chainNamespace)=>{
    const t = chainNamespace === "solana" ? "sip99" : "eip191";
    const header = {
        t
    };
    const network = chainNamespace === "solana" ? "solana" : "ethereum";
    const data = {
        payload,
        header,
        network
    };
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${authServer}/siww/get`, data);
    if (!res.success) {
        throw new Error("Failed to authenticate user, Please reach out to Web3Auth Support team");
    }
    return res.challenge;
};
const verifySignedChallenge = async (chainNamespace, signedMessage, challenge, issuer, sessionTime, clientId, web3AuthNetwork, audience, additionalMetadata)=>{
    var _window$location;
    const t = chainNamespace === "solana" ? "sip99" : "eip191";
    const sigData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
        signature: {
            s: signedMessage,
            t
        },
        message: challenge,
        issuer,
        audience: audience || (typeof window !== "undefined" ? ((_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.hostname) || "com://reactnative" : "com://reactnative"),
        timeout: sessionTime
    }, additionalMetadata || {});
    const idTokenRes = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${authServer}/siww/verify`, sigData, {
        headers: {
            client_id: clientId,
            wallet_provider: issuer,
            web3auth_network: web3AuthNetwork
        }
    });
    if (!idTokenRes.success) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error("Failed to authenticate user, ,message verification failed", idTokenRes.error);
        throw new Error("Failed to authenticate user, ,message verification failed");
    }
    return idTokenRes.token;
};
const getTxStatusText = (txStatus)=>{
    switch(txStatus){
        case "rejected":
        case "unapproved":
        case "failed":
            return ACTIVITY_STATUS_UNSUCCESSFUL;
        case "confirmed":
            return ACTIVITY_STATUS_SUCCESSFUL;
        case "submitted":
            return ACTIVITY_STATUS_PENDING;
        case "cancelled":
            return ACTIVITY_STATUS_CANCELLED;
        default:
            return "";
    }
};
/**
 * General utility functions
 */ function intToHex(i) {
    const hex = i.toString(16);
    return `0x${hex}`;
}
/**
 * Returns a random number. Don't use for cryptographic purposes.
 * @returns a random number
 */ const randomId = ()=>Math.random().toString(36).slice(2);
/**
 * Pads the front of the given hex string with zeroes until it reaches the
 * target length. If the input string is already longer than or equal to the
 * target length, it is returned unmodified.
 *
 * If the input string is "0x"-prefixed or not a hex string, an error will be
 * thrown.
 *
 * @param hexString - The hexadecimal string to pad with zeroes.
 * @param targetLength - The target length of the hexadecimal string.
 * @returns The input string front-padded with zeroes, or the original string
 * if it was already greater than or equal to to the target length.
 */ function padWithZeroes(hexString, targetLength) {
    if (hexString !== "" && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
    }
    if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
    }
    return String.prototype.padStart.call(hexString, targetLength, "0");
}
/**
 * Concatenate an extended ECDSA signature into a hex string.
 *
 * @param v - The 'v' portion of the signature.
 * @param r - The 'r' portion of the signature.
 * @param s - The 's' portion of the signature.
 * @returns The concatenated ECDSA signature.
 */ function concatSig(v, r, s) {
    const rSig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromSigned"])(r);
    const sSig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromSigned"])(s);
    const vSig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bytesToBigInt"])(v);
    const rStr = padWithZeroes(Buffer.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUnsigned"])(rSig)).toString("hex"), 64);
    const sStr = padWithZeroes(Buffer.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toUnsigned"])(sSig)).toString("hex"), 64);
    const vStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$internal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripHexPrefix"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bigIntToHex"])(vSig));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addHexPrefix"])(rStr.concat(sStr, vStr));
}
function timeout$1(duration) {
    return new Promise((resolve)=>{
        const timeoutRef = window.setTimeout(()=>{
            resolve();
            window.clearTimeout(timeoutRef);
        }, duration);
    });
}
const getHeaders = (jwt, publicAddress)=>{
    return {
        headers: {
            Authorization: `Bearer ${jwt}`,
            "Content-Type": "application/json; charset=utf-8",
            "public-address": publicAddress
        }
    };
};
/**
 * Text/number formatting utilities
 */ const formatSmallNumbers = (number, currency = "usd", noTilde = false)=>{
    const finalNumber = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].isBigNumber(number) ? number.toNumber() : number;
    if (!Number.isFinite(finalNumber)) return "";
    const value = currency.toLowerCase() === "usd" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));
    const tilde = value > 0 ? "~ " : "";
    return `${currency.toLowerCase() === "usd" || noTilde ? "" : tilde}${Number(value)} ${currency.toUpperCase()}`;
};
const addressSlicer = (address, sliceLength = 5)=>{
    if (!address) return "";
    if (address.length < 11) {
        return address;
    }
    if (typeof address !== "string") return "";
    return `${address.slice(0, sliceLength)}...${address.slice(-sliceLength)}`;
};
const significantDigits = (number, perc = false, length_ = 2)=>{
    let input = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].isBigNumber(number) ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](number) : number;
    if (input.isZero()) return input;
    if (perc) {
        input = input.times(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](100));
    }
    let depth;
    if (input.gte(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](1))) {
        depth = length_;
    } else {
        depth = length_ - 1 + Math.ceil(Math.log10(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]("1").div(input).toNumber()));
    }
    const shift = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](10).pow(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](depth));
    const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();
    return roundedNumber;
};
const formatDate = (inputDate)=>{
    const monthList = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ];
    const date = new Date(inputDate);
    const day = date.getDate();
    const month = monthList[date.getMonth()];
    const year = date.getFullYear();
    return `${day} ${month} ${year}`;
};
const formatTime = (time)=>{
    return new Date(time).toTimeString().slice(0, 8);
};
/**
 * Network utilities
 */ const transactionMatchesNetwork = (transaction, chainId)=>{
    if (typeof transaction.chainId !== "undefined") {
        return transaction.chainId === chainId;
    }
    return false;
};
/**
 * Signing utils
 */ const hashMessage = (message)=>{
    const bufferedMessage = Buffer.from(message, "utf8");
    const el = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hashPersonalMessage"])(bufferedMessage);
    return Buffer.from(el);
};
const signMessage = async (privateKey, data)=>{
    const privKey = Buffer.from(privateKey, "hex");
    const message = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$internal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripHexPrefix"])(data);
    const msgSig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ecsign"])(Buffer.from(message, "hex"), privKey);
    const rawMsgSig = concatSig(Buffer.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bigIntToBytes"])(msgSig.v)), Buffer.from(msgSig.r), Buffer.from(msgSig.s));
    return rawMsgSig;
};
/**
 * popup handler utils
 */ function getPopupFeatures({ width: w, height: h }) {
    // Fixes dual-screen position                             Most browsers      Firefox
    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
    const systemZoom = 1; // No reliable estimate
    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
    return features;
}
const broadcastChannelOptions = {
    type: "server",
    // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']
    webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)
};
function getCustomDeviceInfo() {
    var _navigator;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {
        return {
            browser: "Brave"
        };
    }
}
class UserError extends Error {
}
const handleRedirectParameters = (hash, queryParameters)=>{
    const hashParameters = {};
    const hashUrl = new URL(`${window.location.origin}/?${hash.slice(1)}`);
    hashUrl.searchParams.forEach((value, key)=>{
        hashParameters[key] = value;
    });
    let instanceParameters = {};
    let error = "";
    if (!queryParameters.windowId) {
        if (Object.keys(hashParameters).length > 0 && hashParameters.state) {
            instanceParameters = JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$utils$2f$dist$2f$openloginUtils$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeatob"])(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};
            error = hashParameters.error_description || hashParameters.error || error;
        } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {
            instanceParameters = JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$utils$2f$dist$2f$openloginUtils$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeatob"])(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};
            if (queryParameters.error) error = queryParameters.error;
        }
    }
    return {
        error,
        instanceParameters,
        hashParameters
    };
};
function sleep(ms) {
    return new Promise((resolve)=>{
        setTimeout(resolve, ms);
    });
}
const isUnauthorizedError = (error)=>{
    return error instanceof Response && error.status === 401;
};
class BaseKeyringController extends BaseController {
    constructor({ config = {}, state }){
        var _state$wallets;
        super({
            config,
            state
        });
        this.defaultState = {
            wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []
        };
        this.initialize();
    }
    // for signing auth message
    async signAuthMessage(address, message) {
        const keyring = this.state.wallets.find((x)=>x.address === address);
        if (!keyring) {
            throw new Error("key does not exist");
        }
        const hashedMessage = hashMessage(message).toString("hex");
        const rawMessageSig = await signMessage(keyring.privateKey, hashedMessage);
        return rawMessageSig;
    }
}
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    "Gateway timeout",
    "ETIMEDOUT",
    // ignore server sent html error pages
    // or truncated json responses
    "failed to parse response body",
    // ignore errors where http req failed to establish
    "Failed to fetch"
];
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch(fetchRes.status){
        case 405:
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].methodNotFound();
        case 418:
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].internal({
                message: `Request is being rate limited.`,
                data: {
                    cause: fetchRes
                }
            });
        case 503:
        case 504:
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].internal({
                message: `Gateway timeout. The request took too long to process.` + `This can happen when querying over too wide a block range.`
            });
    }
}
function timeout(duration) {
    return new Promise((resolve)=>{
        setTimeout(resolve, duration);
    });
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body
        });
    }
    // check for rpc error
    if (body.error) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].internal({
            data: body.error
        });
    }
    // return successful result
    return body.result;
}
function createFetchConfigFromReq({ req, rpcTarget, originHttpHeaderKey }) {
    const parsedUrl = new URL(rpcTarget);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: "POST",
        headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
        },
        body: serializedPayload
    };
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return {
        fetchUrl: parsedUrl.href,
        fetchParams
    };
}
function createFetchMiddleware({ rpcTarget, originHttpHeaderKey }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(async (req, res, _next)=>{
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            req,
            rpcTarget,
            originHttpHeaderKey
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for(let attempt = 0; attempt < maxAttempts; attempt++){
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const fetchBody = await fetchRes.json();
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            } catch (err) {
                const errMsg = (err.message || err).toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase)=>errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout(retryInterval);
        }
    });
}
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve)=>{
        resolve = _resolve;
    });
    return {
        resolve,
        promise
    };
}
function createInflightCacheMiddleware({ cacheIdentifierForRequest }) {
    const inflightRequests = {};
    async function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes)=>{
            // append a copy of the result and error to the response
            res.result = cloneDeep(handledRes.result);
            res.error = cloneDeep(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(()=>{
            activeRequestHandlers.forEach((handler)=>{
                try {
                    handler(res);
                } catch (err) {
                    // catch error so all requests are handled correctly
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error(err);
                }
            });
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(async (req, res, next)=>{
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = cacheIdentifierForRequest(req);
        // if not cacheable, skip
        if (!cacheId) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info("Request is not cacheable, proceeding. req = %o", req);
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info("Running %i handler(s) for request %o", activeRequestHandlers.length, req);
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info("Carrying original request forward %o", req);
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info("Running %i collected handler(s) for request %o", activeRequestHandlers.length, req);
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
}
function createLoggerMiddleware(options) {
    return function loggerMiddleware(request, response, next) {
        next((callback)=>{
            if (response.error) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].warn("Error in RPC response:\n", response);
            }
            if (request.isTorusInternal) return;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info(`RPC (${options.origin}):`, request, "->", response);
            callback();
        });
    };
}
function createOriginMiddleware(options) {
    return function originMiddleware(request, _, next) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        request.origin = options.origin;
        next();
    };
}
const createRandomId = ()=>Math.random().toString(36).substring(2);
const CHAIN_NAMESPACES = {
    EIP155: "eip155",
    SOLANA: "solana",
    CASPER: "casper",
    XRPL: "xrpl",
    OTHER: "other"
};
// eip155 for all evm chains
/**
 * Custom network properties
 * @example isEIP1559Compatible: true etc.
 */ /**
 *
 */ class BroadcastChannelHandler {
    constructor(channelPrefix, instanceId){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "bc", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "channel", void 0);
        const queryParameters = new URLSearchParams(window.location.search);
        const windowId = queryParameters.get("windowId");
        this.channel = `${channelPrefix}_${instanceId}_${windowId}`;
        this.bc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](this.channel, broadcastChannelOptions);
    }
    getMessageFromChannel() {
        return new Promise((resolve, reject)=>{
            this.bc.addEventListener("message", async (ev)=>{
                this.bc.close();
                if (ev.error) {
                    reject(ev.error);
                } else {
                    resolve(ev.data);
                }
            });
            this.bc.postMessage({
                data: {
                    type: POPUP_LOADED
                }
            });
        });
    }
}
class StreamWindow extends BaseController {
    constructor({ config, state = {} }){
        super({
            config,
            state
        });
        // if window has been closed by users
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "closed", false);
        this.initialize();
    }
    async open() {
        return new Promise((resolve, reject)=>{
            const { communicationEngine, communicationWindowManager } = this.config;
            let popupSuccess = false;
            communicationWindowManager.once(`${this.state.windowId}:closed`, ()=>{
                this.closed = true;
            });
            // Window is not open yet
            if (!this.state.windowId) {
                // since, we're opening window now, no need to tell window anything
                this.update({
                    windowId: randomId()
                });
                if (typeof this.config.handleWindowBlockAlert !== "function") reject(new Error("handleWindowBlockAlert is not a function"));
                communicationWindowManager.once(`${this.state.windowId}:iframe-opened`, ()=>{
                    // this means iframe is full screen now
                    // there might be multiple block alerts at a time. so, we don't set iframe to close after handling this here
                    this.config.handleWindowBlockAlert({
                        windowId: this.state.windowId,
                        finalUrl: this.state.url.href
                    }).then(resolve).catch(reject);
                });
                // Tell the other party to maximize the iframe
                communicationEngine.emit("notification", {
                    method: COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS,
                    params: {
                        isFullScreen: true,
                        rid: this.state.windowId
                    }
                });
            } else {
                // this is a pre-opened window. so, we need to tell it to redirect to correct url. it's currently waiting on /redirect and uses `RedirectHandler` code
                // Send this window with `windowId` the url to open via bc
                const channelName = `${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${this.config.instanceId}_${this.state.windowId}`;
                const bc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](channelName, broadcastChannelOptions);
                bc.addEventListener("message", async (ev)=>{
                    try {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info(ev, `receiving data on channel: ${bc.name}`);
                        const { error } = ev;
                        if (error) {
                            // Popup says some error. so, we say it's not really opened
                            reject(new Error(error));
                            return;
                        }
                        const { message } = ev.data;
                        if (message === POPUP_LOADED) {
                            popupSuccess = true;
                            await bc.postMessage({
                                data: {
                                    url: this.state.url.href,
                                    message: "" // No need of a msg
                                }
                            });
                            resolve(this);
                            bc.close();
                        }
                    } catch (error) {
                        reject(error);
                        bc.close();
                        // Something went wrong. so, we close that window
                        this.close();
                    }
                });
                // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something
                // we need backoff strategy
                // we need to wait for first attempt to succeed/fail until the second attempt
                // If we get 429, we need to wait for a while and then try again
                const postMsg = async ()=>{
                    // this never throws
                    const localResponse = await bc.postMessage({
                        data: {
                            message: SETUP_COMPLETE
                        }
                    });
                    return localResponse;
                };
                let currentDelay = bc.type === "server" ? 1000 : 200;
                const recursiveFn = async ()=>{
                    if (!popupSuccess && !this.closed) {
                        const localResponse = await postMsg();
                        if (bc.type === "server") {
                            const serverResponse = localResponse;
                            if (serverResponse.status >= 400) {
                                // We need to wait for a while and then try again
                                currentDelay = Math.round(currentDelay * 1.5);
                            }
                        }
                        await sleep(currentDelay);
                        await recursiveFn();
                    }
                };
                recursiveFn();
            }
        });
    }
    close() {
        const { communicationEngine } = this.config;
        communicationEngine.emit("notification", {
            method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,
            params: {
                windowId: this.state.windowId
            }
        });
    }
}
/*
Scenarios:
1. Open a normal popup window and no communication with it - Use PopupHandler
2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)

3. If window is already opened, pass in windowId to the popup handler. 
   This will establish communication with the popup window and sends it a new url to redirect to


If you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),
  StreamWindow is invoked and it writes in a channel to display a message to the user

Once user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)
*/ /**
 * Handles popup window management.
 * For broadcast channel communication, use url with `instanceId` coded into state parameter.
 * This state parameter will be passed across redirects according to OAuth spec.
 */ class PopupHandler extends BaseController {
    constructor({ config, state }){
        super({
            config,
            state
        });
        // this.id = randomId()
        // Add in dapp storage key to all popups as a hash parameter
        this.defaultConfig = {
            features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),
            target: "_blank",
            communicationEngine: null,
            communicationWindowManager: null,
            timeout: 30000,
            instanceId: "",
            handleWindowBlockAlert: null
        };
        this.defaultState = {
            windowTimer: null,
            window: null,
            iClosedWindow: false,
            windowId: "",
            url: state.url
        };
        this.initialize();
        this._setupTimer();
    }
    async open() {
        // if window is already open
        const { target, features, communicationEngine, communicationWindowManager } = this.config;
        const { windowId, url } = this.state;
        // No window has been pre-opened
        if (!windowId) {
            // try to open a window first
            let localWindow = window.open(url.href, target, features);
            let finalWindowId = "";
            if (!localWindow) {
                // if it's blocked, open StreamWindow
                const streamWindow = new StreamWindow({
                    config: {
                        communicationEngine,
                        communicationWindowManager,
                        instanceId: this.config.instanceId,
                        handleWindowBlockAlert: this.config.handleWindowBlockAlert
                    },
                    state: {
                        url
                    }
                });
                streamWindow.open();
                finalWindowId = streamWindow.state.windowId;
                localWindow = streamWindow;
            }
            this.update({
                window: localWindow,
                windowId: finalWindowId || randomId()
            });
            return;
        }
        // A window has been pre-opened with a query parameter `windowId`
        const localWindow = new StreamWindow({
            config: {
                communicationEngine,
                communicationWindowManager,
                instanceId: this.config.instanceId,
                handleWindowBlockAlert: this.config.handleWindowBlockAlert
            },
            state: {
                url,
                windowId
            }
        });
        this.update({
            window: localWindow,
            windowId: localWindow.state.windowId
        });
        await localWindow.open();
    }
    close() {
        this.update({
            iClosedWindow: true
        });
        const { window: window1 } = this.state;
        if (window1) window1.close();
    }
    _setupTimer() {
        const timer = window.setInterval(()=>{
            const { window: window1, windowTimer, iClosedWindow } = this.state;
            if (window1 && window1.closed) {
                if (windowTimer) clearInterval(windowTimer);
                setTimeout(()=>{
                    if (!iClosedWindow) {
                        this.emit("close");
                    }
                    this.update({
                        iClosedWindow: false,
                        window: null
                    });
                }, this.config.timeout);
            }
            if (window1 === null && windowTimer) clearInterval(windowTimer);
        }, 500);
        this.update({
            windowTimer: timer
        });
    }
}
// Always listening channels. Hence, no window id
class PopupStoreChannel {
    constructor({ instanceId, handleLogout, handleAccountImport, handleNetworkChange, handleSelectedAddressChange, handleThemeChange }){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "handleLogout", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "handleAccountImport", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "handleNetworkChange", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "handleThemeChange", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "handleSelectedAddressChange", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "instanceId", void 0);
        this.instanceId = instanceId;
        this.handleLogout = handleLogout;
        this.handleAccountImport = handleAccountImport;
        this.handleNetworkChange = handleNetworkChange;
        this.handleSelectedAddressChange = handleSelectedAddressChange;
        this.handleThemeChange = handleThemeChange;
    }
    setupStoreChannels() {
        this.logoutChannel();
        this.importAccountChannel();
        this.networkChangeChannel();
        this.selectedAddressChangeChannel();
        this.themeChangedChannel();
    }
    logoutChannel() {
        const logoutChannel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](`${BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);
        logoutChannel.addEventListener("message", (ev)=>{
            var _ev$data;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info("received logout message", ev);
            if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info("Logging Out");
                this.handleLogout();
            }
        });
    }
    importAccountChannel() {
        const walletAccountImportChannel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](`${BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);
        walletAccountImportChannel.addEventListener("message", (ev)=>{
            var _ev$data2;
            if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {
                var _ev$data3;
                this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);
            }
        });
    }
    networkChangeChannel() {
        const walletAccountImportChannel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](`${BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);
        walletAccountImportChannel.addEventListener("message", (ev)=>{
            var _ev$data4;
            if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {
                var _ev$data5;
                this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);
            }
        });
    }
    themeChangedChannel() {
        const walletAccountImportChannel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](`${BROADCAST_CHANNELS.THEME_CHANGE}_${this.instanceId}`, broadcastChannelOptions);
        walletAccountImportChannel.addEventListener("message", (ev)=>{
            var _ev$data6;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info({
                ev
            });
            if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {
                var _ev$data7;
                this.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);
            }
        });
    }
    selectedAddressChangeChannel() {
        const walletAccountImportChannel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](`${BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);
        walletAccountImportChannel.addEventListener("message", (ev)=>{
            var _ev$data8;
            if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {
                var _ev$data9;
                this.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);
            }
        });
    }
}
/**
 * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.
 */ class PopupWithBcHandler extends PopupHandler {
    constructor({ config, state, channelPrefix }){
        super({
            config,
            state
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "channelPrefix", void 0);
        this.channelPrefix = channelPrefix;
    }
    /**
   * Receives the data from popup window and closes the window
   * @param successExtraFn - Extra function to be called after the data is received
   * @returns The data to be received
   */ handle(successExtraFn) {
        const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;
        const bc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](channelName, broadcastChannelOptions);
        return new Promise((resolve, reject)=>{
            const closeListener = ()=>{
                bc.close();
                reject(new UserError("user closed popup"));
                this.removeListener("close", closeListener);
            };
            this.on("close", closeListener);
            bc.addEventListener("message", async (ev)=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info(ev, `receiving data on channel: ${bc.name}`);
                try {
                    const { error, data } = ev;
                    if (error) {
                        reject(new Error(error));
                        return;
                    }
                    if (successExtraFn) await successExtraFn.call(this, data);
                    resolve(data);
                } catch (error) {
                    reject(error);
                } finally{
                    bc.close();
                    this.close();
                }
            });
            this.open().then(()=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info(`opened window ${bc.name}`);
                // Opened window. yay.  let the bc events do their job
                return undefined;
            }).catch((err)=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error(err, "something went wrong while opening window");
                reject(err);
            });
        });
    }
    /**
   * Use this if we have to send large payloads which don't fit in query/hash params.
   * Waits for ack that popup window is ready to receive data.
   * Receives the data from popup window and closes the window
   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data
   * @param successExtraFn - Extra function to be called after the data is received
   * @returns The data to be received
   */ handleWithHandshake(payload, successExtraFn) {
        const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;
        const bc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](channelName, broadcastChannelOptions);
        return new Promise((resolve, reject)=>{
            const closeListener = ()=>{
                bc.close();
                reject(new UserError("user closed popup"));
                this.removeListener("close", closeListener);
            };
            this.on("close", closeListener);
            bc.addEventListener("message", async (ev)=>{
                try {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info(ev, `receiving data on channel: ${bc.name}`);
                    const { error, data } = ev;
                    if (error) {
                        reject(new Error(error));
                        return;
                    }
                    // Do handshake
                    const { type = "" } = data;
                    if (type === POPUP_LOADED) {
                        // Hack with generic to use the same type for both send and receive
                        await bc.postMessage({
                            data: payload
                        });
                    } else if (type === POPUP_RESULT) {
                        if (successExtraFn) await successExtraFn.call(this, data);
                        resolve(data);
                        // Must only close the bc after result is done
                        bc.close();
                        this.close();
                    }
                } catch (error) {
                    reject(error);
                    bc.close();
                    this.close();
                }
            });
            this.open().then(()=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info(`opened window ${bc.name}`);
                // Opened window. yay.  let the bc events do their job
                return undefined;
            }).catch((err)=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error(err, "something went wrong while opening window");
                reject(err);
            });
        });
    }
}
class RedirectHandler {
    // private hashParameters: Record<string, string>;
    constructor(instanceId){
        // private error: string;
        // this is sessionid post login
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "instanceId", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "finalQueryParams", {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "instanceParameters", void 0);
        const { hash } = window.location;
        const queryParameters = new URLSearchParams(window.location.search);
        queryParameters.forEach((value, key)=>{
            this.finalQueryParams[key] = value;
        });
        const { instanceParameters } = handleRedirectParameters(hash, this.finalQueryParams);
        // this.error = error;
        this.instanceParameters = instanceParameters;
        // this.hashParameters = hashParameters;
        this.instanceId = instanceId;
    }
    async handle() {
        return new Promise((resolve, reject)=>{
            const { finalQueryParams, instanceParameters } = this;
            let bc;
            try {
                // used for login case. there's no windowId here
                // if (!finalQueryParams.windowId) {
                //   bc = new BroadcastChannel(`${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${instanceParameters.instanceId}`, broadcastChannelOptions);
                //   bc.addEventListener("message", async (ev) => {
                //     if (ev.error) {
                //       reject(ev.error);
                //       window.close();
                //     } else {
                //       resolve();
                //       bc.close();
                //       log.info("posted", { finalQueryParams, hashParameters, instanceParameters });
                //     }
                //   });
                //   bc.postMessage({
                //     data: {
                //       instanceParams: instanceParameters,
                //       hashParams: hashParameters,
                //       queryParams: finalQueryParams,
                //     },
                //     error,
                //   });
                //   setTimeout(() => {
                //     resolve();
                //     window.location.href = window.location.origin + window.location.search + window.location.hash;
                //   }, 5000);
                // } else {
                const channelName = `${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${this.instanceId || instanceParameters.instanceId}_${finalQueryParams.windowId || instanceParameters.windowId}`;
                bc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$broadcast$2d$channel$2f$dist$2f$broadcastChannel$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BroadcastChannel"](channelName, broadcastChannelOptions);
                bc.addEventListener("message", async (ev)=>{
                    const { url, message } = ev.data;
                    if (url) {
                        resolve();
                        window.location.href = url;
                    } else if (message === SETUP_COMPLETE) {
                        await bc.postMessage({
                            data: {
                                windowId: finalQueryParams.windowId,
                                message: POPUP_LOADED
                            }
                        });
                    }
                    if (ev.error && ev.error !== "") {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error(ev.error);
                        resolve();
                        bc.close();
                    }
                });
            // }
            } catch (err) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info(err, "something went wrong");
                reject(err);
                if (bc) bc.close();
                window.close();
            }
        });
    }
}
var HTTP_METHOD = /*#__PURE__*/ function(HTTP_METHOD) {
    HTTP_METHOD[HTTP_METHOD["GET"] = 0] = "GET";
    HTTP_METHOD[HTTP_METHOD["POST"] = 1] = "POST";
    HTTP_METHOD[HTTP_METHOD["PUT"] = 2] = "PUT";
    HTTP_METHOD[HTTP_METHOD["PATCH"] = 3] = "PATCH";
    HTTP_METHOD[HTTP_METHOD["DELETE"] = 4] = "DELETE";
    return HTTP_METHOD;
}(HTTP_METHOD || {});
const constructAuthHeaders = ({ jwtToken, publicAddress })=>{
    return {
        headers: {
            Authorization: `Bearer ${jwtToken}`,
            "public-address": publicAddress
        }
    };
};
const withUnauthorizedHandler = async (fn, emitter)=>{
    try {
        const response = await fn();
        return response;
    } catch (e) {
        if (isUnauthorizedError(e)) {
            emitter.emit(ControllerEvents.UserUnauthorized);
        }
        throw e;
    }
};
const jwtTokenExpired = (jwt)=>{
    const decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jwt$2d$decode$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jwtDecode"])(jwt);
    const jwtExpiry = decoded.exp * 1000;
    const currentTime = new Date().getTime();
    return currentTime >= jwtExpiry;
};
const WSApiClient = (baseApiUrl, emitter)=>{
    const authRequest = (method, url, data, authCredentials, customOptions)=>{
        if (jwtTokenExpired(authCredentials.jwtToken)) {
            emitter.emit(ControllerEvents.UserUnauthorized);
            // eslint-disable-next-line @typescript-eslint/no-throw-literal
            throw new Response(null, {
                status: 401,
                statusText: "Unauthorized"
            });
        }
        const headers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            "Content-Type": "application/json; charset=utf-8"
        }, constructAuthHeaders(authCredentials));
        if (method === HTTP_METHOD.GET) {
            return withUnauthorizedHandler(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["get"])(url, headers, customOptions), emitter);
        }
        if (method === HTTP_METHOD.POST) {
            return withUnauthorizedHandler(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(url, data, headers, customOptions), emitter);
        }
        if (method === HTTP_METHOD.PUT) {
            return withUnauthorizedHandler(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["put"])(url, data, headers, customOptions), emitter);
        }
        if (method === HTTP_METHOD.PATCH) {
            return withUnauthorizedHandler(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["patch"])(url, data, headers, customOptions), emitter);
        }
        if (method === HTTP_METHOD.DELETE) {
            return withUnauthorizedHandler(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["remove"])(url, data, headers, customOptions), emitter);
        }
    };
    return {
        authGet: (url, authCredentials, customOptions)=>authRequest(HTTP_METHOD.GET, `${baseApiUrl}/${url}`, {}, authCredentials, customOptions),
        authPost: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.POST, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),
        authPut: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.PUT, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),
        authPatch: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.PATCH, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),
        authRemove: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.DELETE, `${baseApiUrl}/${url}`, data, authCredentials, customOptions)
    };
};
const ACTIVITY_ACTION = {
    ACTIVITY_ACTION_ALL: "walletActivity.allTransactions",
    ACTIVITY_ACTION_SEND: "walletActivity.send",
    ACTIVITY_ACTION_RECEIVE: "walletActivity.receive",
    ACTIVITY_ACTION_TOPUP: "walletActivity.topup"
};
const ACCOUNT_CATEGORY = {
    NORMAL: "normal",
    THRESHOLD: "threshold",
    IMPORTED: "imported",
    // we have private key here
    APP_SCOPED: "app_scoped",
    ACCOUNT_ABSTRACTION: "account_abstraction",
    EXTERNAL: "external",
    // like metamask, wallet connect
    MPC: "mpc",
    SFA: "sfa"
};
/**
 * Preferences controller state
 */ /**
 * @param address - address of the user
 * @param jwtToken - if jwt token already exists, it will be used instead of fetching from backend
 * @param calledFromEmbed - if called from embed
 * @param userInfo - optional user info
 * @param rehydrate - Rehydrate the preferences from the local storage
 */ // By default, poll every 3 minutes
const DEFAULT_INTERVAL = 180 * 1000;
const DEFAULT_PREFERENCES = {
    selectedCurrency: "USD",
    theme: "dark",
    locale: "en",
    accountType: ACCOUNT_CATEGORY.NORMAL,
    contacts: [],
    jwtToken: "",
    fetchedPastTx: [],
    pastTransactions: [],
    paymentTx: [],
    defaultPublicAddress: "",
    customTokens: [],
    customNfts: [],
    crashReport: true,
    userInfo: {
        aggregateVerifier: "",
        email: "",
        name: "",
        profileImage: "",
        typeOfLogin: LOGIN_PROVIDER.GOOGLE,
        verifier: "",
        verifierId: ""
    }
};
/**
 * Controller that stores shared settings and exposes convenience methods
 */ class BasePreferencesController extends BaseController {
    /**
   * Creates a PreferencesController instance
   *
   * @param config - Initial options used to configure this controller
   * @param state - Initial state to set on this controller
   */ constructor({ config, state, defaultPreferences, signAuthMessage, validateSignMessage }){
        super({
            config,
            state
        });
        /**
     * Name of this controller used during composition
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "name", "PreferencesController");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "iframeOrigin", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "wsApiClient", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "signAuthMessage", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "validateSignMessage", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "defaultPreferences", void 0);
        if (!config.api) {
            throw new Error("PreferencesController - no api specified in config.");
        }
        this.defaultState = {
            identities: {},
            selectedAddress: "",
            lastErrorMessage: "",
            lastSuccessMessage: ""
        };
        this.defaultConfig = {
            api: config.api,
            pollInterval: DEFAULT_INTERVAL
        };
        this.initialize();
        this.defaultPreferences = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, DEFAULT_PREFERENCES), defaultPreferences);
        this.signAuthMessage = signAuthMessage;
        this.validateSignMessage = validateSignMessage;
        this.wsApiClient = WSApiClient(this.config.api, this);
    }
    setIframeOrigin(origin) {
        this.iframeOrigin = origin;
    }
    getAddressState(address) {
        const selectedAddress = address || this.state.selectedAddress;
        return this.state.identities[selectedAddress];
    }
    /**
   * Sets selected address
   *
   * @param selectedAddress - casper account hash
   */ setSelectedAddress(selectedAddress) {
        this.update({
            selectedAddress
        });
    }
    async getUser(address) {
        const user = await this.wsApiClient.authGet("user?fetchTx=false", this.authCredentials(address), {
            useAPIKey: true
        });
        return user.data;
    }
    async createUser(params) {
        const { selectedCurrency, theme, verifier, verifierId, locale, address, idToken, type, web3AuthNetwork } = params;
        const userPayload = {
            default_currency: selectedCurrency,
            theme,
            verifier,
            verifier_id: verifierId,
            locale,
            idToken,
            account_type: type,
            web3auth_network: web3AuthNetwork
        };
        await this.wsApiClient.authPost("user", userPayload, this.authCredentials(address), {
            useAPIKey: true
        });
        this.updateState({
            theme,
            defaultPublicAddress: address,
            selectedCurrency,
            locale,
            accountType: type
        }, address);
    }
    async storeUserLogin(params) {
        const { verifierId, verifier, options, address, idToken, web3AuthClientId, web3AuthNetwork, sessionPubKey, loginMode } = params;
        if (!options.rehydrate) {
            const browser = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bowser$2f$src$2f$bowser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getParser(window.navigator.userAgent);
            const specialBrowser = getCustomDeviceInfo();
            const recordLoginPayload = {
                os: browser.getOSName(),
                os_version: browser.getOSVersion() || "unidentified",
                browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || "unidentified",
                browser_version: browser.getBrowserVersion() || "unidentified",
                platform: browser.getPlatform().type || "desktop",
                hostname: this.iframeOrigin,
                verifier,
                verifier_id: verifierId,
                idToken,
                web3auth_client_id: web3AuthClientId,
                web3auth_network: web3AuthNetwork,
                session_pub_key: sessionPubKey,
                login_mode: loginMode
            };
            await this.wsApiClient.authPost("user/recordLogin", recordLoginPayload, this.authCredentials(address), {
                useAPIKey: true
            });
        }
    }
    async setCrashReport(isEnabled) {
        var _this$getAddressState;
        if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;
        try {
            await this.wsApiClient.authPatch("user", {
                enable_crash_reporter: isEnabled
            }, this.authCredentials(), {
                useAPIKey: true
            });
            this.updateState({
                crashReport: isEnabled
            });
            return true;
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error(error);
            return false;
        }
    }
    async setUserTheme(theme) {
        var _this$getAddressState2;
        if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;
        try {
            await this.wsApiClient.authPatch("user", {
                theme
            }, this.authCredentials(), {
                useAPIKey: true
            });
            this.updateState({
                theme
            });
            return true;
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error(error);
            return false;
        }
    }
    async setUserLocale(locale) {
        var _this$getAddressState3;
        if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;
        try {
            await this.wsApiClient.authPatch("user", {
                locale
            }, this.authCredentials(), {
                useAPIKey: true
            });
            this.updateState({
                locale
            });
            return true;
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error("unable to set locale", error);
            return false;
        }
    }
    async setSelectedCurrency(payload) {
        var _this$getAddressState4;
        if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;
        try {
            await this.wsApiClient.authPatch("user", {
                default_currency: payload.selectedCurrency
            }, this.authCredentials(), {
                useAPIKey: true
            });
            this.updateState({
                selectedCurrency: payload.selectedCurrency
            });
            return true;
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error(error);
            return false;
        }
    }
    async addContact(contact) {
        try {
            var _this$getAddressState5;
            const response = await this.wsApiClient.authPost("contact", contact, this.authCredentials(), {
                useAPIKey: true
            });
            this.updateState({
                contacts: [
                    ...((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || [],
                    response.data
                ]
            });
            return true;
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error("unable to add contact", error);
            return false;
        }
    }
    async deleteContact(contactId) {
        try {
            var _this$getAddressState6;
            const response = await this.wsApiClient.authRemove(`contact/${contactId}`, {}, this.authCredentials(), {
                useAPIKey: true
            });
            const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter((contact)=>contact.id !== response.data.id);
            if (finalContacts) this.updateState({
                contacts: [
                    ...finalContacts
                ]
            });
            return true;
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error("unable to delete contact", error);
            return false;
        }
    }
    async revokeDiscord(idToken) {
        try {
            const resp = await this.wsApiClient.authPost("revoke/discord", {
                token: idToken
            }, this.authCredentials(), {
                useAPIKey: true
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info(resp);
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error(error);
        }
    }
    async patchPastTx(body, address) {
        try {
            const response = await this.wsApiClient.authPatch("transaction", body, this.authCredentials(address), {
                useAPIKey: true
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info("successfully patched", response);
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error("unable to patch tx", error);
        }
    }
    async postPastTx(tx, address) {
        try {
            const response = await this.wsApiClient.authPost("transaction", tx, this.authCredentials(address), {
                useAPIKey: true
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].info("successfully posted tx", response);
            return response;
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error(error, "unable to insert transaction");
        }
    }
    async getWalletOrders(address) {
        try {
            const response = await this.wsApiClient.authGet("transaction", this.authCredentials(address), {
                useAPIKey: true
            });
            return response.success ? response.data ? response.data : [] : [];
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error("unable to get wallet orders tx", error);
            return [];
        }
    }
    async getTopUpOrders(address) {
        try {
            const response = await this.wsApiClient.authGet("transaction", this.authCredentials(address), {
                useAPIKey: true
            });
            return response.data || [];
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error("unable to fetch past Top up orders", error);
        }
    }
    async getBillBoardData() {
        try {
            const response = await this.wsApiClient.authGet("billboard", this.authCredentials(), {
                useAPIKey: true
            });
            return response.success ? response.data : [];
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error("unable to get billboard data", error);
            return [];
        }
    }
    async getMessageForSigning(publicAddress, web3AuthIdToken) {
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${this.config.api}/auth/message`, {
            public_address: publicAddress,
            id_token: web3AuthIdToken
        }, {}, {
            useAPIKey: true
        });
        return response.message;
    }
    async getTwitterId(payload) {
        const res = await this.wsApiClient.authGet(`twitter?screen_name=${payload.nick}`, this.authCredentials(), {
            useAPIKey: true
        });
        return `${payload.typeOfLogin.toLowerCase()}|${res.data.toString()}`;
    }
    async sendEmail(payload) {
        return this.wsApiClient.authPost("transaction/sendemail", payload.emailObject, this.authCredentials(), {
            useAPIKey: true
        });
    }
    async refreshJwt() {
        const address = this.state.selectedAddress;
        const messageToSign = await this.getMessageForSigning(address);
        await this.validateSignMessage(messageToSign);
        const signedMessage = await this.signAuthMessage(address, messageToSign);
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${this.config.api}/auth/verify`, {
            challenge: messageToSign,
            public_address: address,
            signed_message: signedMessage
        }, {}, {
            useAPIKey: true
        });
        this.updateState({
            jwtToken: response.token
        }, address);
    }
    async getDappList() {
        try {
            const response = await this.wsApiClient.authGet("dapps", this.authCredentials(), {
                useAPIKey: true
            });
            return response.success ? response.data : [];
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].error("unable to get dapps list", error);
            return [];
        }
    }
    /**
   * Strategy
   * For account type: threshold, normal (web3auth login)
   * idToken from web3auth login must be present. We use it directly
   *
   * For account type: app_scoped, IMPORTED
   * idToken from web3auth login must be present. We request a message for signing using the idToken
   * and sign it using the private key of the account. We then send the signed message to the backend
   * to verify the signature and return a new jwtToken that includes the app_scoped address
   *
   * For account type: Account abstraction
   * idToken from web3auth login must be present. We use it to exchange for a new jwtToken.
   * Because backend can derive AA address from public address and issue this token easily.
   *
   * For account type: external
   * idToken from web3auth `authenticateUser` (siww) login must be present. We use it directly
   */ async init(params) {
        const { address, userInfo, idToken, metadata = {}, type } = params;
        if (this.getAddressState(address)) return;
        let jwtToken;
        switch(type){
            case ACCOUNT_CATEGORY.IMPORTED:
                {
                    if (!idToken) throw new Error("Web3Auth idToken must be present");
                    const messageToSign = await this.getMessageForSigning(address, idToken);
                    await this.validateSignMessage(messageToSign);
                    const signedMessage = await this.signAuthMessage(address, messageToSign);
                    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${this.config.api}/auth/verify`, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
                        challenge: messageToSign,
                        account_type: type,
                        public_address: address,
                        signed_message: signedMessage,
                        verifier: userInfo.aggregateVerifier || userInfo.verifier,
                        verifier_id: userInfo.verifierId
                    }, metadata), {}, {
                        useAPIKey: true
                    });
                    jwtToken = response.token;
                    break;
                }
            case ACCOUNT_CATEGORY.EXTERNAL:
                {
                    if (!idToken) throw new Error("SIWW idToken must be present");
                    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${this.config.api}/auth/verify`, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
                        account_type: type,
                        public_address: address,
                        id_token: idToken,
                        verifier: userInfo.aggregateVerifier || userInfo.verifier,
                        verifier_id: userInfo.verifierId
                    }, metadata), {}, {
                        useAPIKey: true
                    });
                    jwtToken = response.token;
                    break;
                }
            case ACCOUNT_CATEGORY.ACCOUNT_ABSTRACTION:
                {
                    if (!idToken) throw new Error("Web3Auth idToken must be present");
                    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${this.config.api}/auth/verify`, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
                        public_address: address,
                        id_token: idToken,
                        verifier: userInfo.aggregateVerifier || userInfo.verifier,
                        verifier_id: userInfo.verifierId,
                        account_type: type
                    }, metadata), {}, {
                        useAPIKey: true
                    });
                    jwtToken = response.token;
                    break;
                }
            case ACCOUNT_CATEGORY.MPC:
            case ACCOUNT_CATEGORY.SFA:
                {
                    if (!metadata.signatures) throw new Error("MPC signatures must be present");
                    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["post"])(`${this.config.api}/auth/verify`, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
                        public_address: address,
                        verifier: userInfo.aggregateVerifier || userInfo.verifier,
                        verifier_id: userInfo.verifierId,
                        account_type: type
                    }, metadata), {}, {
                        useAPIKey: true
                    });
                    jwtToken = response.token;
                    break;
                }
            case ACCOUNT_CATEGORY.NORMAL:
            case ACCOUNT_CATEGORY.THRESHOLD:
            case ACCOUNT_CATEGORY.APP_SCOPED:
            default:
                if (!idToken) throw new Error("Web3Auth idToken must be present");
                jwtToken = idToken;
                break;
        }
        this.updateState({
            jwtToken,
            userInfo,
            accountType: type !== null && type !== void 0 ? type : this.defaultPreferences.accountType
        }, address);
    }
    updateState(preferences, address) {
        const selectedAddress = address || this.state.selectedAddress;
        const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);
        const mergedState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, currentState), preferences);
        this.update({
            identities: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.state.identities), {}, {
                [selectedAddress]: mergedState
            })
        });
        return mergedState;
    }
    authCredentials(address) {
        var _this$getAddressState7;
        const selectedAddress = address || this.state.selectedAddress;
        const jwtToken = ((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || "";
        return {
            jwtToken,
            publicAddress: selectedAddress
        };
    }
    headers(address) {
        var _this$getAddressState8;
        const selectedAddress = address || this.state.selectedAddress;
        return getHeaders(((_this$getAddressState8 = this.getAddressState(selectedAddress)) === null || _this$getAddressState8 === void 0 ? void 0 : _this$getAddressState8.jwtToken) || "", selectedAddress);
    }
}
/**
 * The status of the transaction. Each status represents the state of the transaction internally
 * in the wallet. Some of these correspond with the state of the transaction on the network, but
 * some are wallet-specific.
 */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {
    TransactionStatus["approved"] = "approved";
    TransactionStatus["cancelled"] = "cancelled";
    TransactionStatus["cancelling"] = "cancelling";
    TransactionStatus["confirmed"] = "confirmed";
    TransactionStatus["failed"] = "failed";
    TransactionStatus["finalized"] = "finalized";
    TransactionStatus["processed"] = "processed";
    TransactionStatus["rejected"] = "rejected";
    TransactionStatus["signed"] = "signed";
    TransactionStatus["submitted"] = "submitted";
    TransactionStatus["unapproved"] = "unapproved";
    TransactionStatus["dropped"] = "dropped";
    TransactionStatus["expired"] = "expired";
    TransactionStatus["pending"] = "pending";
    return TransactionStatus;
}({});
const TRANSACTION_TYPES = {
    CANCEL: "cancel",
    RETRY: "retry",
    CONTRACT_INTERACTION: "contractInteraction",
    DEPLOY_CONTRACT: "contractDeployment",
    WASM_BASED_DEPLOY: "wasmBasedDeploy",
    STANDARD_TRANSACTION: "transaction",
    STANDARD_PAYMENT_TRANSACTION: "payment_transaction",
    // specific to chains like solana and casper
    SENT_ETHER: "sentEther",
    TOKEN_METHOD_TRANSFER: "transfer",
    TOKEN_METHOD_TRANSFER_FROM: "transferFrom",
    TOKEN_METHOD_APPROVE: "approve",
    COLLECTIBLE_METHOD_SAFE_TRANSFER_FROM: "safeTransferFrom",
    SET_APPROVAL_FOR_ALL: "setApprovalForAll"
};
const TX_EVENTS = {
    TX_WARNING: "tx:warning",
    TX_ERROR: "tx:error",
    TX_FAILED: "tx:failed",
    TX_CONFIRMED: "tx:confirmed",
    TX_DROPPED: "tx:dropped",
    TX_EXPIRED: "tx:expired",
    TX_STATUS_UPDATE: "tx:status_update",
    TX_UNAPPROVED: "tx:unapproved",
    TX_RETRY: "tx:retry",
    TX_BLOCK_UPDATE: "tx:block_update"
};
/**
 * Transaction controller configuration
 */ /**
 * Transaction controller state
 */ /**
 * Result
 *
 * result - Promise resolving to a new transaction hash
 * transactionMeta - Meta information about this new transaction
 */ class BaseTransactionStateManager extends BaseController {
    constructor({ config, state, getCurrentChainId }){
        super({
            config,
            state
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "getCurrentChainId", void 0);
        this.defaultConfig = {
            txHistoryLimit: 40
        };
        this.defaultState = {
            transactions: {},
            unapprovedTxs: {},
            currentNetworkTxsList: []
        };
        this.initialize();
        this.getCurrentChainId = getCurrentChainId;
    }
    getUnapprovedTxList() {
        const chainId = this.getCurrentChainId();
        return pickBy(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));
    }
    getTransaction(txId) {
        const { transactions } = this.state;
        return transactions[txId];
    }
    updateTransaction(txMeta) {
        // commit txMeta to state
        const txId = txMeta.id;
        txMeta.updated_at = new Date().toISOString();
        this.update({
            transactions: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.state.transactions), {}, {
                [txId]: txMeta
            })
        });
    }
    setTxStatusRejected(txId) {
        this._setTransactionStatus(txId, TransactionStatus.rejected);
        this._deleteTransaction(txId);
    }
    /**
   * The implementing controller can override this functionality and add custom logic + call super.()
   */ setTxStatusUnapproved(txId) {
        this._setTransactionStatus(txId, TransactionStatus.unapproved);
    }
    setTxStatusApproved(txId) {
        this._setTransactionStatus(txId, TransactionStatus.approved);
    }
    setTxStatusSigned(txId, isFinalStep) {
        this._setTransactionStatus(txId, TransactionStatus.signed, isFinalStep);
    }
    setTxStatusSubmitted(txId) {
        this._setTransactionStatus(txId, TransactionStatus.submitted);
    }
    setTxStatusDropped(txId) {
        this._setTransactionStatus(txId, TransactionStatus.dropped);
    }
    setTxStatusExpired(txId) {
        this._setTransactionStatus(txId, TransactionStatus.expired);
    }
    setTxStatusConfirmed(txId) {
        this._setTransactionStatus(txId, TransactionStatus.confirmed);
    }
    setTxStatusFailed(txId, error_) {
        const error = !error_ ? new Error("Internal torus failure") : error_;
        const txMeta = this.getTransaction(txId);
        txMeta.error = error;
        this.updateTransaction(txMeta);
        this._setTransactionStatus(txId, TransactionStatus.failed);
    }
    /**
   * Method to determine if the transaction is in a final state
   * @param status - Transaction status
   * @returns boolean if the transaction is in a final state
   */ isFinalState(status) {
        return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;
    }
    /**
   * Filters out the unapproved transactions from state
   */ clearUnapprovedTxs() {
        this.update({
            transactions: omitBy(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved)
        });
    }
    /**
   * will append new transactions to old txns.
   */ _addTransactionsToState(transactions) {
        this.update({
            transactions: transactions.reduce((result, newTx)=>{
                result[newTx.id] = newTx;
                return result;
            }, this.state.transactions)
        });
    }
    /**
   * will set new txns, override existing if any in state.
   */ _setTransactionsToState(transactions) {
        this.update({
            transactions: transactions.reduce((result, newTx)=>{
                result[newTx.id] = newTx;
                return result;
            }, {})
        });
    }
    _deleteTransaction(targetTransactionId) {
        const { transactions } = this.state;
        delete transactions[targetTransactionId];
        this.update({
            transactions
        });
    }
    _deleteTransactions(targetTransactionIds) {
        const { transactions } = this.state;
        targetTransactionIds.forEach((transactionId)=>{
            delete transactions[transactionId];
        });
        this.update({
            transactions
        });
    }
    _setTransactionStatus(txId, status, isFinalStep) {
        const txMeta = this.getTransaction(txId);
        if (!txMeta) {
            return;
        }
        txMeta.status = status;
        // only updating status so no validation required on txn.
        this.updateTransaction(txMeta);
        this.emit(TX_EVENTS.TX_STATUS_UPDATE, {
            txId,
            status
        });
        if (this.isFinalState(status) || isFinalStep) {
            this.emit(`${txMeta.id}:finished`, txMeta);
        } else {
            this.emit(`${txMeta.id}:${status}`, txId);
        }
    }
}
;
}}),
"[project]/node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BUTTON_POSITION": (()=>BUTTON_POSITION),
    "LOGIN_PROVIDER": (()=>LOGIN_PROVIDER),
    "PAYMENT_PROVIDER": (()=>PAYMENT_PROVIDER),
    "TORUS_BUILD_ENV": (()=>TORUS_BUILD_ENV),
    "TorusInPageProvider": (()=>TorusInPageProvider),
    "default": (()=>Torus)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/web3.js/lib/index.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eth$2d$rpc$2d$errors$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/eth-rpc-errors/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pump$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pump/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loglevel/lib/loglevel.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-deep-equal/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
var version = "2.1.0";
/* eslint-disable @typescript-eslint/no-explicit-any */ function isStream(stream) {
    return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isWritableStream(stream) {
    return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
function isReadableStream(stream) {
    return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
function isDuplexStream(stream) {
    return isWritableStream(stream) && isReadableStream(stream);
}
var messages = {
    errors: {
        disconnected: ()=>"Torus: Lost connection to Torus.",
        permanentlyDisconnected: ()=>"Torus: Disconnected from iframe. Page reload required.",
        unsupportedSync: (method)=>`Torus: The Torus Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,
        invalidDuplexStream: ()=>"Must provide a Node.js-style duplex stream.",
        invalidOptions: (maxEventListeners)=>`Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,
        invalidRequestArgs: ()=>`Expected a single, non-array, object argument.`,
        invalidRequestMethod: ()=>`'args.method' must be a non-empty string.`,
        invalidRequestParams: ()=>`'args.params' must be an object or array if provided.`,
        invalidLoggerObject: ()=>`'args.logger' must be an object if provided.`,
        invalidLoggerMethod: (method)=>`'args.logger' must include required method '${method}'.`
    },
    info: {
        connected: (chainId)=>`Torus: Connected to chain with ID "${chainId}".`
    },
    warnings: {}
};
const PAYMENT_PROVIDER = {
    MOONPAY: "moonpay",
    WYRE: "wyre",
    RAMPNETWORK: "rampnetwork",
    XANPOOL: "xanpool",
    MERCURYO: "mercuryo",
    TRANSAK: "transak"
};
const TORUS_BUILD_ENV = {
    PRODUCTION: "production",
    DEVELOPMENT: "development",
    TESTING: "testing"
};
const BUTTON_POSITION = {
    BOTTOM_LEFT: "bottom-left",
    TOP_LEFT: "top-left",
    BOTTOM_RIGHT: "bottom-right",
    TOP_RIGHT: "top-right"
};
const LOGIN_PROVIDER = {
    GOOGLE: "google",
    FACEBOOK: "facebook",
    REDDIT: "reddit",
    DISCORD: "discord",
    TWITCH: "twitch",
    APPLE: "apple",
    LINE: "line",
    GITHUB: "github",
    KAKAO: "kakao",
    LINKEDIN: "linkedin",
    TWITTER: "twitter",
    WEIBO: "weibo",
    WECHAT: "wechat",
    EMAIL_PASSWORDLESS: "email_passwordless"
};
const translations = {
    en: {
        embed: {
            continue: "Continue",
            actionRequired: "Authorization required",
            pendingAction: "Click continue to proceed with your request in a popup",
            cookiesRequired: "Cookies Required",
            enableCookies: "Please enable cookies in your browser preferences to access Torus",
            clickHere: "More Info"
        }
    },
    de: {
        embed: {
            continue: "Fortsetzen",
            actionRequired: "Autorisierung erforderlich",
            pendingAction: "Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren",
            cookiesRequired: "Cookies bentigt",
            enableCookies: "Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen",
            clickHere: "Mehr Info"
        }
    },
    ja: {
        embed: {
            continue: "",
            actionRequired: "",
            pendingAction: "",
            cookiesRequired: "",
            enableCookies: "TorusCookie",
            clickHere: ""
        }
    },
    ko: {
        embed: {
            continue: "",
            actionRequired: " ",
            pendingAction: "    .",
            cookiesRequired: " ",
            enableCookies: "     Torus .",
            clickHere: "  "
        }
    },
    zh: {
        embed: {
            continue: "",
            actionRequired: "",
            pendingAction: "",
            cookiesRequired: "Cookie",
            enableCookies: "cookieTorus",
            clickHere: ""
        }
    }
};
var configuration = {
    supportedVerifierList: [
        LOGIN_PROVIDER.GOOGLE,
        LOGIN_PROVIDER.REDDIT,
        LOGIN_PROVIDER.DISCORD
    ],
    api: "https://api.tor.us",
    translations,
    prodTorusUrl: "",
    localStorageKeyPrefix: `torus-`
};
var log = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loglevel$2f$lib$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].getLogger("solana-embed");
// utility functions
/**
 * json-rpc-engine middleware that logs RPC errors and and validates req.method.
 *
 * @param log - The logging API to use.
 * @returns  json-rpc-engine middleware function
 */ function createErrorMiddleware() {
    return (req, res, next)=>{
        // json-rpc-engine will terminate the request when it notices this error
        if (typeof req.method !== "string" || !req.method) {
            res.error = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eth$2d$rpc$2d$errors$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ethErrors"].rpc.invalidRequest({
                message: `The request 'method' must be a non-empty string.`,
                data: req
            });
        }
        next((done)=>{
            const { error } = res;
            if (!error) {
                return done();
            }
            log.error(`Torus - RPC Error: ${error.message}`, error);
            return done();
        });
    };
}
/**
 * Logs a stream disconnection error. Emits an 'error' if given an
 * EventEmitter that has listeners for the 'error' event.
 *
 * @param log - The logging API to use.
 * @param remoteLabel - The label of the disconnected stream.
 * @param error - The associated error to log.
 * @param emitter - The logging API to use.
 */ function logStreamDisconnectWarning(remoteLabel, error, emitter) {
    let warningMsg = `Torus: Lost connection to "${remoteLabel}".`;
    if (error?.stack) {
        warningMsg += `\n${error.stack}`;
    }
    log.warn(warningMsg);
    if (emitter && emitter.listenerCount("error") > 0) {
        emitter.emit("error", warningMsg);
    }
}
const getWindowId = ()=>Math.random().toString(36).slice(2);
const getTorusUrl = async (buildEnv)=>{
    let torusUrl;
    let logLevel;
    // const versionUsed = version;
    // log.info("solana embed version used: ", versionUsed);
    switch(buildEnv){
        case "testing":
            torusUrl = "https://solana-testing.tor.us";
            logLevel = "debug";
            break;
        case "development":
            torusUrl = "http://localhost:8080";
            logLevel = "debug";
            break;
        default:
            torusUrl = `https://solana.tor.us`;
            logLevel = "error";
            break;
    }
    return {
        torusUrl,
        logLevel
    };
};
const getUserLanguage = ()=>{
    let userLanguage = window.navigator.language || "en-US";
    const userLanguages = userLanguage.split("-");
    userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : "en";
    return userLanguage;
};
const FEATURES_PROVIDER_CHANGE_WINDOW = {
    height: 660,
    width: 375
};
const FEATURES_DEFAULT_WALLET_WINDOW = {
    height: 740,
    width: 1315
};
const FEATURES_DEFAULT_POPUP_WINDOW = {
    height: 700,
    width: 1200
};
const FEATURES_CONFIRM_WINDOW = {
    height: 600,
    width: 400
};
function storageAvailable(type) {
    let storage;
    try {
        storage = window[type];
        const x = "__storage_test__";
        storage.setItem(x, x);
        storage.removeItem(x);
        return true;
    } catch (error) {
        const e = error;
        return e && (// everything except Firefox
        e.code === 22 || // Firefox
        e.code === 1014 || // test name field too, because code might not be present
        // everything except Firefox
        e.name === "QuotaExceededError" || // Firefox
        e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
        storage && storage.length !== 0;
    }
}
/**
 * popup handler utils
 */ function getPopupFeatures(_ref) {
    let { width: w, height: h } = _ref;
    // Fixes dual-screen position                             Most browsers      Firefox
    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
    const systemZoom = 1; // No reliable estimate
    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
    return features;
}
class BaseProvider extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SafeEventEmitter"] {
    constructor(connectionStream, _ref){
        let { maxEventListeners = 100, jsonRpcStreamName = "provider" } = _ref;
        super();
        /**
     * Indicating that this provider is a Torus provider.
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "isTorus", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_rpcEngine", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "jsonRpcConnectionEvents", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_state", void 0);
        if (!isDuplexStream(connectionStream)) {
            throw new Error(messages.errors.invalidDuplexStream());
        }
        this.isTorus = true;
        this.setMaxListeners(maxEventListeners);
        this._handleConnect = this._handleConnect.bind(this);
        this._handleDisconnect = this._handleDisconnect.bind(this);
        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
        this._rpcRequest = this._rpcRequest.bind(this);
        this._initializeState = this._initializeState.bind(this);
        this.request = this.request.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        // this.enable = this.enable.bind(this);
        // setup connectionStream multiplexing
        const mux = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObjectMultiplex"]();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pump$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, "Torus"));
        // ignore phishing warning message (handled elsewhere)
        mux.ignoreStream("phishing");
        // setup own event listeners
        // connect to async provider
        const jsonRpcConnection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createStreamMiddleware"])();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pump$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "Torus RpcProvider"));
        // handle RPC requests via dapp-side rpc engine
        const rpcEngine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["JRPCEngine"]();
        rpcEngine.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createIdRemapMiddleware"])());
        rpcEngine.push(createErrorMiddleware());
        rpcEngine.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createLoggerMiddleware"])({
            origin: location.origin
        }));
        rpcEngine.push(jsonRpcConnection.middleware);
        this._rpcEngine = rpcEngine;
        this.jsonRpcConnectionEvents = jsonRpcConnection.events;
    }
    /**
   * Submits an RPC request for the given method, with the given params.
   * Resolves with the result of the method call, or rejects on error.
   */ async request(args) {
        if (!args || typeof args !== "object" || Array.isArray(args)) {
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eth$2d$rpc$2d$errors$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ethErrors"].rpc.invalidRequest({
                message: messages.errors.invalidRequestArgs(),
                data: args
            });
        }
        const { method, params } = args;
        if (typeof method !== "string" || method.length === 0) {
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eth$2d$rpc$2d$errors$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ethErrors"].rpc.invalidRequest({
                message: messages.errors.invalidRequestMethod(),
                data: args
            });
        }
        if (params !== undefined && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eth$2d$rpc$2d$errors$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ethErrors"].rpc.invalidRequest({
                message: messages.errors.invalidRequestParams(),
                data: args
            });
        }
        return new Promise((resolve, reject)=>{
            this._rpcRequest({
                method,
                params
            }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRpcPromiseCallback"])(resolve, reject));
        });
    }
    /**
   * Submits an RPC request per the given JSON-RPC request object.
   */ send(payload, callback) {
        this._rpcRequest(payload, callback);
    }
    /**
   * Submits an RPC request per the given JSON-RPC request object.
   */ sendAsync(payload) {
        return new Promise((resolve, reject)=>{
            this._rpcRequest(payload, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRpcPromiseCallback"])(resolve, reject));
        });
    }
    /**
   * Called when connection is lost to critical streams.
   *
   * emits TorusInpageProvider#disconnect
   */ _handleStreamDisconnect(streamName, error) {
        logStreamDisconnectWarning(streamName, error, this);
        this._handleDisconnect(false, error ? error.message : undefined);
    }
}
const htmlToElement = (html)=>{
    const template = window.document.createElement("template");
    const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result
    template.innerHTML = trimmedHtml;
    return template.content.firstChild;
};
function isLegacyTransactionInstance(transaction) {
    return transaction.version === undefined;
}
class PopupHandler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SafeEventEmitter"] {
    constructor(_ref){
        let { url, target, features, timeout = 30000 } = _ref;
        super();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "url", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "target", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "features", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "window", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "windowTimer", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "iClosedWindow", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "timeout", void 0);
        this.url = url;
        this.target = target || "_blank";
        this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);
        this.window = undefined;
        this.windowTimer = undefined;
        this.iClosedWindow = false;
        this.timeout = timeout;
        this._setupTimer();
    }
    _setupTimer() {
        this.windowTimer = Number(setInterval(()=>{
            if (this.window && this.window.closed) {
                clearInterval(this.windowTimer);
                setTimeout(()=>{
                    if (!this.iClosedWindow) {
                        this.emit("close");
                    }
                    this.iClosedWindow = false;
                    this.window = undefined;
                }, this.timeout);
            }
            if (this.window === undefined) clearInterval(this.windowTimer);
        }, 500));
    }
    open() {
        this.window = window.open(this.url.href, this.target, this.features);
        if (this.window?.focus) this.window.focus();
        return Promise.resolve();
    }
    close() {
        this.iClosedWindow = true;
        if (this.window) this.window.close();
    }
    redirect(locationReplaceOnRedirect) {
        if (locationReplaceOnRedirect) {
            window.location.replace(this.url.href);
        } else {
            window.location.href = this.url.href;
        }
    }
}
class TorusCommunicationProvider extends BaseProvider {
    constructor(connectionStream, _ref){
        let { maxEventListeners = 100, jsonRpcStreamName = "provider" } = _ref;
        super(connectionStream, {
            maxEventListeners,
            jsonRpcStreamName
        });
        // private state
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "embedTranslations", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "torusUrl", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "dappStorageKey", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "windowRefs", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "tryWindowHandle", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "torusAlertContainer", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "torusIframe", void 0);
        this._state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, TorusCommunicationProvider._defaultState);
        // public state
        this.torusUrl = "";
        this.dappStorageKey = "";
        const languageTranslations = configuration.translations[getUserLanguage()];
        this.embedTranslations = languageTranslations.embed;
        this.windowRefs = {};
        // setup own event listeners
        // EIP-1193 connect
        this.on("connect", ()=>{
            this._state.isConnected = true;
        });
        const notificationHandler = (payload)=>{
            const { method, params } = payload;
            if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_NOTIFICATIONS"].IFRAME_STATUS) {
                const { isFullScreen, rid } = params;
                this._displayIframe({
                    isFull: isFullScreen,
                    rid: rid
                });
            // TODO: remove this method when wallet adds versioning and stops supporting this method
            } else if (method === "create_window") {
                const { windowId, url } = params;
                this._createPopupBlockAlert(windowId, url);
            } else if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_NOTIFICATIONS"].CLOSE_WINDOW) {
                this._handleCloseWindow(params);
            } else if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_NOTIFICATIONS"].USER_LOGGED_IN) {
                const { currentLoginProvider } = params;
                this._state.isLoggedIn = true;
                this._state.currentLoginProvider = currentLoginProvider;
            } else if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_NOTIFICATIONS"].USER_LOGGED_OUT) {
                this._state.isLoggedIn = false;
                this._state.currentLoginProvider = null;
                this._displayIframe();
            }
        };
        this.jsonRpcConnectionEvents.on("notification", notificationHandler);
    }
    get isLoggedIn() {
        return this._state.isLoggedIn;
    }
    get isIFrameFullScreen() {
        return this._state.isIFrameFullScreen;
    }
    /**
   * Returns whether the inPage provider is connected to Torus.
   */ isConnected() {
        return this._state.isConnected;
    }
    async _initializeState(params) {
        try {
            const { torusUrl, dappStorageKey, torusAlertContainer, torusIframe } = params;
            this.torusUrl = torusUrl;
            this.dappStorageKey = dappStorageKey;
            this.torusAlertContainer = torusAlertContainer;
            this.torusIframe = torusIframe;
            this.torusIframe.addEventListener("load", ()=>{
                // only do this if iframe is not full screen
                if (!this._state.isIFrameFullScreen) this._displayIframe();
            });
            const { currentLoginProvider, isLoggedIn } = await this.request({
                method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_JRPC_METHODS"].GET_PROVIDER_STATE,
                params: []
            });
            // indicate that we've connected, for EIP-1193 compliance
            this._handleConnect(currentLoginProvider, isLoggedIn);
        } catch (error) {
            log.error("Torus: Failed to get initial state. Please report this bug.", error);
        } finally{
            log.info("initialized communication state");
            this._state.initialized = true;
            this.emit("_initialized");
        }
    }
    _handleWindow(windowId) {
        let { url, target, features } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const finalUrl = new URL(url || `${this.torusUrl}/redirect?windowId=${windowId}`);
        if (this.dappStorageKey) {
            // If multiple instances, it returns the first one
            if (finalUrl.hash) finalUrl.hash += `&dappStorageKey=${this.dappStorageKey}`;
            else finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;
        }
        const handledWindow = new PopupHandler({
            url: finalUrl,
            target,
            features
        });
        handledWindow.open();
        if (!handledWindow.window) {
            this._createPopupBlockAlert(windowId, finalUrl.href);
            return;
        }
        // Add to collection only if window is opened
        this.windowRefs[windowId] = handledWindow;
        // We tell the iframe that the window has been successfully opened
        this.request({
            method: "opened_window",
            params: {
                windowId
            }
        });
        handledWindow.once("close", ()=>{
            // user closed the window
            delete this.windowRefs[windowId];
            this.request({
                method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_JRPC_METHODS"].CLOSED_WINDOW,
                params: {
                    windowId
                }
            });
        });
    }
    _displayIframe() {
        let { isFull = false, rid = "" } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const style = {};
        // set phase
        if (!isFull) {
            style.display = this._state.torusWidgetVisibility ? "block" : "none";
            style.height = "70px";
            style.width = "70px";
            switch(this._state.buttonPosition){
                case BUTTON_POSITION.TOP_LEFT:
                    style.top = "0px";
                    style.left = "0px";
                    style.right = "auto";
                    style.bottom = "auto";
                    break;
                case BUTTON_POSITION.TOP_RIGHT:
                    style.top = "0px";
                    style.right = "0px";
                    style.left = "auto";
                    style.bottom = "auto";
                    break;
                case BUTTON_POSITION.BOTTOM_RIGHT:
                    style.bottom = "0px";
                    style.right = "0px";
                    style.top = "auto";
                    style.left = "auto";
                    break;
                case BUTTON_POSITION.BOTTOM_LEFT:
                default:
                    style.bottom = "0px";
                    style.left = "0px";
                    style.top = "auto";
                    style.right = "auto";
                    break;
            }
        } else {
            style.display = "block";
            style.width = "100%";
            style.height = "100%";
            style.top = "0px";
            style.right = "0px";
            style.left = "0px";
            style.bottom = "0px";
        }
        Object.assign(this.torusIframe.style, style);
        this._state.isIFrameFullScreen = isFull;
        this.request({
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_JRPC_METHODS"].IFRAME_STATUS,
            params: {
                isIFrameFullScreen: isFull,
                rid
            }
        });
    }
    hideTorusButton() {
        this._state.torusWidgetVisibility = false;
        this._displayIframe();
    }
    showTorusButton() {
        this._state.torusWidgetVisibility = true;
        this._displayIframe();
    }
    /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */ _rpcRequest(payload, callback) {
        const cb = callback;
        const _payload = payload;
        if (!Array.isArray(_payload)) {
            if (!_payload.jsonrpc) {
                _payload.jsonrpc = "2.0";
            }
        }
        this.tryWindowHandle(_payload, cb);
    }
    /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param currentLoginProvider - The login Provider
   * emits TorusInpageProvider#connect
   */ _handleConnect(currentLoginProvider, isLoggedIn) {
        if (!this._state.isConnected) {
            this._state.isConnected = true;
            this.emit("connect", {
                currentLoginProvider,
                isLoggedIn
            });
            log.debug(messages.info.connected(currentLoginProvider));
        }
    }
    /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */ _handleDisconnect(isRecoverable, errorMessage) {
        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {
            this._state.isConnected = false;
            let error;
            if (isRecoverable) {
                error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eth$2d$rpc$2d$errors$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumRpcError"](1013, // Try again later
                errorMessage || messages.errors.disconnected());
                log.debug(error);
            } else {
                error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eth$2d$rpc$2d$errors$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumRpcError"](1011, // Internal error
                errorMessage || messages.errors.permanentlyDisconnected());
                log.error(error);
                this._state.currentLoginProvider = null;
                this._state.isLoggedIn = false;
                this._state.torusWidgetVisibility = false;
                this._state.isIFrameFullScreen = false;
                this._state.isPermanentlyDisconnected = true;
            }
            this.emit("disconnect", error);
        }
    }
    // Called if the iframe wants to close the window cause it is done processing the request
    _handleCloseWindow(params) {
        const { windowId } = params;
        if (this.windowRefs[windowId]) {
            this.windowRefs[windowId].close();
            delete this.windowRefs[windowId];
        }
    }
    async _createPopupBlockAlert(windowId, url) {
        const logoUrl = this.getLogoUrl();
        const torusAlert = htmlToElement('<div id="torusAlert" class="torus-alert--v2">' + `<div id="torusAlert__logo"><img src="${logoUrl}" /></div>` + "<div>" + `<h1 id="torusAlert__title">${this.embedTranslations.actionRequired}</h1>` + `<p id="torusAlert__desc">${this.embedTranslations.pendingAction}</p>` + "</div>" + "</div>");
        const successAlert = htmlToElement(`<div><a id="torusAlert__btn">${this.embedTranslations.continue}</a></div>`);
        const btnContainer = htmlToElement('<div id="torusAlert__btn-container"></div>');
        btnContainer.appendChild(successAlert);
        torusAlert.appendChild(btnContainer);
        const bindOnLoad = ()=>{
            successAlert.addEventListener("click", ()=>{
                this._handleWindow(windowId, {
                    url,
                    target: "_blank",
                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)
                });
                torusAlert.remove();
                if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = "none";
            });
        };
        const attachOnLoad = ()=>{
            this.torusAlertContainer.appendChild(torusAlert);
        };
        attachOnLoad();
        bindOnLoad();
        this.torusAlertContainer.style.display = "block";
    }
    getLogoUrl() {
        const logoUrl = `${this.torusUrl}/images/torus_icon-blue.svg`;
        return logoUrl;
    }
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(TorusCommunicationProvider, "_defaultState", {
    buttonPosition: "bottom-left",
    currentLoginProvider: null,
    isIFrameFullScreen: false,
    hasEmittedConnection: false,
    torusWidgetVisibility: false,
    initialized: false,
    isLoggedIn: false,
    isPermanentlyDisconnected: false,
    isConnected: false
});
class TorusInPageProvider extends BaseProvider {
    constructor(connectionStream, _ref){
        let { maxEventListeners = 100, jsonRpcStreamName = "provider" } = _ref;
        super(connectionStream, {
            maxEventListeners,
            jsonRpcStreamName
        });
        // private state
        /**
     * The chain ID of the currently connected Solana chain.
     * See [chainId.network]{@link https://chainid.network} for more information.
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "chainId", void 0);
        /**
     * The user's currently selected Solana address.
     * If null, Torus is either locked or the user has not permitted any
     * addresses to be viewed.
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "selectedAddress", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "tryWindowHandle", void 0);
        this._state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, TorusInPageProvider._defaultState);
        // public state
        this.selectedAddress = null;
        this.chainId = null;
        this._handleAccountsChanged = this._handleAccountsChanged.bind(this);
        this._handleChainChanged = this._handleChainChanged.bind(this);
        this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);
        // setup own event listeners
        // EIP-1193 connect
        this.on("connect", ()=>{
            this._state.isConnected = true;
        });
        const jsonRpcNotificationHandler = (payload)=>{
            const { method, params } = payload;
            if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PROVIDER_NOTIFICATIONS"].ACCOUNTS_CHANGED) {
                this._handleAccountsChanged(params);
            } else if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PROVIDER_NOTIFICATIONS"].UNLOCK_STATE_CHANGED) {
                this._handleUnlockStateChanged(params);
            } else if (method === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PROVIDER_NOTIFICATIONS"].CHAIN_CHANGED) {
                this._handleChainChanged(params);
            }
        };
        // json rpc notification listener
        this.jsonRpcConnectionEvents.on("notification", jsonRpcNotificationHandler);
    }
    /**
   * Returns whether the inpage provider is connected to Torus.
   */ isConnected() {
        return this._state.isConnected;
    }
    // Private Methods
    //= ===================
    /**
   * Constructor helper.
   * Populates initial state by calling 'wallet_getProviderState' and emits
   * necessary events.
   */ async _initializeState() {
        try {
            const { accounts, chainId, isUnlocked } = await this.request({
                method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PROVIDER_JRPC_METHODS"].GET_PROVIDER_STATE,
                params: []
            });
            // indicate that we've connected, for EIP-1193 compliance
            this.emit("connect", {
                chainId
            });
            this._handleChainChanged({
                chainId
            });
            this._handleUnlockStateChanged({
                accounts,
                isUnlocked
            });
            this._handleAccountsChanged(accounts);
        } catch (error) {
            log.error("Torus: Failed to get initial state. Please report this bug.", error);
        } finally{
            log.info("initialized provider state");
            this._state.initialized = true;
            this.emit("_initialized");
        }
    }
    /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */ _rpcRequest(payload, callback) {
        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        let cb = callback;
        const _payload = payload;
        if (!Array.isArray(_payload)) {
            if (!_payload.jsonrpc) {
                _payload.jsonrpc = "2.0";
            }
            if (_payload.method === "solana_accounts" || _payload.method === "solana_requestAccounts") {
                // handle accounts changing
                cb = (err, res)=>{
                    this._handleAccountsChanged(res.result || [], _payload.method === "solana_accounts", isInternal);
                    callback(err, res);
                };
            } else if (_payload.method === "wallet_getProviderState") {
                this._rpcEngine.handle(payload, cb);
                return;
            }
        }
        this.tryWindowHandle(_payload, cb);
    }
    /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param chainId - The ID of the newly connected chain.
   * emits TorusInpageProvider#connect
   */ _handleConnect(chainId) {
        if (!this._state.isConnected) {
            this._state.isConnected = true;
            this.emit("connect", {
                chainId
            });
            log.debug(messages.info.connected(chainId));
        }
    }
    /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */ _handleDisconnect(isRecoverable, errorMessage) {
        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {
            this._state.isConnected = false;
            let error;
            if (isRecoverable) {
                error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eth$2d$rpc$2d$errors$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumRpcError"](1013, // Try again later
                errorMessage || messages.errors.disconnected());
                log.debug(error);
            } else {
                error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eth$2d$rpc$2d$errors$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumRpcError"](1011, // Internal error
                errorMessage || messages.errors.permanentlyDisconnected());
                log.error(error);
                this.chainId = null;
                this._state.accounts = null;
                this.selectedAddress = null;
                this._state.isUnlocked = false;
                this._state.isPermanentlyDisconnected = true;
            }
            this.emit("disconnect", error);
        }
    }
    /**
   * Called when accounts may have changed.
   */ _handleAccountsChanged(accounts) {
        let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        // defensive programming
        let finalAccounts = accounts;
        if (!Array.isArray(finalAccounts)) {
            log.error("Torus: Received non-array accounts parameter. Please report this bug.", finalAccounts);
            finalAccounts = [];
        }
        for (const account of accounts){
            if (typeof account !== "string") {
                log.error("Torus: Received non-string account. Please report this bug.", accounts);
                finalAccounts = [];
                break;
            }
        }
        // emit accountsChanged if anything about the accounts array has changed
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this._state.accounts, finalAccounts)) {
            // we should always have the correct accounts even before solana_accounts
            // returns, except in cases where isInternal is true
            if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {
                log.error('Torus: "solana_accounts" unexpectedly updated accounts. Please report this bug.', finalAccounts);
            }
            this._state.accounts = finalAccounts;
            this.emit("accountsChanged", finalAccounts);
        }
        // handle selectedAddress
        if (this.selectedAddress !== finalAccounts[0]) {
            this.selectedAddress = finalAccounts[0] || null;
        }
    }
    /**
   * Upon receipt of a new chainId and networkVersion, emits corresponding
   * events and sets relevant public state.
   * Does nothing if neither the chainId nor the networkVersion are different
   * from existing values.
   *
   * emits TorusInpageProvider#chainChanged
   * @param networkInfo - An object with network info.
   */ _handleChainChanged() {
        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (!chainId) {
            log.error("Torus: Received invalid network parameters. Please report this bug.", {
                chainId
            });
            return;
        }
        if (chainId === "loading") {
            this._handleDisconnect(true);
        } else {
            this._handleConnect(chainId);
            if (chainId !== this.chainId) {
                this.chainId = chainId;
                if (this._state.initialized) {
                    this.emit("chainChanged", this.chainId);
                }
            }
        }
    }
    /**
   * Upon receipt of a new isUnlocked state, sets relevant public state.
   * Calls the accounts changed handler with the received accounts, or an empty
   * array.
   *
   * Does nothing if the received value is equal to the existing value.
   * There are no lock/unlock events.
   *
   * @param opts - Options bag.
   */ _handleUnlockStateChanged() {
        let { accounts, isUnlocked } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (typeof isUnlocked !== "boolean") {
            log.error("Torus: Received invalid isUnlocked parameter. Please report this bug.", {
                isUnlocked
            });
            return;
        }
        if (isUnlocked !== this._state.isUnlocked) {
            this._state.isUnlocked = isUnlocked;
            this._handleAccountsChanged(accounts || []);
        }
    }
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(TorusInPageProvider, "_defaultState", {
    accounts: null,
    isConnected: false,
    isUnlocked: false,
    initialized: false,
    isPermanentlyDisconnected: false,
    hasEmittedConnection: false
});
/**
 * Returns whether the given image URL exists
 */ function imgExists(url) {
    return new Promise((resolve, reject)=>{
        try {
            const img = document.createElement("img");
            img.onload = ()=>resolve(true);
            img.onerror = ()=>resolve(false);
            img.src = url;
        } catch (e) {
            reject(e);
        }
    });
}
/**
 * Extracts a name for the site from the DOM
 */ const getSiteName = (window1)=>{
    const { document: document1 } = window1;
    const siteName = document1.querySelector('head > meta[property="og:site_name"]');
    if (siteName) {
        return siteName.content;
    }
    const metaTitle = document1.querySelector('head > meta[name="title"]');
    if (metaTitle) {
        return metaTitle.content;
    }
    if (document1.title && document1.title.length > 0) {
        return document1.title;
    }
    return window1.location.hostname;
};
/**
 * Extracts an icon for the site from the DOM
 */ async function getSiteIcon(window1) {
    try {
        const { document: document1 } = window1;
        // Use the site's favicon if it exists
        let icon = document1.querySelector('head > link[rel="shortcut icon"]');
        if (icon && await imgExists(icon.href)) {
            return icon.href;
        }
        // Search through available icons in no particular order
        icon = Array.from(document1.querySelectorAll('head > link[rel="icon"]')).find((_icon)=>Boolean(_icon.href));
        if (icon && await imgExists(icon.href)) {
            return icon.href;
        }
        return "";
    } catch (error) {
        return "";
    }
}
/**
 * Gets site metadata and returns it
 *
 */ const getSiteMetadata = async ()=>({
        name: getSiteName(window),
        icon: await getSiteIcon(window)
    });
const PROVIDER_UNSAFE_METHODS = [
    "send_transaction",
    "sign_transaction",
    "sign_all_transactions",
    "sign_message",
    "connect"
];
const COMMUNICATION_UNSAFE_METHODS = [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_JRPC_METHODS"].SET_PROVIDER
];
const isLocalStorageAvailable = storageAvailable("localStorage");
// preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267
(async function preLoadIframe() {
    try {
        if (typeof document === "undefined") return;
        const torusIframeHtml = document.createElement("link");
        const { torusUrl } = await getTorusUrl("production");
        torusIframeHtml.href = `${torusUrl}/frame`;
        torusIframeHtml.crossOrigin = "anonymous";
        torusIframeHtml.type = "text/html";
        torusIframeHtml.rel = "prefetch";
        if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {
            if (torusIframeHtml.relList.supports("prefetch")) {
                document.head.appendChild(torusIframeHtml);
            }
        }
    } catch (error) {
        log.warn(error);
    }
})();
class Torus {
    constructor(){
        let { modalZIndex = 99999 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "isInitialized", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "torusAlert", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "modalZIndex", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "alertZIndex", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "requestedLoginProvider", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "provider", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "communicationProvider", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "dappStorageKey", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "isTopupHidden", false);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "torusAlertContainer", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "torusUrl", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "torusIframe", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "styleLink", void 0);
        this.torusUrl = "";
        this.isInitialized = false; // init done
        this.requestedLoginProvider = null;
        this.modalZIndex = modalZIndex;
        this.alertZIndex = modalZIndex + 1000;
        this.dappStorageKey = "";
    }
    get isLoggedIn() {
        if (!this.communicationProvider) return false;
        return this.communicationProvider.isLoggedIn;
    }
    async init() {
        let { buildEnv = TORUS_BUILD_ENV.PRODUCTION, enableLogging = false, network, showTorusButton = false, useLocalStorage = false, buttonPosition = BUTTON_POSITION.BOTTOM_LEFT, apiKey = "torus-default", extraParams = {}, whiteLabel } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this.isInitialized) throw new Error("Already initialized");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$http$2d$helpers$2f$dist$2f$httpHelpers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setAPIKey"])(apiKey);
        const { torusUrl, logLevel } = await getTorusUrl(buildEnv);
        log.enableAll();
        log.info(torusUrl, "url loaded");
        log.info(`Solana Embed Version :${version}`);
        this.torusUrl = torusUrl;
        log.setDefaultLevel(logLevel);
        if (enableLogging) log.enableAll();
        else log.disableAll();
        const dappStorageKey = this.handleDappStorageKey(useLocalStorage);
        const torusIframeUrl = new URL(torusUrl);
        if (torusIframeUrl.pathname.endsWith("/")) torusIframeUrl.pathname += "frame";
        else torusIframeUrl.pathname += "/frame";
        const hashParams = new URLSearchParams();
        if (dappStorageKey) hashParams.append("dappStorageKey", dappStorageKey);
        hashParams.append("origin", window.location.origin);
        torusIframeUrl.hash = hashParams.toString();
        // Iframe code
        this.torusIframe = htmlToElement(`<iframe
        id="torusIframe"
        class="torusIframe"
        src="${torusIframeUrl.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%;
        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()}"
      ></iframe>`);
        this.torusAlertContainer = htmlToElement(`<div id="torusAlertContainer" style="display:none; z-index: ${this.alertZIndex.toString()}"></div>`);
        this.styleLink = htmlToElement(`<link href="${torusUrl}/css/widget.css" rel="stylesheet" type="text/css">`);
        return new Promise((resolve, reject)=>{
            try {
                this.torusIframe.addEventListener("load", async ()=>{
                    const dappMetadata = await getSiteMetadata();
                    // send init params here
                    this.torusIframe.contentWindow.postMessage({
                        buttonPosition,
                        apiKey,
                        network,
                        dappMetadata,
                        extraParams,
                        whiteLabel
                    }, torusIframeUrl.origin);
                    await this._setupWeb3({
                        torusUrl
                    });
                    if (showTorusButton) this.showTorusButton();
                    if (whiteLabel?.topupHide) this.isTopupHidden = whiteLabel.topupHide;
                    else this.hideTorusButton();
                    this.isInitialized = true;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    window.torus = this;
                    resolve();
                });
                window.document.head.appendChild(this.styleLink);
                window.document.body.appendChild(this.torusIframe);
                window.document.body.appendChild(this.torusAlertContainer);
            } catch (error) {
                reject(error);
            }
        });
    }
    async login() {
        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (!this.isInitialized) throw new Error("Call init() first");
        try {
            this.requestedLoginProvider = params.loginProvider || null;
            if (!this.requestedLoginProvider) {
                this.communicationProvider._displayIframe({
                    isFull: true
                });
            }
            // If user is already logged in, we assume they have given access to the website
            const res = await new Promise((resolve, reject)=>{
                // We use this method because we want to update inPage provider state with account info
                this.provider._rpcRequest({
                    method: "solana_requestAccounts",
                    params: [
                        this.requestedLoginProvider,
                        params.login_hint
                    ]
                }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRpcPromiseCallback"])(resolve, reject));
            });
            if (Array.isArray(res) && res.length > 0) {
                return res;
            }
            // This would never happen, but just in case
            throw new Error("Login failed");
        } catch (error) {
            log.error("login failed", error);
            throw error;
        } finally{
            if (this.communicationProvider.isIFrameFullScreen) this.communicationProvider._displayIframe();
        }
    }
    async loginWithPrivateKey(loginParams) {
        if (!this.isInitialized) throw new Error("Call init() first");
        const { privateKey, userInfo } = loginParams;
        const { success } = await this.communicationProvider.request({
            method: "login_with_private_key",
            params: {
                privateKey,
                userInfo
            }
        });
        if (!success) throw new Error("Login Failed");
    }
    async logout() {
        if (!this.communicationProvider.isLoggedIn) throw new Error("Not logged in");
        await this.communicationProvider.request({
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_JRPC_METHODS"].LOGOUT,
            params: []
        });
        this.requestedLoginProvider = null;
    }
    async cleanUp() {
        if (this.communicationProvider.isLoggedIn) {
            await this.logout();
        }
        this.clearInit();
    }
    clearInit() {
        function isElement(element) {
            return element instanceof Element || element instanceof Document;
        }
        if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {
            this.styleLink.remove();
            this.styleLink = undefined;
        }
        if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {
            this.torusIframe.remove();
            this.torusIframe = undefined;
        }
        if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {
            this.torusAlert = undefined;
            this.torusAlertContainer.remove();
            this.torusAlertContainer = undefined;
        }
        this.isInitialized = false;
    }
    hideTorusButton() {
        this.communicationProvider.hideTorusButton();
    }
    showTorusButton() {
        this.communicationProvider.showTorusButton();
    }
    async setProvider(params) {
        await this.communicationProvider.request({
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_JRPC_METHODS"].SET_PROVIDER,
            params: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, params)
        });
    }
    async showWallet(path) {
        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const instanceId = await this.communicationProvider.request({
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_JRPC_METHODS"].WALLET_INSTANCE_ID,
            params: []
        });
        const finalPath = path ? `/${path}` : "";
        const finalUrl = new URL(`${this.torusUrl}/wallet${finalPath}`);
        // Using URL constructor to prevent js injection and allow parameter validation.!
        finalUrl.searchParams.append("instanceId", instanceId);
        Object.keys(params).forEach((x)=>{
            finalUrl.searchParams.append(x, params[x]);
        });
        if (this.dappStorageKey) {
            finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;
        }
        // No need to track this window state. Hence, no _handleWindow call.
        const walletWindow = new PopupHandler({
            url: finalUrl,
            features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)
        });
        walletWindow.open();
    }
    async getUserInfo() {
        const userInfoResponse = await this.communicationProvider.request({
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_JRPC_METHODS"].USER_INFO,
            params: []
        });
        return userInfoResponse;
    }
    async initiateTopup(provider, params) {
        if (!this.isInitialized) throw new Error("Torus is not initialized");
        const windowId = getWindowId();
        this.communicationProvider._handleWindow(windowId);
        const topupResponse = await this.communicationProvider.request({
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$baseControllers$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["COMMUNICATION_JRPC_METHODS"].TOPUP,
            params: {
                provider,
                params,
                windowId
            }
        });
        return topupResponse;
    }
    // Solana specific API
    async getAccounts() {
        const response = await this.provider.request({
            method: "getAccounts",
            params: []
        });
        return response;
    }
    async sendTransaction(transaction) {
        const isLegacyTransaction = isLegacyTransactionInstance(transaction);
        const message = isLegacyTransaction ? transaction.serialize({
            requireAllSignatures: false
        }).toString("hex") : Buffer.from(transaction.serialize()).toString("hex");
        const response = await this.provider.request({
            method: "send_transaction",
            params: {
                message,
                isLegacyTransaction
            }
        });
        return response;
    }
    // support sendOptions
    async signAndSendTransaction(transaction, options) {
        const isLegacyTransaction = isLegacyTransactionInstance(transaction);
        const message = isLegacyTransaction ? transaction.serialize({
            requireAllSignatures: false
        }).toString("hex") : Buffer.from(transaction.serialize()).toString("hex");
        const response = await this.provider.request({
            method: "send_transaction",
            params: {
                message,
                options,
                isLegacyTransaction
            }
        });
        return {
            signature: response
        };
    }
    async signTransaction(transaction) {
        const isLegacyTransaction = isLegacyTransactionInstance(transaction);
        const message = isLegacyTransaction ? transaction.serializeMessage().toString("hex") : Buffer.from(transaction.message.serialize()).toString("hex");
        const response = await this.provider.request({
            method: "sign_transaction",
            params: {
                message,
                messageOnly: true,
                isLegacyTransaction
            }
        });
        // reconstruct signature pair
        const parsed = JSON.parse(response);
        const signature = {
            publicKey: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PublicKey"](parsed.publicKey),
            signature: Buffer.from(parsed.signature, "hex")
        };
        transaction.addSignature(signature.publicKey, signature.signature);
        return transaction;
    }
    async signAllTransactions(transactions) {
        let isLegacyTransaction;
        const encodedMessage = transactions.map((tx)=>{
            isLegacyTransaction = isLegacyTransactionInstance(tx);
            return isLegacyTransaction ? tx.serializeMessage().toString("hex") : Buffer.from(tx.message.serialize()).toString("hex");
        });
        const responses = await this.provider.request({
            method: "sign_all_transactions",
            params: {
                message: encodedMessage,
                messageOnly: true,
                isLegacyTransaction
            }
        });
        // reconstruct signature pairs
        const signatures = responses.map((item)=>{
            const parsed = JSON.parse(item);
            return {
                publicKey: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PublicKey"](parsed.publicKey),
                signature: Buffer.from(parsed.signature, "hex")
            };
        });
        transactions.forEach((tx, idx)=>{
            tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);
            return tx;
        });
        return transactions;
    }
    async signMessage(data) {
        const response = await this.provider.request({
            method: "sign_message",
            params: {
                data
            }
        });
        return response;
    }
    async getGaslessPublicKey() {
        const response = await this.provider.request({
            method: "get_gasless_public_key",
            params: []
        });
        return response;
    }
    // async connect(): Promise<boolean> {
    //   const response = (await this.provider.request({
    //     method: "connect",
    //     params: {},
    //   })) as boolean;
    //   return response;
    // }
    handleDappStorageKey(useLocalStorage) {
        const localStorageKey = `${configuration.localStorageKeyPrefix}${window.location.hostname}`;
        let dappStorageKey = "";
        if (isLocalStorageAvailable && useLocalStorage) {
            const storedKey = window.localStorage.getItem(localStorageKey);
            if (storedKey) dappStorageKey = storedKey;
            else {
                const generatedKey = `torus-app-${getWindowId()}`;
                window.localStorage.setItem(localStorageKey, generatedKey);
                dappStorageKey = generatedKey;
            }
        }
        this.dappStorageKey = dappStorageKey;
        return dappStorageKey;
    }
    async _setupWeb3(providerParams) {
        log.info("setupWeb3 running");
        // setup background connection
        const providerStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BasePostMessageStream"]({
            name: "embed_torus",
            target: "iframe_torus",
            targetWindow: this.torusIframe.contentWindow
        });
        // We create another LocalMessageDuplexStream for communication between dapp <> iframe
        const communicationStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$openlogin$2d$jrpc$2f$dist$2f$openloginJrpc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BasePostMessageStream"]({
            name: "embed_communication",
            target: "iframe_communication",
            targetWindow: this.torusIframe.contentWindow
        });
        // compose the inPage provider
        const inPageProvider = new TorusInPageProvider(providerStream, {});
        const communicationProvider = new TorusCommunicationProvider(communicationStream, {});
        inPageProvider.tryWindowHandle = (payload, cb)=>{
            const _payload = payload;
            if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {
                if (!this.communicationProvider.isLoggedIn) throw new Error("User Not Logged In");
                const windowId = getWindowId();
                communicationProvider._handleWindow(windowId, {
                    target: "_blank",
                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)
                });
                // for inPageProvider methods sending windowId in request instead of params
                // as params might be positional.
                _payload.windowId = windowId;
            }
            inPageProvider._rpcEngine.handle(_payload, cb);
        };
        communicationProvider.tryWindowHandle = (payload, cb)=>{
            const _payload = payload;
            if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {
                const windowId = getWindowId();
                communicationProvider._handleWindow(windowId, {
                    target: "_blank",
                    features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW) // todo: are these features generic for all
                });
                // for communication methods sending window id in jrpc req params
                _payload.params.windowId = windowId;
            }
            communicationProvider._rpcEngine.handle(_payload, cb);
        };
        // detect solana_requestAccounts and pipe to enable for now
        const detectAccountRequestPrototypeModifier = (m)=>{
            const originalMethod = inPageProvider[m];
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const self = this;
            inPageProvider[m] = function providerFunc(request, cb) {
                const { method, params = [] } = request;
                if (method === "solana_requestAccounts") {
                    if (!cb) return self.login({
                        loginProvider: params[0]
                    });
                    self.login({
                        loginProvider: params[0]
                    })// eslint-disable-next-line promise/no-callback-in-promise
                    .then((res)=>cb(null, res))// eslint-disable-next-line promise/no-callback-in-promise
                    .catch((err)=>cb(err));
                }
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                return originalMethod.apply(this, [
                    request,
                    cb
                ]);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            };
        };
        // Detects call to solana_requestAccounts in request & sendAsync and passes to login
        detectAccountRequestPrototypeModifier("request");
        detectAccountRequestPrototypeModifier("sendAsync");
        detectAccountRequestPrototypeModifier("send");
        const proxiedInPageProvider = new Proxy(inPageProvider, {
            // straight up lie that we deleted the property so that it doesn't
            // throw an error in strict mode
            deleteProperty: ()=>true
        });
        const proxiedCommunicationProvider = new Proxy(communicationProvider, {
            // straight up lie that we deleted the property so that it doesn't
            // throw an error in strict mode
            deleteProperty: ()=>true
        });
        this.provider = proxiedInPageProvider;
        this.communicationProvider = proxiedCommunicationProvider;
        await Promise.all([
            inPageProvider._initializeState(),
            communicationProvider._initializeState((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, providerParams), {}, {
                dappStorageKey: this.dappStorageKey,
                torusAlertContainer: this.torusAlertContainer,
                torusIframe: this.torusIframe
            }))
        ]);
        log.debug("Torus - injected provider");
    }
}
;
}}),

};

//# sourceMappingURL=node_modules_%40toruslabs_4a998bf8._.js.map