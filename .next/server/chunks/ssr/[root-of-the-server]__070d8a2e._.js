module.exports = {

"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[project]/src/context/theme-provider.tsx [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ThemeProvider": (()=>ThemeProvider)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$themes$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-themes/dist/index.mjs [app-ssr] (ecmascript)");
'use client';
;
;
function ThemeProvider({ children, ...props }) {
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxDEV"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$themes$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ThemeProvider"], {
        ...props,
        children: children
    }, void 0, false, {
        fileName: "[project]/src/context/theme-provider.tsx",
        lineNumber: 8,
        columnNumber: 10
    }, this);
}
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/node:crypto [external] (node:crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/node:url [external] (node:url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:url", () => require("node:url"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[project]/src/lib/solana-connection.ts [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "connectionManager": (()=>connectionManager),
    "getConnection": (()=>getConnection)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/web3.js/lib/index.esm.js [app-ssr] (ecmascript)");
;
// RPC node configuration
const CONNECTION_CONFIG = {
    commitment: 'confirmed',
    confirmTransactionInitialTimeout: 60000,
    disableRetryOnRateLimit: true
};
// List of available RPC endpoints - add more options for better fallback capabilities
const RPC_ENDPOINTS = [
    // Your current endpoint
    'https://mainnet.helius-rpc.com/?api-key=56ad7ab1-3b24-442a-9141-0b362594dac9'
];
// Create a connection with intelligent endpoint selection
class SolanaConnectionManager {
    endpoints = RPC_ENDPOINTS;
    currentEndpointIndex = 0;
    connection;
    // Track endpoint stats to make smarter decisions
    endpointStats = [];
    // Request throttling with per-endpoint tracking
    maxRequestsPerMinute = 45;
    globalRequestsPerMinute = 100;
    globalRequestLog = [];
    // Track pending requests to avoid overwhelming the node
    pendingRequests = 0;
    maxConcurrentRequests = 10;
    constructor(){
        // Initialize stats for all endpoints
        this.endpoints.forEach((url)=>{
            this.endpointStats.push({
                url,
                requestCount: 0,
                lastRequestTime: 0,
                errorCount: 0,
                consecutiveErrors: 0,
                lastErrorTime: null,
                cooldownUntil: null,
                avgResponseTime: 0,
                successRate: 1.0,
                requestLog: []
            });
        });
        // Start with first endpoint
        this.connection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Connection"](this.endpoints[this.currentEndpointIndex], CONNECTION_CONFIG);
        // Set up periodic health checks and stats calculation
        this.setupPeriodicTasks();
    }
    // Get the current connection
    getConnection() {
        return this.connection;
    }
    // Setup periodic maintenance tasks
    setupPeriodicTasks() {
        // Check endpoint health every 2 minutes
        setInterval(()=>{
            this.checkEndpointHealth().catch(console.error);
        }, 2 * 60 * 1000);
        // Recalculate endpoint stats every minute
        setInterval(()=>{
            this.recalculateEndpointStats();
        }, 60 * 1000);
        // Cleanup old request logs every 5 minutes
        setInterval(()=>{
            this.cleanupOldLogs();
        }, 5 * 60 * 1000);
    }
    // Clean up old request logs to prevent memory bloat
    cleanupOldLogs() {
        const now = Date.now();
        const oneHourAgo = now - 60 * 60 * 1000;
        // Clean global request log
        this.globalRequestLog = this.globalRequestLog.filter((time)=>time > oneHourAgo);
        // Clean endpoint-specific logs
        this.endpointStats.forEach((stats)=>{
            stats.requestLog = stats.requestLog.filter((log)=>log.timestamp > oneHourAgo);
        });
    }
    // Check if we should throttle our requests
    shouldThrottle(endpointIndex) {
        const now = Date.now();
        const stats = this.endpointStats[endpointIndex];
        // Check if endpoint is in cooldown
        if (stats.cooldownUntil && now < stats.cooldownUntil) {
            return true;
        }
        // Count requests in the last minute for this endpoint
        const recentRequests = stats.requestLog.filter((log)=>log.timestamp > now - 60000).length;
        // Clean up old global timestamps (older than 1 minute)
        this.globalRequestLog = this.globalRequestLog.filter((time)=>time > now - 60000);
        // Check if we're over our per-endpoint or global limits
        const overPerEndpointLimit = recentRequests >= this.maxRequestsPerMinute;
        const overGlobalLimit = this.globalRequestLog.length >= this.globalRequestsPerMinute;
        const tooManyConcurrent = this.pendingRequests >= this.maxConcurrentRequests;
        return overPerEndpointLimit || overGlobalLimit || tooManyConcurrent;
    }
    // Recalculate endpoint statistics
    recalculateEndpointStats() {
        const now = Date.now();
        const recentWindow = now - 10 * 60 * 1000; // Last 10 minutes
        this.endpointStats.forEach((stats)=>{
            const recentLogs = stats.requestLog.filter((log)=>log.timestamp > recentWindow);
            if (recentLogs.length > 0) {
                // Calculate success rate
                const successfulRequests = recentLogs.filter((log)=>log.success).length;
                stats.successRate = successfulRequests / recentLogs.length;
                // Calculate average response time
                const responseTimes = recentLogs.filter((log)=>log.responseTime !== undefined).map((log)=>log.responseTime);
                if (responseTimes.length > 0) {
                    stats.avgResponseTime = responseTimes.reduce((sum, time)=>sum + time, 0) / responseTimes.length;
                }
            }
        });
    }
    // Select the best endpoint to use based on comprehensive metrics
    selectBestEndpoint() {
        const now = Date.now();
        // Step 1: Filter out endpoints in cooldown
        let availableEndpoints = this.endpointStats.map((stats, index)=>({
                stats,
                index
            })).filter(({ stats })=>!stats.cooldownUntil || now > stats.cooldownUntil);
        // If all endpoints are in cooldown, use the one with shortest cooldown time
        if (availableEndpoints.length === 0) {
            const endpointsSorted = this.endpointStats.map((stats, index)=>({
                    stats,
                    index
                })).sort((a, b)=>(a.stats.cooldownUntil || Infinity) - (b.stats.cooldownUntil || Infinity));
            return endpointsSorted[0].index;
        }
        // Step 2: Score endpoints based on multiple factors
        const scoredEndpoints = availableEndpoints.map(({ stats, index })=>{
            // Calculate a score (higher is better)
            const errorPenalty = stats.errorCount * 5;
            const responsePenalty = stats.avgResponseTime / 50; // Penalty for slow responses
            const successBonus = stats.successRate * 100;
            const score = successBonus - errorPenalty - responsePenalty;
            return {
                index,
                score
            };
        });
        // Step 3: Sort by score and pick the best
        scoredEndpoints.sort((a, b)=>b.score - a.score);
        return scoredEndpoints[0].index;
    }
    // Switch to best RPC endpoint
    switchEndpoint() {
        const previousEndpoint = this.currentEndpointIndex;
        this.currentEndpointIndex = this.selectBestEndpoint();
        // Only create new connection if endpoint actually changed
        if (previousEndpoint !== this.currentEndpointIndex) {
            this.connection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Connection"](this.endpoints[this.currentEndpointIndex], CONNECTION_CONFIG);
            console.log(`Switched to RPC endpoint: ${this.endpoints[this.currentEndpointIndex]}`);
        }
        return this.connection;
    }
    // Calculate dynamic backoff time based on consecutive errors and endpoint health
    calculateBackoffTime(endpointIndex) {
        const stats = this.endpointStats[endpointIndex];
        // Exponential backoff based on consecutive errors
        // Start at 1 second, double each time, cap at 60 seconds
        const baseTime = Math.min(1000 * Math.pow(2, stats.consecutiveErrors), 60000);
        // Add jitter to prevent all clients from retrying simultaneously
        const jitter = Math.random() * 1000;
        return baseTime + jitter;
    }
    // Execute a function with advanced fallback, throttling, and retry logic
    async executeWithFallback(fn, maxRetries = 3) {
        let retries = 0;
        let result;
        let lastError = null;
        // Try until success or max retries reached
        while(retries <= maxRetries){
            // Get best endpoint before each attempt
            if (retries > 0) {
                this.switchEndpoint();
            }
            const endpointIndex = this.currentEndpointIndex;
            const endpoint = this.endpoints[endpointIndex];
            const stats = this.endpointStats[endpointIndex];
            // Check if we need to throttle requests
            if (this.shouldThrottle(endpointIndex)) {
                const backoffTime = this.calculateBackoffTime(endpointIndex);
                console.warn(`Throttling requests to endpoint ${endpoint}. Waiting ${backoffTime}ms...`);
                await new Promise((resolve)=>setTimeout(resolve, backoffTime));
                continue; // Try again with possibly a different endpoint
            }
            // Record this request timestamp for throttling (both global and endpoint-specific)
            const now = Date.now();
            this.globalRequestLog.push(now);
            // Create request log entry
            const requestLogEntry = {
                timestamp: now,
                success: false
            };
            stats.requestLog.push(requestLogEntry);
            // Update stats for current endpoint
            stats.requestCount++;
            stats.lastRequestTime = now;
            this.pendingRequests++;
            // Measure response time
            const startTime = performance.now();
            try {
                // Execute the RPC call
                result = await fn(this.connection);
                // Record successful request
                const endTime = performance.now();
                const responseTime = endTime - startTime;
                requestLogEntry.success = true;
                requestLogEntry.responseTime = responseTime;
                // Reset consecutive error count on success
                stats.consecutiveErrors = 0;
                // Recover slightly from previous errors
                if (stats.errorCount > 0) {
                    stats.errorCount = Math.max(0, stats.errorCount - 0.5);
                }
                this.pendingRequests--;
                return result;
            } catch (error) {
                this.pendingRequests--;
                const endTime = performance.now();
                requestLogEntry.responseTime = endTime - startTime;
                const errorMessage = error?.message || '';
                lastError = error;
                // Update error stats for current endpoint
                stats.errorCount++;
                stats.consecutiveErrors++;
                stats.lastErrorTime = now;
                // Identify different types of RPC errors
                const isRateLimit = errorMessage.includes('429') || errorMessage.includes('Too many requests') || errorMessage.includes('Rate limit exceeded');
                const isServerError = errorMessage.includes('500') || errorMessage.includes('502') || errorMessage.includes('503') || errorMessage.includes('504') || errorMessage.includes('Internal Server Error');
                const isAuthError = errorMessage.includes('403') || errorMessage.includes('401') || errorMessage.includes('Access forbidden') || errorMessage.includes('Unauthorized');
                // Apply different strategies based on error type
                if (isRateLimit) {
                    // For rate limits, apply longer cooldown
                    const cooldownTime = Math.min(60000, stats.consecutiveErrors * 10000); // Max 60 sec
                    stats.cooldownUntil = now + cooldownTime;
                    console.warn(`Rate limit (429) on endpoint ${endpoint}. Cooldown for ${cooldownTime / 1000}s.`);
                    // Immediate switch to another endpoint
                    this.switchEndpoint();
                } else if (isServerError) {
                    // For server errors, apply short cooldown
                    const cooldownTime = Math.min(30000, stats.consecutiveErrors * 5000); // Max 30 sec
                    stats.cooldownUntil = now + cooldownTime;
                    console.warn(`Server error on endpoint ${endpoint}. Cooldown for ${cooldownTime / 1000}s.`);
                } else if (isAuthError) {
                    // For auth errors, apply longer cooldown as they won't resolve quickly
                    stats.cooldownUntil = now + 5 * 60 * 1000; // 5 minutes
                    console.warn(`Auth error on endpoint ${endpoint}. Cooldown for 5 minutes.`);
                }
                if (retries < maxRetries) {
                    // Apply backoff before retry
                    const backoffTime = this.calculateBackoffTime(endpointIndex);
                    console.warn(`RPC error (${errorMessage}). Retrying in ${backoffTime / 1000}s (${retries + 1}/${maxRetries})`);
                    await new Promise((resolve)=>setTimeout(resolve, backoffTime));
                    retries++;
                } else {
                    console.error(`Exhausted all retries (${maxRetries}). Last error:`, error);
                    throw error;
                }
            }
        }
        throw lastError || new Error('Exhausted all RPC fallback attempts');
    }
    // Add a custom RPC endpoint
    addEndpoint(url) {
        // Check if endpoint already exists
        if (!this.endpoints.includes(url)) {
            this.endpoints.push(url);
            // Initialize stats for the new endpoint
            this.endpointStats.push({
                url,
                requestCount: 0,
                lastRequestTime: 0,
                errorCount: 0,
                consecutiveErrors: 0,
                lastErrorTime: null,
                cooldownUntil: null,
                avgResponseTime: 0,
                successRate: 1.0,
                requestLog: []
            });
            console.log(`Added new RPC endpoint: ${url}`);
        }
    }
    // Remove an RPC endpoint
    removeEndpoint(url) {
        const index = this.endpoints.indexOf(url);
        if (index >= 0) {
            this.endpoints.splice(index, 1);
            this.endpointStats.splice(index, 1);
            // If current endpoint was removed, switch to another
            if (this.currentEndpointIndex === index) {
                this.switchEndpoint();
            } else if (this.currentEndpointIndex > index) {
                // Adjust current index if it's after the removed one
                this.currentEndpointIndex--;
            }
            console.log(`Removed RPC endpoint: ${url}`);
        }
    }
    // Prioritize a specific endpoint
    prioritizeEndpoint(url) {
        const index = this.endpoints.indexOf(url);
        if (index >= 0) {
            // Reset errors and cooldown
            const stats = this.endpointStats[index];
            stats.errorCount = 0;
            stats.consecutiveErrors = 0;
            stats.cooldownUntil = null;
            // Switch to this endpoint
            this.currentEndpointIndex = index;
            this.connection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Connection"](url, CONNECTION_CONFIG);
            console.log(`Prioritized RPC endpoint: ${url}`);
        }
    }
    // Check endpoint health and dynamically adjust request limits
    async checkEndpointHealth() {
        // Test all endpoints with a simple request
        for(let i = 0; i < this.endpoints.length; i++){
            const endpoint = this.endpoints[i];
            const stats = this.endpointStats[i];
            // Skip endpoints in cooldown
            if (stats.cooldownUntil && Date.now() < stats.cooldownUntil) {
                continue;
            }
            // Create isolated connection for health check
            const connection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Connection"](endpoint, CONNECTION_CONFIG);
            try {
                // Measure response time
                const startTime = performance.now();
                // Simple health check
                await connection.getSlot();
                const endTime = performance.now();
                const responseTime = endTime - startTime;
                // Update success stats
                stats.requestLog.push({
                    timestamp: Date.now(),
                    success: true,
                    responseTime
                });
                // Reset error counts slightly for successful check
                stats.consecutiveErrors = 0;
                if (stats.errorCount > 0) {
                    stats.errorCount = Math.max(0, stats.errorCount - 1);
                }
            } catch (error) {
                console.warn(`Health check failed for endpoint ${endpoint}:`, error);
                // Log failure
                stats.requestLog.push({
                    timestamp: Date.now(),
                    success: false
                });
                stats.errorCount++;
                stats.consecutiveErrors++;
            }
        }
        // Recalculate stats after health checks
        this.recalculateEndpointStats();
    }
    // Get health status for reporting
    getEndpointStatus() {
        const currentEndpoint = this.endpoints[this.currentEndpointIndex];
        const now = Date.now();
        return {
            currentEndpoint,
            endpointStats: this.endpointStats.map((stats)=>{
                // Determine status
                let status;
                if (stats.cooldownUntil && now < stats.cooldownUntil) {
                    status = 'cooldown';
                } else if (stats.successRate > 0.9 && stats.consecutiveErrors === 0) {
                    status = 'healthy';
                } else if (stats.successRate > 0.5) {
                    status = 'degraded';
                } else {
                    status = 'unhealthy';
                }
                return {
                    url: stats.url,
                    status,
                    successRate: Math.round(stats.successRate * 100) / 100,
                    avgResponseTime: Math.round(stats.avgResponseTime),
                    errorCount: stats.errorCount,
                    inCooldown: !!(stats.cooldownUntil && now < stats.cooldownUntil)
                };
            })
        };
    }
}
const connectionManager = new SolanaConnectionManager();
const getConnection = ()=>{
    return connectionManager.getConnection();
};
}}),
"[project]/src/lib/solana.ts [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// token-utils.ts
__turbopack_context__.s({
    "analyzeTokenRisks": (()=>analyzeTokenRisks),
    "checkTokenAccount": (()=>checkTokenAccount),
    "clearTokenCaches": (()=>clearTokenCaches),
    "createTokenAccountIfNeeded": (()=>createTokenAccountIfNeeded),
    "getRecentTransactions": (()=>getRecentTransactions),
    "getTokenAccounts": (()=>getTokenAccounts),
    "getTokenMetadata": (()=>getTokenMetadata),
    "getTransactionDetails": (()=>getTransactionDetails),
    "getWalletTokens": (()=>getWalletTokens)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/web3.js/lib/index.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/spl-token/lib/esm/constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$state$2f$mint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/spl-token/lib/esm/state/mint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$instructions$2f$associatedTokenAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/spl-token/lib/esm/instructions/associatedTokenAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/spl-token/lib/esm/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$state$2f$account$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/spl-token/lib/esm/state/account.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/solana-connection.ts [app-ssr] (ecmascript)");
;
;
;
// Cache results to reduce RPC calls
const tokenMetadataCache = {};
const tokenAccountsCache = {};
const riskAssessmentCache = {};
// Cache expiration times (in milliseconds)
const CACHE_TIMES = {
    TOKEN_METADATA: 30 * 60 * 1000,
    TOKEN_ACCOUNTS: 30 * 1000,
    RISK_ASSESSMENT: 60 * 60 * 1000
};
async function getTokenAccounts(walletAddress) {
    try {
        // Check cache first
        const cacheKey = `accounts:${walletAddress}`;
        const cachedData = tokenAccountsCache[cacheKey];
        if (cachedData && Date.now() - cachedData.timestamp < CACHE_TIMES.TOKEN_ACCOUNTS) {
            return cachedData.data;
        }
        const walletPublicKey = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PublicKey"](walletAddress);
        // Use the connection manager with improved fallback capability
        const accounts = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["connectionManager"].executeWithFallback(async (connection)=>{
            const tokenResp = await connection.getParsedTokenAccountsByOwner(walletPublicKey, {
                programId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TOKEN_PROGRAM_ID"]
            });
            return tokenResp.value;
        });
        // Update cache
        tokenAccountsCache[cacheKey] = {
            data: accounts,
            timestamp: Date.now()
        };
        return accounts;
    } catch (error) {
        console.error('Error fetching token accounts:', error);
        // Return cached data even if expired in case of error
        const cacheKey = `accounts:${walletAddress}`;
        const cachedData = tokenAccountsCache[cacheKey];
        if (cachedData) {
            console.log('Returning cached token accounts data due to RPC error');
            return cachedData.data;
        }
        throw error;
    }
}
async function getWalletTokens(walletAddress) {
    try {
        const accounts = await getTokenAccounts(walletAddress);
        // Filter to only include accounts with non-zero balance
        const filteredAccounts = accounts.filter((acc)=>parseInt(acc.account.data.parsed.info.tokenAmount.amount) > 0);
        // Map account data to WalletToken format
        const tokens = filteredAccounts.map((acc)=>{
            const parsedInfo = acc.account.data.parsed.info;
            return {
                mint: parsedInfo.mint,
                owner: walletAddress,
                amount: parsedInfo.tokenAmount.amount,
                decimals: parsedInfo.tokenAmount.decimals,
                uiAmount: parsedInfo.tokenAmount.uiAmount
            };
        });
        // Get metadata and risk assessment for each token (with batch processing)
        // Process tokens in batches to avoid overwhelming RPC nodes
        const BATCH_SIZE = 5;
        const tokensWithMetadata = [];
        for(let i = 0; i < tokens.length; i += BATCH_SIZE){
            const batch = tokens.slice(i, i + BATCH_SIZE);
            const batchResults = await Promise.all(batch.map(async (token)=>{
                // Fetch metadata and risk assessment in parallel, with caching
                const [metadata, riskAssessment] = await Promise.all([
                    getTokenMetadata(token.mint),
                    analyzeTokenRisks(token.mint)
                ]);
                // Determine risk level
                let riskLevel = undefined;
                if (riskAssessment) {
                    const { hasHighSupply, hasLowLiquidity, hasLargeHolders, isNewToken, hasSuspiciousTransactions } = riskAssessment;
                    // Calculate risk score (simple heuristic)
                    let riskFactors = 0;
                    if (hasHighSupply) riskFactors++;
                    if (hasLowLiquidity) riskFactors += 2;
                    if (hasLargeHolders) riskFactors += 2;
                    if (isNewToken) riskFactors++;
                    if (hasSuspiciousTransactions) riskFactors += 3;
                    // Assign risk level
                    if (riskFactors >= 5) riskLevel = 'critical';
                    else if (riskFactors >= 3) riskLevel = 'high';
                    else if (riskFactors >= 1) riskLevel = 'medium';
                    else riskLevel = 'low';
                }
                return {
                    ...token,
                    name: metadata?.name || 'Unknown Token',
                    symbol: metadata?.symbol || '',
                    logoURI: metadata?.logoURI,
                    riskLevel,
                    riskFactors: riskAssessment || {}
                };
            }));
            tokensWithMetadata.push(...batchResults);
            // If there are more batches to process, add a small delay to avoid rate limiting
            if (i + BATCH_SIZE < tokens.length) {
                await new Promise((resolve)=>setTimeout(resolve, 100));
            }
        }
        return tokensWithMetadata;
    } catch (error) {
        console.error('Error formatting wallet tokens:', error);
        throw error;
    }
}
async function getRecentTransactions(walletAddress, limit = 10) {
    try {
        const walletPublicKey = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PublicKey"](walletAddress);
        return await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["connectionManager"].executeWithFallback(async (connection)=>{
            return await connection.getSignaturesForAddress(walletPublicKey, {
                limit
            });
        }, 'confirmed', 5, 300 // Lower initial delay for faster first retry
        );
    } catch (error) {
        console.error('Error fetching recent transactions:', error);
        throw error;
    }
}
async function getTransactionDetails(signature) {
    try {
        return await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["connectionManager"].executeWithFallback(async (connection)=>{
            return await connection.getParsedTransaction(signature, 'confirmed');
        });
    } catch (error) {
        console.error('Error fetching transaction details:', error);
        throw error;
    }
}
async function checkTokenAccount(walletAddress, mintAddress) {
    try {
        const walletPublicKey = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PublicKey"](walletAddress);
        const mintPublicKey = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PublicKey"](mintAddress);
        // Get associated token account
        const tokenAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$state$2f$mint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAssociatedTokenAddress"])(mintPublicKey, walletPublicKey);
        try {
            // Check if account exists and get balance
            return await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["connectionManager"].executeWithFallback(async (connection)=>{
                return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$state$2f$account$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAccount"])(connection, tokenAddress);
            });
        } catch (error) {
            if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TokenAccountNotFoundError"] || error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TokenInvalidAccountOwnerError"]) {
                // Account doesn't exist
                return null;
            }
            throw error;
        }
    } catch (error) {
        console.error('Error checking token account:', error);
        throw error;
    }
}
async function getTokenMetadata(mintAddress) {
    try {
        // Check cache first
        const cacheKey = `metadata:${mintAddress}`;
        const cachedData = tokenMetadataCache[cacheKey];
        if (cachedData && Date.now() - cachedData.timestamp < CACHE_TIMES.TOKEN_METADATA) {
            return cachedData.data;
        }
        // Implement a circuit breaker pattern for the token API calls
        const fetchWithTimeout = async (url, timeout = 5000)=>{
            const controller = new AbortController();
            const timeoutId = setTimeout(()=>controller.abort(), timeout);
            try {
                const response = await fetch(url, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        };
        // First try to get from Jupiter Aggregator token list (more comprehensive)
        try {
            const jupiterResponse = await fetchWithTimeout('https://token.jup.ag/all');
            if (jupiterResponse.ok) {
                const jupiterTokens = await jupiterResponse.json();
                const token = jupiterTokens.find((t)=>t.address === mintAddress);
                if (token) {
                    const metadata = {
                        name: token.name,
                        symbol: token.symbol,
                        logoURI: token.logoURI
                    };
                    // Update cache
                    tokenMetadataCache[cacheKey] = {
                        data: metadata,
                        timestamp: Date.now()
                    };
                    return metadata;
                }
            }
        } catch (error) {
            console.warn('Jupiter token list fetch failed, falling back to Solana list:', error);
        }
        // Fallback to Solana token list
        try {
            const response = await fetchWithTimeout('https://cdn.jsdelivr.net/gh/solana-labs/token-list@main/src/tokens/solana.tokenlist.json');
            if (response.ok) {
                const tokenList = await response.json();
                const token = tokenList.tokens.find((t)=>t.address === mintAddress);
                if (token) {
                    const metadata = {
                        name: token.name,
                        symbol: token.symbol,
                        logoURI: token.logoURI
                    };
                    // Update cache
                    tokenMetadataCache[cacheKey] = {
                        data: metadata,
                        timestamp: Date.now()
                    };
                    return metadata;
                }
            }
        } catch (error) {
            console.warn('Solana token list fetch failed:', error);
        }
        // If not found in token lists, token might be unlisted
        const unknownToken = {
            name: 'Unknown Token',
            symbol: '???',
            logoURI: undefined
        };
        // Cache the unknown result too
        tokenMetadataCache[cacheKey] = {
            data: unknownToken,
            timestamp: Date.now()
        };
        return unknownToken;
    } catch (error) {
        console.error('Error fetching token metadata:', error);
        // Return cached data even if expired in case of error
        const cacheKey = `metadata:${mintAddress}`;
        const cachedData = tokenMetadataCache[cacheKey];
        if (cachedData) {
            return cachedData.data;
        }
        return null;
    }
}
async function analyzeTokenRisks(mintAddress) {
    try {
        // Check cache first
        const cacheKey = `risk:${mintAddress}`;
        const cachedData = riskAssessmentCache[cacheKey];
        if (cachedData && Date.now() - cachedData.timestamp < CACHE_TIMES.RISK_ASSESSMENT) {
            return cachedData.data;
        }
        const mintPublicKey = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PublicKey"](mintAddress);
        const riskData = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["connectionManager"].executeWithFallback(async (connection)=>{
            try {
                // Get token supply with retries and backoff
                const supplyPromise = connection.getTokenSupply(mintPublicKey).catch((error)=>{
                    console.warn('Error getting token supply, skipping this metric:', error);
                    return {
                        value: {
                            amount: '0'
                        }
                    };
                });
                // Get larger token holders with retries and backoff
                const holdersPromise = connection.getTokenLargestAccounts(mintPublicKey).catch((error)=>{
                    console.warn('Error getting token holders, skipping this metric:', error);
                    return {
                        value: []
                    };
                });
                // Get token creation info with retries and backoff
                const signaturesPromise = connection.getSignaturesForAddress(mintPublicKey, {
                    limit: 1
                }).catch((error)=>{
                    console.warn('Error getting token signatures, skipping this metric:', error);
                    return [];
                });
                // Execute all queries in parallel
                const [supply, largestAccounts, signatures] = await Promise.all([
                    supplyPromise,
                    holdersPromise,
                    signaturesPromise
                ]);
                // Token creation date check
                const isNewToken = signatures.length > 0 && new Date().getTime() - new Date(signatures[0].blockTime * 1000).getTime() < 7 * 24 * 60 * 60 * 1000; // 7 days
                // Analyze token distribution
                const totalAccounts = largestAccounts.value.length;
                const largestHolderPercentage = largestAccounts.value[0] ? parseInt(largestAccounts.value[0].amount) / parseInt(supply.value.amount) : 0;
                const riskAssessment = {
                    hasHighSupply: parseInt(supply.value.amount) > 1_000_000_000_000_000,
                    hasLowLiquidity: totalAccounts < 10,
                    hasLargeHolders: largestHolderPercentage > 0.8,
                    isNewToken: isNewToken,
                    hasSuspiciousTransactions: false
                };
                // Update cache
                riskAssessmentCache[cacheKey] = {
                    data: riskAssessment,
                    timestamp: Date.now()
                };
                return riskAssessment;
            } catch (error) {
                console.warn('Error in token risk analysis, continuing with partial data:', error);
                // Return default values in case of error with this specific analysis
                const defaultRisk = {
                    hasHighSupply: false,
                    hasLowLiquidity: false,
                    hasLargeHolders: false,
                    isNewToken: false,
                    hasSuspiciousTransactions: false
                };
                // Update cache even for default values
                riskAssessmentCache[cacheKey] = {
                    data: defaultRisk,
                    timestamp: Date.now()
                };
                return defaultRisk;
            }
        });
        return riskData;
    } catch (error) {
        console.error('Error analyzing token risks:', error);
        // Return cached data even if expired in case of error
        const cacheKey = `risk:${mintAddress}`;
        const cachedData = riskAssessmentCache[cacheKey];
        if (cachedData) {
            return cachedData.data;
        }
        return null;
    }
}
async function createTokenAccountIfNeeded(wallet, mintAddress) {
    try {
        const walletPublicKey = wallet.publicKey;
        const mintPublicKey = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PublicKey"](mintAddress);
        // Get associated token account address
        const tokenAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$state$2f$mint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAssociatedTokenAddress"])(mintPublicKey, walletPublicKey);
        // Check if account exists
        try {
            await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["connectionManager"].executeWithFallback(async (connection)=>{
                return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$state$2f$account$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAccount"])(connection, tokenAddress);
            });
            return tokenAddress.toString();
        } catch (error) {
            if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TokenAccountNotFoundError"] || error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TokenInvalidAccountOwnerError"]) {
                // Account doesn't exist, create it
                return await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["connectionManager"].executeWithFallback(async (connection)=>{
                    const transaction = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$web3$2e$js$2f$lib$2f$index$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Transaction"]().add((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$spl$2d$token$2f$lib$2f$esm$2f$instructions$2f$associatedTokenAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAssociatedTokenAccountInstruction"])(walletPublicKey, tokenAddress, walletPublicKey, mintPublicKey));
                    const signature = await wallet.sendTransaction(transaction, connection);
                    await connection.confirmTransaction(signature, 'confirmed');
                    return tokenAddress.toString();
                });
            }
            throw error;
        }
    } catch (error) {
        console.error('Error creating token account:', error);
        throw error;
    }
}
function clearTokenCaches() {
    Object.keys(tokenMetadataCache).forEach((key)=>{
        delete tokenMetadataCache[key];
    });
    Object.keys(tokenAccountsCache).forEach((key)=>{
        delete tokenAccountsCache[key];
    });
    Object.keys(riskAssessmentCache).forEach((key)=>{
        delete riskAssessmentCache[key];
    });
}
}}),
"[project]/src/context/WalletContext.tsx [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "WalletContextProvider": (()=>WalletContextProvider),
    "default": (()=>__TURBOPACK__default__export__),
    "useWalletContext": (()=>useWalletContext)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$react$2f$lib$2f$esm$2f$ConnectionProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$react$2f$lib$2f$esm$2f$WalletProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$react$2f$lib$2f$esm$2f$useWallet$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$base$2f$lib$2f$esm$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-base/lib/esm/types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$phantom$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-phantom/lib/esm/adapter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$solflare$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-solflare/lib/esm/adapter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$torus$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-torus/lib/esm/adapter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$ledger$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-ledger/lib/esm/adapter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$clover$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-clover/lib/esm/adapter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$react$2d$ui$2f$lib$2f$esm$2f$WalletModalProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/solana.ts [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/solana-connection.ts [app-ssr] (ecmascript)");
'use client';
;
;
;
;
;
;
;
;
;
// Create context with defaults
const WalletContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createContext"])({
    walletAddress: null,
    connected: false,
    tokens: [],
    isLoadingTokens: false,
    error: null,
    riskSummary: {
        highRiskCount: 0,
        mediumRiskCount: 0,
        lowRiskCount: 0,
        unknownCount: 0,
        totalTokens: 0
    },
    refreshTokens: async ()=>{},
    clearError: ()=>{}
});
const useWalletContext = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useContext"])(WalletContext);
const WalletContextProvider = ({ children })=>{
    // Configure Solana network
    const network = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$base$2f$lib$2f$esm$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WalletAdapterNetwork"].Mainnet;
    // Use our custom RPC connection configuration
    // Instead of clusterApiUrl(network), we now use our managed connection
    const endpoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2d$connection$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getConnection"])().rpcEndpoint;
    // Set up wallet adapters
    const wallets = [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$phantom$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PhantomWalletAdapter"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$solflare$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SolflareWalletAdapter"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$torus$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TorusWalletAdapter"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$ledger$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LedgerWalletAdapter"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$clover$2f$lib$2f$esm$2f$adapter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CloverWalletAdapter"]()
    ];
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxDEV"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$react$2f$lib$2f$esm$2f$ConnectionProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ConnectionProvider"], {
        endpoint: endpoint,
        children: /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxDEV"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$react$2f$lib$2f$esm$2f$WalletProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WalletProvider"], {
            wallets: wallets,
            autoConnect: true,
            children: /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxDEV"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$react$2d$ui$2f$lib$2f$esm$2f$WalletModalProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WalletModalProvider"], {
                children: /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxDEV"])(WalletDataProvider, {
                    children: children
                }, void 0, false, {
                    fileName: "[project]/src/context/WalletContext.tsx",
                    lineNumber: 85,
                    columnNumber: 11
                }, this)
            }, void 0, false, {
                fileName: "[project]/src/context/WalletContext.tsx",
                lineNumber: 84,
                columnNumber: 9
            }, this)
        }, void 0, false, {
            fileName: "[project]/src/context/WalletContext.tsx",
            lineNumber: 83,
            columnNumber: 7
        }, this)
    }, void 0, false, {
        fileName: "[project]/src/context/WalletContext.tsx",
        lineNumber: 82,
        columnNumber: 5
    }, this);
};
// Inner provider that handles the data
const WalletDataProvider = ({ children })=>{
    const { publicKey, connected } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$solana$2f$wallet$2d$adapter$2d$react$2f$lib$2f$esm$2f$useWallet$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useWallet"])();
    const walletAddress = publicKey?.toBase58() || null;
    const [tokens, setTokens] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])([]);
    const [isLoadingTokens, setIsLoadingTokens] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(false);
    const [error, setError] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(null);
    const [lastFetchAttempt, setLastFetchAttempt] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useState"])(0);
    // Calculate risk summary
    const riskSummary = {
        highRiskCount: tokens.filter((t)=>t.riskLevel === 'high' || t.riskLevel === 'critical').length,
        mediumRiskCount: tokens.filter((t)=>t.riskLevel === 'medium').length,
        lowRiskCount: tokens.filter((t)=>t.riskLevel === 'low').length,
        unknownCount: tokens.filter((t)=>!t.riskLevel).length,
        totalTokens: tokens.length
    };
    // Clear error state
    const clearError = ()=>{
        setError(null);
    };
    // Fetch tokens with error handling and debouncing
    const fetchTokens = async ()=>{
        if (!walletAddress) {
            setTokens([]);
            return;
        }
        // Avoid repeated fetching on errors (simple debouncing)
        const now = Date.now();
        if (now - lastFetchAttempt < 10000) {
            return;
        }
        setLastFetchAttempt(now);
        setIsLoadingTokens(true);
        setError(null);
        try {
            const walletTokens = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$solana$2e$ts__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWalletTokens"])(walletAddress);
            setTokens(walletTokens);
        } catch (error) {
            console.error('Error fetching wallet tokens:', error);
            // Format a user-friendly error message
            let errorMessage = 'Failed to load tokens. ';
            if (error?.message?.includes('403') || error?.message?.includes('Access forbidden')) {
                errorMessage += 'The RPC server connection was blocked. This could be due to rate limiting.';
            } else if (error?.message?.includes('429') || error?.message?.includes('Too many requests')) {
                errorMessage += 'Too many requests to the Solana network. Please try again in a moment.';
            } else if (error?.message?.includes('timeout')) {
                errorMessage += 'The connection to Solana network timed out. Please check your internet connection.';
            } else {
                errorMessage += error?.message || 'Unknown error occurred.';
            }
            setError(errorMessage);
        // Return a minimal set of tokens if we have them cached
        // This allows the UI to continue functioning with stale data if needed
        } finally{
            setIsLoadingTokens(false);
        }
    };
    // Refresh tokens (for manual refresh)
    const refreshTokens = async ()=>{
        // Reset last fetch attempt to force a refresh
        setLastFetchAttempt(0);
        await fetchTokens();
    };
    // Initial fetch and refresh on wallet change
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (connected && walletAddress) {
            fetchTokens();
        } else {
            setTokens([]);
            clearError();
        }
    }, [
        walletAddress,
        connected
    ]);
    const contextValue = {
        walletAddress,
        connected,
        tokens,
        isLoadingTokens,
        error,
        riskSummary,
        refreshTokens,
        clearError
    };
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxDEV"])(WalletContext.Provider, {
        value: contextValue,
        children: children
    }, void 0, false, {
        fileName: "[project]/src/context/WalletContext.tsx",
        lineNumber: 193,
        columnNumber: 5
    }, this);
};
const __TURBOPACK__default__export__ = WalletContextProvider;
}}),
"[project]/src/react-query/index.tsx [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Providers": (()=>Providers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$queryClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/modern/queryClient.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$context$2f$WalletContext$2e$tsx__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/context/WalletContext.tsx [app-ssr] (ecmascript)");
'use client';
;
;
;
// import { NotificationProvider } from '@/contexts/NotificationContext';
// import { TokenAnalysisProvider } from '@/contexts/TokenAnalysisContext';
// Create a client
const queryClient = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$queryClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["QueryClient"]({
    defaultOptions: {
        queries: {
            refetchOnWindowFocus: false,
            retry: 1
        }
    }
});
function Providers({ children }) {
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxDEV"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["QueryClientProvider"], {
        client: queryClient,
        children: /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxDEV"])(__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$context$2f$WalletContext$2e$tsx__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WalletContextProvider"], {
            children: children
        }, void 0, false, {
            fileName: "[project]/src/react-query/index.tsx",
            lineNumber: 22,
            columnNumber: 7
        }, this)
    }, void 0, false, {
        fileName: "[project]/src/react-query/index.tsx",
        lineNumber: 21,
        columnNumber: 5
    }, this);
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__070d8a2e._.js.map